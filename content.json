{"meta":{"title":"胡闹的日子","subtitle":null,"description":"我想在变化很快的年代里，必须要坚持些什么","author":"XCC","url":"http://blog.iamxcc.com"},"pages":[{"title":"404","date":"2016-08-09T09:05:24.586Z","updated":"2016-08-09T09:05:24.586Z","comments":true,"path":"404.html","permalink":"http://blog.iamxcc.com/404.html","excerpt":"","text":""},{"title":"","date":"2016-08-13T03:37:19.172Z","updated":"2016-08-13T03:37:19.172Z","comments":true,"path":"README.html","permalink":"http://blog.iamxcc.com/README.html","excerpt":"","text":"hexo-source"},{"title":"","date":"2016-06-21T02:03:29.832Z","updated":"2016-05-17T23:30:47.000Z","comments":true,"path":"google46447695f1c84c21.html","permalink":"http://blog.iamxcc.com/google46447695f1c84c21.html","excerpt":"","text":"google-site-verification: google46447695f1c84c21.html"},{"title":"","date":"2016-08-05T13:57:53.778Z","updated":"2016-08-05T13:57:53.778Z","comments":true,"path":"baidu_verify_8J7kG66Rha.html","permalink":"http://blog.iamxcc.com/baidu_verify_8J7kG66Rha.html","excerpt":"","text":"8J7kG66Rha"},{"title":"分类","date":"2016-08-04T11:10:57.697Z","updated":"2016-08-04T11:10:57.697Z","comments":true,"path":"categories/index.html","permalink":"http://blog.iamxcc.com/categories/index.html","excerpt":"","text":""},{"title":"About","date":"2016-08-07T23:55:06.007Z","updated":"2016-08-07T23:55:06.007Z","comments":true,"path":"about/index.html","permalink":"http://blog.iamxcc.com/about/index.html","excerpt":"","text":"The blog theme you may fall in love with, coming to Hexo. Preview InstallationInstall1$ git clone https://github.com/ppoffice/hexo-theme-icarus.git themes/icarus Icarus requires Hexo 3.0 and above. Enable Rename themes\\icarus\\_config.yml.example to themes\\icarus\\_config.yml; Copy themes\\icarus\\_config.yml.site.example to your hexo blog’s root directory and rename it to _config.yml; Copy themes\\icarus\\_source\\* into your hexo blog’s directory source; Then modify theme setting in _config.yml to icarus. Update12cd themes/icarusgit pull ConfigurationTheme configuration example1234567891011121314151617181920212223242526272829303132333435363738394041# Headermenu: Home: . Archives: archives Categories: categories # you need to add extra page to enable this, please see the config below. Tags: tags # you need to add extra page to enable this, please see the config below. About: about# Contentexcerpt_link: Read Morefancybox: true# Sidebarsidebar: rightwidgets:- recent_posts- category- tag- tagcloud- archivethumbnail: true# Contactscontacts: github: http://github.com/ppoffice/hexo-theme-icarus twitter: '#' facebook: '#' dribbble: '#' rss: atom.xml# Linkslinks: Hexo: http://hexo.io# Miscellaneousgoogle_analytics:favicon: favicon.pngtwitter:google_plus:fb_admins:fb_app_id: excerpt_link - Cooperate with &lt;!-- more --&gt; tag to show only part of the article in index pages. fancybox - Enable Fancybox. contacts - Your social network links, RSS link, etc. widgets - Widgets displaying in sidebar. thumbnail - Whether to show post thumbnails in the sidebar and archive pages. links - Links displayed in the link widget. google_analytics - Google Analytics ID. favicon - Favicon path. Site configuration example123456789101112131415# Sitetitle: Icarussubtitle:description: Hexo theme - Icarusauthor: PPOfficeauthor_title: 'Web Developer &amp; Designer'avatar: css/images/avatar.pnglocation: 'Harbin, China'language: entimezone:...# Disqusdisqus_shortname: author - Your name. author_title - Title to your occupation. avatar - Your avatar image link. location - Where you live in. disqus_shortname - Your Disqus shortname. Post Thumbnail &amp; BannerYou can add a thumbnail and a banner to each post by adding the following lines into your post source files’ front-matter:123456title: Demodate: 2015-01-01...# add thosethumbnail: http://example.com/thumbnail.jpgbanner: http://example.com/banner.jpg Custom Categories &amp; Tags PagesTo enable custom categories page and tags page, just copy the categories folder and tags folder under your theme’s _source foler into your site’s source folder. Then edit theme’s _config.yml and add the following lines:123456# Headermenu: ... Categories: categories # -&gt; add this line Tags: tags # -&gt; and add this line ... LanguagesEnglish and Simplified Chinese are the default languages of the theme. You can add translations in the languages folder and change the default language in blog’s _config.yml. 1language: zh-CN FeaturesProfile SidebarA nice place to show yourself. You can add your own information in your site’s _config.yml Post Banner &amp; ThumbnailThanks to atika, you can now add thumbnails and banners to every post to create better reading experience. Responsive LayoutIcarus knows on what screen size you are browsering the website, and reorganize the layout to fit your device. Custom Categories &amp; Tags PagesGet your categories and tags listed in single pages to make your blog more methodic. FancyboxIcarus uses Fancybox to showcase your photos. You can use Markdown syntax or fancybox tag plugin to add your photos. 1![img caption](img url) SidebarIcarus provides 6 built-in widgets: recent_posts category archives tag tagcloud links All of them are enabled by default. You can edit them in widget setting. DevelopmentRequirements Grunt 0.4+ Hexo 3.0+ Grunt tasks default - Download Fancybox and Font Awesome. fontawesome - Only download Font Awesome. fancybox - Only download Fancybox. clean - Clean temporarily files and downloaded files."},{"title":"message","date":"2016-08-13T14:47:13.000Z","updated":"2016-08-13T14:47:39.689Z","comments":true,"path":"message/index.html","permalink":"http://blog.iamxcc.com/message/index.html","excerpt":"","text":""},{"title":"search","date":"2016-07-26T15:35:55.179Z","updated":"2016-05-16T06:06:40.000Z","comments":true,"path":"search/index.html","permalink":"http://blog.iamxcc.com/search/index.html","excerpt":"","text":""},{"title":"标签","date":"2016-08-04T11:11:07.073Z","updated":"2016-08-04T11:11:07.073Z","comments":true,"path":"tags/index.html","permalink":"http://blog.iamxcc.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"小球下落问题","slug":"小球下落问题","date":"2016-08-16T09:56:31.000Z","updated":"2016-08-18T15:57:55.561Z","comments":true,"path":"2016/08/16/小球下落问题/","link":"","permalink":"http://blog.iamxcc.com/2016/08/16/小球下落问题/","excerpt":"一颗二叉树，最大深度为D,且所有叶子的深度都相同。所有节点从上到下，从左到右编号为1,2,3…,2^D-1。","text":"一颗二叉树，最大深度为D,且所有叶子的深度都相同。所有节点从上到下，从左到右编号为1,2,3…,2^D-1。 在节点1处放一个小球，它会往下落。每个内节点上都有一个开关，初始全部关闭，当每次有小球落到一个开关上时，它的状态都会改变。当小球到达一个内节点时，如果该节点上的开关关闭，则往左走，否则，往右 走，知道走到叶子节点，如图所示:一些小球从节点1处一次开始下落，最后一个小球将会落到哪里呢？输入叶子深度D和小球个数I,输出第I个小球最后所在的叶子编号。假设I不超过整棵树的叶子个数。D&lt;=20,输入最多包含1000组数据。 输入:1234564 2 3 4 10 1 2 2 8 128 16 12345 输出:12345612 7 512 3 255 36358 Code123456789101112131415161718192021222324252627282930313233#define _CRT_SECURE_NO_DEPRECATE#include&lt;stdio.h&gt;#include&lt;math.h&gt;#include&lt;string.h&gt;const int maxD = 20;int switcher[1 &lt;&lt; maxD] = &#123; 0 &#125;;int maxNum = 0;int main()&#123; int D = 0; int I = 0; while (scanf(\"%d%d\", &amp;D, &amp;I) == 2) &#123; memset(switcher, 0, sizeof(switcher)); maxNum = (1 &lt;&lt; D) - 1; int k; for (int i = 0; i &lt; I; i++) &#123; k = 1; while (true) &#123; switcher[k] = !switcher[k]; k = switcher[k] ? k * 2 : k * 2 + 1; if (k &gt; maxNum) &#123; break; &#125; &#125; &#125; printf(\"%d\\n\", k/2); &#125; return 0;&#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://blog.iamxcc.com/categories/数据结构/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://blog.iamxcc.com/tags/数据结构/"},{"name":"二叉树","slug":"二叉树","permalink":"http://blog.iamxcc.com/tags/二叉树/"}]},{"title":"二叉排序树的建立与遍历","slug":"二叉排序树的建立与遍历","date":"2016-08-16T08:39:25.000Z","updated":"2016-08-18T15:59:18.277Z","comments":true,"path":"2016/08/16/二叉排序树的建立与遍历/","link":"","permalink":"http://blog.iamxcc.com/2016/08/16/二叉排序树的建立与遍历/","excerpt":"二叉排序树的建立与遍历基本没什么花样可变，这里做个记录，方便下次查阅。","text":"二叉排序树的建立与遍历基本没什么花样可变，这里做个记录，方便下次查阅。 题目描述：输入一系列整数，建立二叉排序数，并进行前序，中序，后序遍历。 输入：输入第一行包括一个整数n(1&lt;=n&lt;=100)。接下来的一行包括n个整数。 输出：可能有多组测试数据，对于每组数据，将题目所给数据建立一个二叉排序树，并对二叉排序树进行前序、中序和后序遍历。每种遍历结果输出一行。每行最后一个数据之后有一个空格。 样例输入：1251 6 5 9 8 样例输出：1231 6 5 9 8 1 5 6 8 9 5 8 9 6 1 提示：输入中可能有重复元素，但是输出的二叉树遍历序列中重复元素不用输出。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#define _CRT_SECURE_NO_DEPRECATE#include &lt;stdio.h&gt;struct Node&#123; Node *lchild; Node *rchild; int c;&#125;tree[110];int index;Node* createNode()&#123; tree[index].lchild = tree[index].rchild = NULL; return &amp;tree[index++];&#125;// preorder traversalvoid preOrder(Node *T)&#123; printf(\"%d \", T-&gt;c); if (T-&gt;lchild != NULL) &#123; preOrder(T-&gt;lchild); &#125; if (T-&gt;rchild != NULL) &#123; preOrder(T-&gt;rchild); &#125;&#125;// inorder traversalvoid inOrder(Node *T)&#123; if (T-&gt;lchild != NULL) &#123; inOrder(T-&gt;lchild); &#125; printf(\"%d \", T-&gt;c); if (T-&gt;rchild != NULL) &#123; inOrder(T-&gt;rchild); &#125;&#125;// postorder traversalvoid postOrder(Node *T)&#123; if (T-&gt;lchild != NULL) &#123; postOrder(T-&gt;lchild); &#125; if (T-&gt;rchild != NULL) &#123; postOrder(T-&gt;rchild); &#125; printf(\"%d \", T-&gt;c);&#125;Node* insert(Node *T, int x)&#123; if (T == NULL) &#123; T = createNode(); T-&gt;c = x; return T; &#125; if (T-&gt;c &lt; x) &#123; T-&gt;rchild = insert(T-&gt;rchild, x); &#125; if (T-&gt;c &gt; x) &#123; T-&gt;lchild = insert(T-&gt;lchild, x); &#125; return T;&#125;int main() &#123; int n = 0; while (scanf(\"%d\", &amp;n) != EOF) &#123; index = 0; Node *root = NULL; for (int i = 0; i &lt; n; i++) &#123; int x; scanf(\"%d\", &amp;x); root = insert(root, x); &#125; preOrder(root); printf(\"\\n\"); inOrder(root); printf(\"\\n\"); postOrder(root); printf(\"\\n\"); &#125; return 0;&#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://blog.iamxcc.com/categories/数据结构/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://blog.iamxcc.com/tags/数据结构/"},{"name":"二叉树","slug":"二叉树","permalink":"http://blog.iamxcc.com/tags/二叉树/"}]},{"title":"STL中的栈","slug":"STL中的栈","date":"2016-08-15T05:21:50.000Z","updated":"2016-08-18T16:00:07.133Z","comments":true,"path":"2016/08/15/STL中的栈/","link":"","permalink":"http://blog.iamxcc.com/2016/08/15/STL中的栈/","excerpt":"栈是一种数据项按序排列的数据结构，只能在它的一端进行删除和插入。","text":"栈是一种数据项按序排列的数据结构，只能在它的一端进行删除和插入。 最近在学习STL中一些基础数据结构的模板。因为C语言在使用这些数据结构之前还得自己实现一遍，很是麻烦。而STL中已经帮我们封装好了这些数据结构的内部操作。 栈的基本用法头文件首先使用stack标准模板之前我们需要在加上头文件#include &lt;stack&gt;。并要声明使用标准命名空间using namespace std;。 然后使用stack&lt;int&gt; S;定义一个保存int类型数据的栈S，这样所有有关栈实现的内部操作，STL都已经帮我们实现好了。 内部操作 使用S.push()向栈中压进一个数值为i的元素。 使用int x = S.top()读取栈顶元素，并将其值赋予给x。 使用S.pop()弹出栈顶元素。 具体例子括号匹配问题题目描述：在某个字符串（长度不超过100）中有左括号、右括号和大小写字母；规定（与常见的算数式子一样）任何一个左括号都从内到外与在它右边且距离最近的右括号匹配。写一个程序，找到无法匹配的左括号和右括号，输出原来字符串，并在下一行标出不能匹配的括号。不能匹配的左括号用”$”标注,不能匹配的右括号用”?”标注. 输入：输入包括多组数据，每组数据一行，包含一个字符串，只包含左右括号和大小写字母，字符串长度不超过100。注意：cin.getline(str,100)最多只能输入99个字符！ 输出：对每组输出数据，输出两行，第一行包含原始输入字符，第二行由”$”,”?”和空格组成，”$”和”?”表示与之对应的左括号和右括号不能匹配。 样例输入：1)(rttyy())sss)( 样例输出：12)(rttyy())sss)(? ?$ Code1234567891011121314151617181920212223242526272829303132333435#include &lt;stdio.h&gt;#include &lt;stack&gt;using namespace std;stack&lt;int&gt; S;char str[110];char res[110];int main() &#123; while(scanf(\"%s\", str) != EOF) &#123; for (int i = 0; str[i] != 0; i++) &#123; if (str[i] == '(') &#123; S.push(i); res[i] = ' '; &#125; else if (str[i] == ')') &#123; if (S.empty() == false) &#123; S.pop(); res[i] = ' '; &#125; else &#123; res[i] = '?'; &#125; &#125; else &#123; res[i] = ' '; &#125; &#125; while (!S.empty()) &#123; res[S.top()] = '$'; S.pop(); &#125; res[i] = 0; puts(str); puts(res); &#125; return 0;&#125; 简单计数器题目描述：读入一个只包含 +, -, *, / 的非负整数计算表达式，计算该表达式的值。 输入：测试输入包含若干测试用例，每个测试用例占一行，每行不超过200个字符，整数和运算符之间用一个空格分隔。没有非法表达式。当一行中只有0时输入结束，相应的结果不要输出。 输出：对每个测试用例输出1行，即该表达式的值，精确到小数点后2位。 样例输入：1231 + 24 + 2 * 5 - 7 / 110 样例输出：123.0013.36 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115#define _CRT_SECURE_NO_DEPRECATE#include &lt;stdio.h&gt;#include &lt;stack&gt;using namespace std;stack&lt;double&gt; digit;stack&lt;int&gt; op;char str[110];int mat[][5] = &#123; 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0&#125;;// reto is true =&gt; oparator// reto is false =&gt; numbervoid getOp(bool &amp;reto, int &amp;retn, int &amp;i) &#123; if (i == 0 &amp;&amp; op.empty()) &#123; reto = true; retn = 0; return; &#125; if (str[i] == 0) &#123; reto = true; retn = 0; return; &#125; if (str[i] &gt;= '0' &amp;&amp; str[i] &lt;= '9') &#123; reto = false; retn = 0; for (; str[i] != ' ' &amp;&amp; str[i] != 0; i++) &#123; retn *= 10; retn += str[i] - '0'; &#125; if (str[i] == ' ') &#123; i++; &#125; return; &#125; else &#123; reto = true; if (str[i] == '+') &#123; retn = 1; &#125; else if (str[i] == '-') &#123; retn = 2; &#125; else if (str[i] == '*') &#123; retn = 3; &#125; else if (str[i] == '/') &#123; retn = 4; &#125; i += 2; return; &#125;&#125;int main() &#123; while (gets_s(str)) &#123; if (str[0] == '0' &amp;&amp; str[1] == 0) &#123; break; &#125; bool retop; int retnum; int idx = 0; while (!op.empty()) &#123; op.pop(); &#125; while (!digit.empty()) &#123; digit.pop(); &#125; while (true) &#123; getOp(retop, retnum, idx); if (retop == false) &#123; digit.push((double)retnum); &#125; else &#123; double tmp; if (op.empty() == true || mat[retnum][op.top()] == 1) &#123; op.push(retnum); &#125; else &#123; while (mat[retnum][op.top()] == 0) &#123; int ret = op.top(); op.pop(); double b = digit.top(); digit.pop(); double a = digit.top(); digit.pop(); if (ret == 1) &#123; tmp = a + b; &#125; else if (ret == 2) &#123; tmp = a - b; &#125; else if (ret == 3) &#123; tmp = a * b; &#125; else &#123; tmp = a / b; &#125; digit.push(tmp); &#125; op.push(retnum); &#125; &#125; if (op.size() == 2 &amp;&amp; op.top() == 0) &#123; break; &#125; &#125; printf(\"%.2f\\n\", digit.top()); &#125; return 0;&#125;","categories":[{"name":"C++","slug":"C","permalink":"http://blog.iamxcc.com/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://blog.iamxcc.com/tags/C/"},{"name":"STL","slug":"STL","permalink":"http://blog.iamxcc.com/tags/STL/"},{"name":"栈","slug":"栈","permalink":"http://blog.iamxcc.com/tags/栈/"}]},{"title":"日期类问题","slug":"日期类问题","date":"2016-08-15T03:51:59.000Z","updated":"2016-08-18T16:01:13.053Z","comments":true,"path":"2016/08/15/日期类问题/","link":"","permalink":"http://blog.iamxcc.com/2016/08/15/日期类问题/","excerpt":"给两个日期怎么计算两者间的日期差数，其中还要考虑闰年。","text":"给两个日期怎么计算两者间的日期差数，其中还要考虑闰年。 闰年的判断规则是：当年数不能被100整除时若其能被4整除则为闰年，或者其能被400整除时也是闰年。有了这个规则，怎么写就简单了。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;stdio.h&gt;// 定义宏判断是否为闰年#define ISYEAP(x) x%100 != 0 &amp;&amp; x%4 == 0 || x%400 == 0 int dayOfMonth[13][2] = &#123; 0, 0, 31, 31, 28, 29, 31, 31, 30, 30, 31, 31, 30, 30, 31, 31, 31, 31, 30, 30, 31, 31, 30, 30, 31, 31&#125;;struct Date &#123; int day; int month; int year; void nextDay() &#123; day++; if (day &gt; dayOfMonth[month][ISYEAP(year)]) &#123; day = 1; month++; if (month &gt; 12) &#123; month = 1; year++; &#125; &#125; &#125;&#125;;int buf[5001][13][32];int Abs(int x) &#123; return x &lt; 0 ? -x : x;&#125;int main() &#123; Date tmp; int count = 0; // 计算日期与0000年1月1日的天数差 tmp.day = 1; tmp.month = 1; tmp.year = 0; while (tmp.year != 5001) &#123; buf[tmp.year][tmp.month][tmp.day] = count; tmp.nextDay(); count++; &#125; int d1, m1, y1; int d2, m2, y2; while (scanf(\"%4d%2d%2d\", &amp;y1, &amp;m1, &amp;d1) != EOF) &#123; scanf(\"%4d%2d%2d\", &amp;y2, &amp;m2, &amp;d2); printf(\"%d\\n\", Abs(buf[y2][m2][d2] - buf[y1][m1][d1]) + 1); &#125; return 0;&#125; 从上面的代码可以看到buf是个三维数组而且还挺大的，所以我们把他定义为全局变量。如果将其定义在函数main中，那么函数所可以使用的栈空间将不足以提供如此庞大的内存，出现栈溢出。 有了这个模板，其他日期类的问题基本就可以解决了。 如给一个日期，输出星期几：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#include &lt;stdio.h&gt;#include &lt;string.h&gt;// 定义宏判断是否为闰年#define ISYEAP(x) x%100 != 0 &amp;&amp; x%4 == 0 || x%400 == 0 int dayOfMonth[13][2] = &#123; 0, 0, 31, 31, 28, 29, 31, 31, 30, 30, 31, 31, 30, 30, 31, 31, 31, 31, 30, 30, 31, 31, 30, 30, 31, 31&#125;;struct Date &#123; int day; int month; int year; void nextDay() &#123; day++; if (day &gt; dayOfMonth[month][ISYEAP(year)]) &#123; day = 1; month++; if (month &gt; 12) &#123; month = 1; year++; &#125; &#125; &#125;&#125;;int buf[3001][13][32];char monthName[13][20] = &#123; \"\", \"January\", \"February\", \"March\", \"April\", \"May\", \"June\", \"July\", \"August\", \"September\", \"October\", \"November\", \"December\"&#125;;char weekName[7][20] = &#123; \"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"&#125;;int main() &#123; Date tmp; int count = 0; // 计算日期与0000年1月1日的天数差 tmp.day = 1; tmp.month = 1; tmp.year = 0; while (tmp.year != 3001) &#123; buf[tmp.year][tmp.month][tmp.day] = count; tmp.nextDay(); count++; &#125; int d, m, y; char s[20]; while (scanf(\"%d%s%d\", &amp;d, s, &amp;y) != EOF) &#123; for (m = 1; m &lt;= 12; m++) &#123; if (strcmp(s, monthName[m]) == 0) &#123; break; &#125; &#125; int days = buf[y][m][d] - buf[2016][8][15]; days++; printf(\"%s\\n\", weekName[(days%7 + 7) % 7]); &#125; return 0;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://blog.iamxcc.com/categories/算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://blog.iamxcc.com/tags/算法/"}]},{"title":"C和C++结构体的区别","slug":"C和C-结构体的区别","date":"2016-08-15T02:55:24.000Z","updated":"2016-08-18T16:00:35.173Z","comments":true,"path":"2016/08/15/C和C-结构体的区别/","link":"","permalink":"http://blog.iamxcc.com/2016/08/15/C和C-结构体的区别/","excerpt":"最近在学习C++，发现它的结构体使用起来比C语言的结构体还要方便一些。具体的区别如下:","text":"最近在学习C++，发现它的结构体使用起来比C语言的结构体还要方便一些。具体的区别如下: 1.C结构体变量定义时,若为struct 结构体名 变量名, struct不能省,而C++中则可以省去struct.1234567// Cstruct Node &#123; int val; Node *next;&#125;;struct Node p; // 定义结构变量struct Node *p1; // 定义结构指针 可以看到其中的struct都不可以省略，如果想要省略还需要加上typedef。1234567// Ctypedef struct Node &#123; int val; Node *next;&#125;Node;Node p; // 定义结构变量Node *p1; // 定义结构指针 加上typedef之后，就可以直接声明变量了。然而在C++中是可以直接声明的。1234567// C++struct Node &#123; int val; Node *next;&#125;;Node p; // 定义结构变量Node *p1; // 定义结构指针 可以看到C++还是方便一些的。 2.C 结构体中只能定义成员变量,而不能定义成员函数,.而C++结构体则可以有成员变量也可以定义成员函数.3.C 结构体中只能定义成员变量,而不能定义成员函数,.而C++结构体则可以有成员变量也可以定义成员函数.","categories":[{"name":"C++","slug":"C","permalink":"http://blog.iamxcc.com/categories/C/"}],"tags":[{"name":"C","slug":"C","permalink":"http://blog.iamxcc.com/tags/C/"},{"name":"C++","slug":"C","permalink":"http://blog.iamxcc.com/tags/C/"}]},{"title":"排序实例","slug":"排序实例","date":"2016-08-14T13:37:31.000Z","updated":"2016-08-14T13:53:34.292Z","comments":true,"path":"2016/08/14/排序实例/","link":"","permalink":"http://blog.iamxcc.com/2016/08/14/排序实例/","excerpt":"今天发现使用C++的sort比C的qsort还要方便一些，为了说明sort的使用方法，这里使用一个实例来说明。","text":"今天发现使用C++的sort比C的qsort还要方便一些，为了说明sort的使用方法，这里使用一个实例来说明。 题目描述有N个学生的数据，将学生数据按成绩高低排序，如果成绩相同则按姓名字符的字母序排序，如果姓名的字母序也相同则按照学生的年龄排序，并输出N个学生排序后的信息。 输入测试数据有多组，每组输入第一行有一个整数N（N&lt;=1000），接下来的N行包括N个学生的数据。每个学生的数据包括姓名（长度不超过100的字符串）、年龄（整形数）、成绩（小于等于100的正数）。 输出将学生信息按成绩进行排序，成绩相同的则按姓名的字母序进行排序。然后输出学生信息，按照如下格式：姓名 年龄 成绩 样例输入 3abc 20 99bcd 19 97bed 20 97 样例输出 bcd 19 97bed 20 97abc 20 99 提示：学生姓名的字母序区分字母的大小写，如A要比a的字母序靠前(因为A的ASC码比a的ASC码要小)。 来源：2000年清华大学计算机研究生机试真题 Code12345678910111213141516171819202122232425262728293031323334353637#define _CRT_SECURE_NO_WARNINGS#include &lt;stdio.h&gt;#include &lt;algorithm&gt;#include &lt;string.h&gt;using namespace std;struct Student &#123; char name[101]; int age; int score;&#125; buf[1000];int cmp(Student a, Student b) &#123; if (a.score != b.score) &#123; return a.score &gt; b.score; &#125; int tmp = strcmp(a.name, b.name); if (tmp != 0) &#123; return tmp &gt; 0; &#125; else &#123; return a.age &gt; b.age; &#125;&#125;int main() &#123; int size; while (scanf(\"%d\", &amp;size) != EOF) &#123; for (int i = 0; i &lt; size; i++) &#123; scanf(\"%s%d%d\", buf[i].name, &amp;buf[i].age, &amp;buf[i].score); &#125; sort(buf, buf + size, cmp); for (int i = 0; i &lt; size; i++) &#123; printf(\"%s %d %d\\n\", buf[i].name, buf[i].age, buf[i].score); &#125; &#125; return 0;&#125; #define _CRT_SECURE_NO_WARNINGS 是为了防止VS2015对于scanf的报错, 可以看到sort比qsort函数少了一个参数。而cmp函数是对于结构体的比较作出规定。cmp的编写基本最复杂的就是结构体的规则编写了，弄懂了基本其他的整型、字符、字符串等等的比较也会了。","categories":[{"name":"算法","slug":"算法","permalink":"http://blog.iamxcc.com/categories/算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://blog.iamxcc.com/tags/算法/"}]},{"title":"VS2015中使用scanf报错","slug":"VS2015中使用scanf报错","date":"2016-08-14T10:30:48.000Z","updated":"2016-08-14T10:45:44.553Z","comments":true,"path":"2016/08/14/VS2015中使用scanf报错/","link":"","permalink":"http://blog.iamxcc.com/2016/08/14/VS2015中使用scanf报错/","excerpt":"今天使用VS2015编译C文件时，发现scanf报错了，提示我们使用scanf_s替代scanf。如果我们坚持要使用scanf，那怎么办呢？","text":"今天使用VS2015编译C文件时，发现scanf报错了，提示我们使用scanf_s替代scanf。如果我们坚持要使用scanf，那怎么办呢？ 解决办法 方法一：在程序最前面加#define _CRT_SECURE_NO_DEPRECATE； 方法二：在程序最前面加#define _CRT_SECURE_NO_WARNINGS； 方法三：在程序最前面加#pragma warning(disable:4996)； 方法四：把scanf改为scanf_s； 方法五：无需在程序最前面加那行代码，只需在新建项目时取消勾选“SDL检查”即可； 方法六：若项目已建立好，在项目属性里关闭SDL也行；","categories":[{"name":"VS2015","slug":"VS2015","permalink":"http://blog.iamxcc.com/categories/VS2015/"}],"tags":[{"name":"VS2015","slug":"VS2015","permalink":"http://blog.iamxcc.com/tags/VS2015/"},{"name":"IDE","slug":"IDE","permalink":"http://blog.iamxcc.com/tags/IDE/"}]},{"title":"jquery插件实现萤火虫效果","slug":"jquery插件实现萤火虫效果","date":"2016-08-13T05:52:51.000Z","updated":"2016-08-13T06:25:26.905Z","comments":true,"path":"2016/08/13/jquery插件实现萤火虫效果/","link":"","permalink":"http://blog.iamxcc.com/2016/08/13/jquery插件实现萤火虫效果/","excerpt":"如果博客页面是黑色的，可以添加一些萤火虫效果在上面，从而显得不那么单调。","text":"如果博客页面是黑色的，可以添加一些萤火虫效果在上面，从而显得不那么单调。 源码在jQuery-firefly上，支持一下。 使用方法直接在页面上添加上这两行代码即可，不过记得要在jquery之下：12&lt;script src=\"firefly.js\"&gt;&lt;/script&gt;&lt;script&gt;$(document).firefly();&lt;/script&gt;","categories":[{"name":"jQuery","slug":"jQuery","permalink":"http://blog.iamxcc.com/categories/jQuery/"}],"tags":[{"name":"jQuery","slug":"jQuery","permalink":"http://blog.iamxcc.com/tags/jQuery/"}]},{"title":"git推送文件到github步骤","slug":"git推送文件到github步骤","date":"2016-08-13T03:41:50.000Z","updated":"2016-08-13T06:33:11.945Z","comments":true,"path":"2016/08/13/git推送文件到github步骤/","link":"","permalink":"http://blog.iamxcc.com/2016/08/13/git推送文件到github步骤/","excerpt":"每次想用git推送文件到github时，总是忘记那几个命令，如果出错还不知道是怎么回事。所以在这里做个记录，方便下次翻阅。","text":"每次想用git推送文件到github时，总是忘记那几个命令，如果出错还不知道是怎么回事。所以在这里做个记录，方便下次翻阅。 推送到新的仓库123456echo \"# hexo-source\" &gt;&gt; README.mdgit initgit add README.mdgit commit -m \"first commit\"git remote add origin git@github.com:iamxcc/hexo-source.gitgit push -u origin master 推送到已有仓库1234git add .git commit -m \"first commit\"git remote add origin git@github.com:iamxcc/hexo-source.gitgit push -u origin master 如果已经推送过了，那么可以省略git remote add origin git@github.com:iamxcc/hexo-source.git这句。","categories":[{"name":"Git","slug":"Git","permalink":"http://blog.iamxcc.com/categories/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://blog.iamxcc.com/tags/Git/"}]},{"title":"PAT(Basic Level) 1001: 害死人不偿命的(3n+1)猜想","slug":"PAT-Basic-Level-1001-害死人不偿命的-3n-1-猜想","date":"2016-08-10T12:05:49.000Z","updated":"2016-08-10T15:39:58.142Z","comments":true,"path":"2016/08/10/PAT-Basic-Level-1001-害死人不偿命的-3n-1-猜想/","link":"","permalink":"http://blog.iamxcc.com/2016/08/10/PAT-Basic-Level-1001-害死人不偿命的-3n-1-猜想/","excerpt":"卡拉兹(Callatz)猜想：对任何一个自然数n，如果它是偶数，那么把它砍掉一半；如果它是奇数，那么把(3n+1)砍掉一半。","text":"卡拉兹(Callatz)猜想：对任何一个自然数n，如果它是偶数，那么把它砍掉一半；如果它是奇数，那么把(3n+1)砍掉一半。 这样一直反复砍下去，最后一定在某一步得到n=1。卡拉兹在1950年的世界数学家大会上公布了这个猜想，传说当时耶鲁大学师生齐动员，拼命想证明这个貌似很傻很天真的命题，结果闹得学生们无心学业，一心只证(3n+1)，以至于有人说这是一个阴谋，卡拉兹是在蓄意延缓美国数学界教学与科研的进展…… 我们今天的题目不是证明卡拉兹猜想，而是对给定的任一不超过1000的正整数n，简单地数一下，需要多少步（砍几下）才能得到n=1？ 输入格式：每个测试输入包含1个测试用例，即给出自然数n的值。 输出格式：输出从n计算到1需要的步数。 输入样例：3输出样例：5 code1234567891011121314151617181920212223#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;limits.h&gt;#include &lt;math.h&gt;int main() &#123; int num = 0; int count = 0; scanf(\"%d\", &amp;num); if (num == 0) &#123; return 0; &#125; while (num != 1) &#123; if (num % 2 == 0) &#123; num /= 2; count++; &#125; else &#123; num = (num * 3 + 1) / 2; count++; &#125; &#125; printf(\"%d/n\", count); return 0;&#125;","categories":[{"name":"PAT","slug":"PAT","permalink":"http://blog.iamxcc.com/categories/PAT/"}],"tags":[{"name":"PAT","slug":"PAT","permalink":"http://blog.iamxcc.com/tags/PAT/"}]},{"title":"L1-002: 打印沙漏","slug":"L1-002-打印沙漏","date":"2016-08-10T11:00:27.000Z","updated":"2016-08-10T14:19:24.680Z","comments":true,"path":"2016/08/10/L1-002-打印沙漏/","link":"","permalink":"http://blog.iamxcc.com/2016/08/10/L1-002-打印沙漏/","excerpt":"本题要求你写个程序把给定的符号打印成沙漏的形状。例如给定17个“*”，要求按下列格式打印","text":"本题要求你写个程序把给定的符号打印成沙漏的形状。例如给定17个“*”，要求按下列格式打印 12345***** *** * ******** 所谓“沙漏形状”，是指每行输出奇数个符号；各行符号中心对齐；相邻两行符号数差2；符号数先从大到小顺序递减到1，再从小到大顺序递增；首尾符号数相等。 给定任意N个符号，不一定能正好组成一个沙漏。要求打印出的沙漏能用掉尽可能多的符号。 输入格式： 输入在一行给出1个正整数N（&lt;=1000）和一个符号，中间以空格分隔。 输出格式： 首先打印出由给定符号组成的最大的沙漏形状，最后在一行中输出剩下没用掉的符号数。123456789输入样例：19 *输出样例：***** *** * ********2 代码1234567891011121314151617181920212223242526272829303132#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;limits.h&gt;#include &lt;math.h&gt;int main() &#123; int num = 0; char symbol; int max = 0; int times = 0; scanf(\"%d %c\", &amp;num, &amp;symbol); max = sqrt(2*(num + 1)) - 1; max = (max % 2) == 0 ? max - 1 : max; for (int i = 0; i &lt; max; i++) &#123; for (int j = 0; j &lt; max; j++) &#123; int temp = i &gt; max / 2 ? (max - i - 1) : i; if (temp &lt;= j &amp;&amp; j &lt;= max - 1 - temp) &#123; printf(\"%c\", symbol); &#125; else if (j &gt; max - 1 - temp) &#123; break; &#125; else &#123; printf(\" \"); &#125; &#125; printf(\"\\n\"); &#125; int left = pow((max + 1), 2) / 2 - 1; left = left &gt; 0 ? left : 0; printf(\"%d\\n\", num - left); return 0;&#125;","categories":[{"name":"PAT","slug":"PAT","permalink":"http://blog.iamxcc.com/categories/PAT/"}],"tags":[{"name":"PAT","slug":"PAT","permalink":"http://blog.iamxcc.com/tags/PAT/"}]},{"title":"Chrome52中Mactype无效怎么回退版本","slug":"Chrome52中Mactype无效怎么回退版本","date":"2016-08-10T02:18:59.000Z","updated":"2016-08-10T02:28:44.914Z","comments":true,"path":"2016/08/10/Chrome52中Mactype无效怎么回退版本/","link":"","permalink":"http://blog.iamxcc.com/2016/08/10/Chrome52中Mactype无效怎么回退版本/","excerpt":"今天在chrome自动更新到523版本后，突然被chrome上显示的字体吓了一下，还以为什么坏了。后来才发现是mactype无效了，因为Chrome52后禁用DirectWrite渲染的选项已经没有了。","text":"今天在chrome自动更新到523版本后，突然被chrome上显示的字体吓了一下，还以为什么坏了。后来才发现是mactype无效了，因为Chrome52后禁用DirectWrite渲染的选项已经没有了。 没有办法只能去找各种各样的解决办法，先是试了stylish的方式，效果不明显。后来又去找mactype有没有新的版本。一直折腾了好久后，终于下定决心把chrome回退到上一个版本。 可是怎么回退呢？卸载掉再重新装吗？答案是不用这么麻烦。下面是解决办法，来自知乎 Dorawei：C:\\Program Files (x86)\\Google\\Chrome\\Temp\\ 下的一个文件夹中有old_chrome.exe，把它复制到C:\\Program Files (x86)\\Google\\Chrome\\Application 中改为 chrome.exe 就可以返回上一版了。","categories":[{"name":"Mactype","slug":"Mactype","permalink":"http://blog.iamxcc.com/categories/Mactype/"}],"tags":[{"name":"Mactype","slug":"Mactype","permalink":"http://blog.iamxcc.com/tags/Mactype/"},{"name":"Chrome","slug":"Chrome","permalink":"http://blog.iamxcc.com/tags/Chrome/"},{"name":"Win10","slug":"Win10","permalink":"http://blog.iamxcc.com/tags/Win10/"}]},{"title":"趣说KMP算法","slug":"趣说KMP算法","date":"2016-08-06T11:59:24.000Z","updated":"2016-08-06T12:04:51.241Z","comments":true,"path":"2016/08/06/趣说KMP算法/","link":"","permalink":"http://blog.iamxcc.com/2016/08/06/趣说KMP算法/","excerpt":"今天逛知乎时，发现了一个比较浅显易懂的KMP算法解释。故在此做个笔记","text":"今天逛知乎时，发现了一个比较浅显易懂的KMP算法解释。故在此做个笔记 。作者信息如下：作者：逍遥行链接：https://www.zhihu.com/question/21923021/answer/37475572来源：知乎著作权归作者所有，转载请联系作者获得授权。 甲：abbaabbaaba在里面寻找乙：abbaaba发现第 7 个字符不匹配。这时候甲把乙叫走了，说你先一边玩去，我自己研究下。然后甲想，自己已经知道乙的前 6 个字符就是自己的前 6 个字符，不妨先「自己与自己匹配一番」。然后甲先用 abbaab 这 6 个已知的字符去匹配自身，错 1 个位，发现第一个就不一样（不匹配），然后错 2 个位，还是不匹配。当错 3 个位的时候，甲发现匹配了一个 a，但是第二个 b 不匹配。当错 4 个位的时候，匹配了两个。错 5 个位不匹配。后面的东西甲就不知道了，因为他只知道前 6 个字符。（注：实际的匹配个数是字符串 [0…i] 的后缀与前缀的最长公共长度） 随后，甲把乙叫了过来：「我已经知道你下一次匹配开始的位置了，来，让你的头部对齐我的第 5 个字符，然后从你的第 3 个字符开始继续匹配我吧！」 关键的地方，在于不要让乙「前功尽弃」——已经匹配了 6 个了，还差一个就结束了，这时不匹配导致从 0 开始，多可惜啊！现在我告诉你，在不匹配的情况下，你仍然已经匹配了 2 个（乙内心：还好不是 0），并且你可以继续从不匹配的地方开始比较，即用你的 3 个字符与我继续匹配。那，这个 2 你是怎么算的？我在你来之前就算好啦！我先与自己进行匹配（预处理），对每个位置，找「当前位置往前看的最长字符串，它与我的前缀匹配」（当然这个字符串不能是前缀），这个最长字符串的长度，在学术上称作「失配函数」。UCCU，从你的第 6 个位置往前看，恰好 [ab] 与你的前缀 [ab] 匹配，但是我的第 7 个字符并不知道你的第 3 个字符是否与我一样，所以你直接从这里开始继续匹配我。 以上为 KMP 的基本思想，关键在于失配函数的计算，网上的代码很多，这里有个很好的例子你仔细体会下：ababzababa，注意最后一个失配函数的值为 3。","categories":[{"name":"算法","slug":"算法","permalink":"http://blog.iamxcc.com/categories/算法/"}],"tags":[{"name":"KMP算法","slug":"KMP算法","permalink":"http://blog.iamxcc.com/tags/KMP算法/"}]},{"title":"OSI模型与TCP/IP模型","slug":"OSI模型与TCP-IP模型","date":"2016-08-06T09:20:25.000Z","updated":"2016-08-06T09:28:19.600Z","comments":true,"path":"2016/08/06/OSI模型与TCP-IP模型/","link":"","permalink":"http://blog.iamxcc.com/2016/08/06/OSI模型与TCP-IP模型/","excerpt":"今天重新温习了一篇OSI模型与TCP/IP模型的知识，发现很多知识点又忘记了。所以，在此记录一下，方便下次查阅。","text":"今天重新温习了一篇OSI模型与TCP/IP模型的知识，发现很多知识点又忘记了。所以，在此记录一下，方便下次查阅。 OSI模型从低到高：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层。 物理层并不是指物理设备或者物理媒体。而是有关物理设备通过物理媒体进行互联的描述和规定。该层定义了接口的机械特性、电气特性、功能特性、规程特性等4个基本特性。物理层以比特流的方式传送来自数据链路层的数据，而不去理会数据的含义和格式。同样，接收数据后直接传给数据链路层。 数据链路层负责通过物理层从一台计算机到另外一台计算机无差错的传输数据帧，允许网络层通过网络连接进行虚拟无差错的传输。通常，数据链路层发送数据帧之后，等待接收方进行确认。接收方数据链路层检测帧传输过程中产生的任何问题。没有经过确认和损坏的帧都需要重传。 网络层负责信息寻址和将逻辑地址转换为物理地址。在网络层，数据传递单位是包。网络层的任务是选择合适的路径转发数据包。使发送方的数据包能够正确无误的按地址寻找到接收方的路径。并将数据包交给接收方。网络中两点之间可以到达的路径可能有很多，在选择最快捷、花费最低的路径时必须考虑网络拥塞程度、服务质量、线路的花费和线路的有效性。总的来说，网络层负责选择最佳路径。 网络层还能够协调发送、传输及接收设备的能力不平衡问题。如网络层对数据进行分段和重组，使得数据的长度能够满足该网络下层数据链路锁支持的最大数据帧MTU的长度。还需要考虑网络层不同网络协议之间的相互连接问题。 传输层传输层的功能是保证在不同子网的两台设备间数据包可靠、顺序、无错的传输。在传输层，数据传输单位是段。传输层负责处理端对端通信，即一个终端到另一个终端的通信，中间可以有多个交换节点。传输层向高层用户提供端到端的可靠的透明传输服务，为不同进程间的数据交换提供可靠的传输手段。在传输层的一个很重要的工作是数据的分段和重组，即把一个上层数据切割成更小的逻辑片和物理片。发送方在传输层把上层交给它的较大的数据进行分段后分别交给网络层进行独立输出，从而在传输层实现流量控制，提高网络资源的利用率。接收方收到数据后重组。传输层可以将收到的乱序数据包重新排序，并验证是否收到所有分组。 会话层会话层是利用传输层提供的端到端的服务，向表示层或会话用户提供会话服务。会话层主要功能是在两个节点之间建立、维护、释放面向用户的连接，并对会话进行管理和控制，保证会话数据可靠传送。会话层的连接与传输层的连接有1对1、1对多、多对1的关系。会话工程中，会话层需要决定到底使用全双工通信还是半双工通信。如果采用全双工，会话层的对话管理工作就很少。如果采用半双工，会话层则通过一个数据令牌来协调会话。保证每次只有一个用户能够传输数据。会话层提供同步服务，通过在数据流中定义检查点来把会话分割成明显的会话单元。当网络出故障时，从最后一个检查点开始重传数据。SQL、RPC(远程进程呼叫)都属于该层协议。 表示层表示层专门负责有关网络中计算机信息表示方式的问题。表示层在不同的数据格式之间进行数据转换，实现不同计算机之间的信息交换。除了编码，还包括数组、浮点数、记录、图像、声音等。表示层还负责数据的加密。文件的压缩，降低传输费用。 应用层直接与用户和应用程序打交道。负责对软件提供接口以使程序可以使用网络。Telnet(虚拟终端协议)、SMTP(简单邮件传输协议)、SNMP(简单网络管理协议)、DNS(域名系统)和超文本传输协议(HTTP)。 TCP/IP模型从低到高：网络接口层、网络层、传输层、应用层。 各层主要功能大致与OSI相对应。 应用层协议：HTTP、FTP、SMTP、DNS。 传输层协议：TCP、UDP。 网络层协议：IP、ARP、ICMP(因特网控制消息协议)、RARP(反向地址解释协议)。 网络接口层：Ethrenet、令牌环、帧中继、ISDN和分组交换网X.25。","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://blog.iamxcc.com/categories/计算机网络/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://blog.iamxcc.com/tags/计算机网络/"}]},{"title":"C语言实现strlen函数的方法","slug":"C语言实现strlen函数的方法","date":"2016-08-05T13:42:17.000Z","updated":"2016-08-05T13:51:29.610Z","comments":true,"path":"2016/08/05/C语言实现strlen函数的方法/","link":"","permalink":"http://blog.iamxcc.com/2016/08/05/C语言实现strlen函数的方法/","excerpt":"不使用中间变量求const字符串长度，即实现求字符串长度库函数strlen函数。函数接口声明如下：int strlen(const char *p)；","text":"不使用中间变量求const字符串长度，即实现求字符串长度库函数strlen函数。函数接口声明如下：int strlen(const char *p)； 思路在字符串中通常可以利用最后一个结束符’\\0’，但此处参数为const，只读，那么我们不能打他的主意。函数运行过程中不占用内存基本不可能，除非都使用了寄存器。“不使用中间变量”只是说程序员不能显示的申请内存而已，即不能有局部变量或者动态内存申请。如果函数自动申请栈内存或者使用寄存器存储变量，或者使用立即数寻址即常量，那么就相当于“不使用中间变量”。从函数原型看，返回值为int，那么在函数内部必定需要一个地方存储这个值，要么是常数要么是寄存器。长度不为1时不能一次就求出来，说明必须有递归调用，这样递归时函数会自动申请栈内存，这样就相当于程序员“不使用中间变量”了。中间返回的值通过寄存器自动保存，最后一次返回时拷贝到int中去。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;assert.h&gt;int mStrlen(const char *str);int mStrlen1(const char *str);int mStrlen2(const char *str);int main()&#123; char *str=NULL; str = \"Hello Jay!\"; printf(\"original strlen():%d\\n\",strlen(str)); printf(\"myStrlen():%d\\n\",myStrlen(str)); printf(\"myStrlen1():%d\\n\",myStrlen1(str)); printf(\"myStrlen2():%d\\n\",myStrlen2(str));&#125;int mStrlen(const char *str) // 不用中间变量，用递归实现，很容易看懂&#123; if ( (str == NULL) || (*str == '\\0') ) &#123; return 0; &#125; else &#123; return myStrlen(str+1)+1; &#125;&#125;int mStrlen1(const char *str) // 不用中间变量，也是用递归实现，写得更简洁而已&#123; assert(str != NULL); return *str ? (myStrlen1(++str) + 1) : 0;&#125;int mStrlen2(const char *str) // 使用了一个int型变量&#123; if(str==NULL) return 0; int len = 0; for(; *str++ != '\\0'; ) &#123; len++; &#125; return len;&#125;","categories":[{"name":"C语言","slug":"C语言","permalink":"http://blog.iamxcc.com/categories/C语言/"}],"tags":[{"name":"C语言","slug":"C语言","permalink":"http://blog.iamxcc.com/tags/C语言/"}]},{"title":"NULL,'\\0',0,'/0'和\"0\"的区别","slug":"NULL,0,'0'","date":"2016-08-05T13:03:42.000Z","updated":"2016-08-05T13:29:20.946Z","comments":true,"path":"2016/08/05/NULL,0,'0'/","link":"","permalink":"http://blog.iamxcc.com/2016/08/05/NULL,0,'0'/","excerpt":"最近发现对于NULL,’\\0’,0,’/0’和”0”的区别有点混淆了。所以在查阅资料之后，将笔记记录在此处，免得下次忘记了可以看看。","text":"最近发现对于NULL,’\\0’,0,’/0’和”0”的区别有点混淆了。所以在查阅资料之后，将笔记记录在此处，免得下次忘记了可以看看。 NULLNULL 即空指针，在C和C++中的形式不一样，msdn上有如下的内容那个：1234567#if !defined(NULL)&amp;&amp;defined(__NEEDS_NULL) #ifdef __cplusplus #define NULL 0 #else #define NULL ((void *)0) #endif#endif NULL 在c中用（void*）0表示，在c++中用0表示。 ‘\\0’和’0’ ‘\\0’表示字符串结束，它在ASCII中的值为0（数值0，非字符‘0’。所以在数值上NULL, ‘\\0’,0是一样的，都是0，但’0’就不同了，在ASCII码中编码为48，所以字符0和上述三个值不同。 在内存中NULL 和&#39;\\0&#39; 和&#39;0&#39;都是一个8位的char类型，NULL 和’\\0’ 值一样，都是0，以数字方式读取就是0，以字符串读取时就是’\\0’或者null（和编译器有关）。 而&#39;0&#39;在内存存储着48，以字符读取就是&#39;0&#39;,以数字读取就是48，至于0，可能是char ,int ,float,double等类型，但是值和NULL和&#39;\\0&#39;一样，都是0。 ‘/0’和’\\0’我在写C代码时，经常把’\\0’写成’/0’。其实这两者之间差别很大的。因为’/0’表示的是两个字符了，一个是’/‘, 另一个’0’。而’\\0’表示的字符串结束，值为0。 “0”“0”表示的是字符串，即在存储中存储了两个内容，一个是’0’(即字符0)，另一个是字符串结束符’\\0’(也即数字0)。 举例为了说明情况，下面列举了几个例子。1234567891011printf(\"%d\",'0'); ==&gt;48printf(\"%c\",'0'); ==&gt;0printf(\"%c\",0); ==&gt;空（即NULL）printf(\"%d\",0); ==&gt;0那么0+'0',0+'\\0'分别是什么呢？printf(\"%c\",0+'\\0'); ==&gt;空（NULL）//先转换成int,然后ASCII编码相加为0，%c输出，转换成char,所以输出NULLprintf(\"%d\",0+'\\0'); ==&gt;0 //先转换成int，然后ASCII编码相加为0, %d输出，不用转换，输出数字0printf(\"%c\",0+'0'); ==&gt;0printf(\"%d\",0+'0'); ==&gt;48","categories":[{"name":"C语言","slug":"C语言","permalink":"http://blog.iamxcc.com/categories/C语言/"}],"tags":[{"name":"C语言","slug":"C语言","permalink":"http://blog.iamxcc.com/tags/C语言/"}]},{"title":"51NOD 1005: 排序","slug":"51NOD-1005-排序","date":"2016-07-31T16:31:39.000Z","updated":"2016-07-31T16:36:51.004Z","comments":true,"path":"2016/08/01/51NOD-1005-排序/","link":"","permalink":"http://blog.iamxcc.com/2016/08/01/51NOD-1005-排序/","excerpt":"题目描述：给出N个整数，对着N个整数进行排序。","text":"题目描述：给出N个整数，对着N个整数进行排序。 input第1行：整数的数量N（1 &lt;= N &lt;= 50000)第2 - N + 1行：待排序的整数（-10^9 &lt;= A[i] &lt;= 10^9） output共n行，按照递增序输出排序好的数据。 input示例554321 output示例1234512345678910111213141516171819202122#include &lt;stdio.h&gt;int cmp(const int* a, const int* b)&#123; return *a - *b;&#125;int main()&#123; int numsSize, nums[50000]; scanf(\"%d\", &amp;numsSize); for(int i=0; i&lt;numsSize; i++) &#123; scanf(\"%d\", &amp;nums[i]); &#125; qsort(nums, numsSize, sizeof(int), cmp); for(int i=0; i&lt;numsSize; i++) &#123; printf(\"%d\\n\", nums[i]); &#125; return 0;&#125;","categories":[{"name":"51NOD","slug":"51NOD","permalink":"http://blog.iamxcc.com/categories/51NOD/"}],"tags":[{"name":"51NOD","slug":"51NOD","permalink":"http://blog.iamxcc.com/tags/51NOD/"}]},{"title":"贪心算法入门","slug":"贪心算法入门","date":"2016-07-31T16:10:35.000Z","updated":"2016-08-06T12:12:39.889Z","comments":true,"path":"2016/08/01/贪心算法入门/","link":"","permalink":"http://blog.iamxcc.com/2016/08/01/贪心算法入门/","excerpt":"约翰认为字符串的完美度等于它里面所有字母的完美度之和。每个字母的完美度可以由你来分配，不同字母的完美度不同，分别对应一个1-26之间的整数。","text":"约翰认为字符串的完美度等于它里面所有字母的完美度之和。每个字母的完美度可以由你来分配，不同字母的完美度不同，分别对应一个1-26之间的整数。 约翰不在乎字母大小写。（也就是说字母F和f）的完美度相同。给定一个字符串，输出它的最大可能的完美度。例如：dad，你可以将26分配给d，25分配给a，这样整个字符串完美度为77。 分析： 由排序不等式，出现次数最多的字母显然应该给26。所以这个题目变成了统计每种字母出现的次数了，然后按照出现次数从大到小，依次分配从高到低的权值。这就是最朴素的贪心思想。123456789101112131415161718192021222324252627#include&lt;stdio.h&gt;#include&lt;string.h&gt;int cmp(const char* a, const char* b)&#123; return *a - *b;&#125;int main()&#123; char str[100]; scanf(\"%s\", str); int strSize; strSize = strlen(str); qsort(str, strSize, sizeof(char), cmp); int res = 26; int maxValue = 26; for (int i = strSize - 1; i &gt;= 1; i--) &#123; if (str[i] != str[i - 1]) &#123; maxValue--; &#125; res += maxValue; &#125; printf(\"%d\", res);&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://blog.iamxcc.com/categories/算法/"}],"tags":[{"name":"贪心算法","slug":"贪心算法","permalink":"http://blog.iamxcc.com/tags/贪心算法/"}]},{"title":"异或^的妙用","slug":"异或-的妙用","date":"2016-07-31T08:33:10.000Z","updated":"2016-07-31T10:15:51.434Z","comments":true,"path":"2016/07/31/异或-的妙用/","link":"","permalink":"http://blog.iamxcc.com/2016/07/31/异或-的妙用/","excerpt":"最近在做一些算法题的时候，发现了异或很好使，经常有一些很妙的点子是通过它来实现的。所以特别在这里记录一下","text":"最近在做一些算法题的时候，发现了异或很好使，经常有一些很妙的点子是通过它来实现的。所以特别在这里记录一下，方便下次使用与学习。 两数交换如果不用这三个参数就实现两数的交换的话，可以使用异或^来实现,代码如下：123456void swap(int &amp;a,int &amp;b) //通过异或交换两者的值&#123; a =a^b; b= a^b; a = b^a;&#125; 找出0, 1, 2, …, n序列中缺了哪个数这是LeetCode 268 Missing Number的题，代码如下:1234567int missingNumber(int* nums, int numsSize) &#123; int res = numsSize; for(int i = 0; i &lt; numsSize; i++)&#123; res ^= i ^ nums[i]; &#125; return res;&#125; 暂时只有这两个妙处，下次还有的话，再添加。","categories":[{"name":"算法","slug":"算法","permalink":"http://blog.iamxcc.com/categories/算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://blog.iamxcc.com/tags/算法/"}]},{"title":"hexo主题中使用mathjax来支持LaTex公式","slug":"hexo主题中使用mathjax来支持latex公式","date":"2016-07-31T05:19:44.000Z","updated":"2016-07-31T06:42:08.750Z","comments":true,"path":"2016/07/31/hexo主题中使用mathjax来支持latex公式/","link":"","permalink":"http://blog.iamxcc.com/2016/07/31/hexo主题中使用mathjax来支持latex公式/","excerpt":"今天发现在要写很多公式时，页面显示会有点乱。或者要表达一些复杂的符号时，发现不知道怎么写出来。","text":"今天发现在要写很多公式时，页面显示会有点乱。或者要表达一些复杂的符号时，发现不知道怎么写出来。后来上网查了一下发现有mathjax这个东西，实在好用。 使用步骤因为mathjax这个js文件每次加载都有点慢，而且很多时候并用不到这个插件，所以我们的策略是按是否需要使用为前提而加载。而且如果哪天我们都不需要mathjax了，我们还要加上全局的控制的功能。所以为了实现上面的功能，我们需要修改几个文件。 主题的_config.yml文件在主题文件夹下的_config.yml中加入下面的代码，为了实现全局的控制，这里加上enable: true, false的话就会全站禁止了12345678# ---------------------------------------------------------------# Third Party Services Settings # ---------------------------------------------------------------# MathJax Supportmathjax: enable: true cdn: http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML 上面的cdn觉得慢的话，可以自己找一个。 按文章加载在文章需要调用 Mathjax 时, 只需在 front-matter 前加上 mathjax: true 即可, 即12345678---title: hexo主题中使用mathjax来支持LaTex公式date: 2016-07-31 13:19:44tags: [LaTex, hexo]categories: hexothumbnail: http://7xveyh.com1.z0.glb.clouddn.com/latex_latin_symbols.jpgmathjax: true--- 加载mathjax文件有了上面的修改，这时候就可以按需要加载mathjax脚本文件了。我主题加载js文件都是在script.ejs中判断后加载的(你们可以根据自己的情况来处理)，所以这里加上下面这段代码：123&lt;% if (page.mathjax)&#123; %&gt; &lt;%- partial(&apos;plugin/mathjax&apos;) %&gt;&lt;% &#125; %&gt; 上面代码说明如果mardkown文件中写了上面说的mathjax: ture，那么if条件为ture，则加载plugin/mathjax mathjax.ejs文件123456789101112131415161718192021&lt;% if (theme.mathjax.enable)&#123; %&gt; &lt;script type=\"text/x-mathjax-config\"&gt; MathJax.Hub.Config(&#123; tex2jax: &#123; inlineMath: [ ['$','$'], [\"\\\\(\",\"\\\\)\"] ], processEscapes: true, skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'] &#125; &#125;); &lt;/script&gt; &lt;script type=\"text/x-mathjax-config\"&gt; MathJax.Hub.Queue(function() &#123; var all = MathJax.Hub.getAllJax(), i; for (i=0; i &lt; all.length; i += 1) &#123; all[i].SourceElement().parentNode.className += ' has-jax'; &#125; &#125;); &lt;/script&gt; &lt;script type=\"text/javascript\" src=\"&lt;%= theme.mathjax.cdn %&gt;\"&gt;&lt;/script&gt;&lt;% &#125; %&gt; 可以看到代码中的theme.mathjax.cdn就是主题配置文件中的mathjax下的cdn啦。 说明我的主题使用的是ejs模板语言写的，如果是swig或者其他语言，还要稍微修改一下，具体怎么改可以上网搜索一下。下面放张效果图：","categories":[{"name":"hexo","slug":"hexo","permalink":"http://blog.iamxcc.com/categories/hexo/"}],"tags":[{"name":"LaTex","slug":"LaTex","permalink":"http://blog.iamxcc.com/tags/LaTex/"},{"name":"hexo","slug":"hexo","permalink":"http://blog.iamxcc.com/tags/hexo/"}]},{"title":"归并排序","slug":"归并排序","date":"2016-07-31T03:06:33.000Z","updated":"2016-08-12T10:18:40.871Z","comments":true,"path":"2016/07/31/归并排序/","link":"","permalink":"http://blog.iamxcc.com/2016/07/31/归并排序/","excerpt":"归并排序以O(NlogN)最坏情形运行时间运行，而所使用的比较次数几乎是最优的。它是递归算法一个很好的实例。","text":"归并排序以O(NlogN)最坏情形运行时间运行，而所使用的比较次数几乎是最优的。它是递归算法一个很好的实例。这个算法中基本的操作是合并两个已排序的表。因为这两个表是已排序的，所以若将输出放到第三个表中时则该算法可以通过对输入数据一趟排序来完成。 归并排序代码归并排序分为三个函数，分别是：mSort函数、merge函数、mergeSort函数。其中merge函数是将不断输入的数据排序并归并。mSort函数是利用递归的想法分而治之，分治是递归非常有力的用法。mergeSort函数是起到调用前面两个函数与分配临时空间的作用。 mSort函数123456789101112void mSort( int nums[], int tmpNums[], int left, int right )&#123; int center; if ( left &lt; right ) &#123; center = (left + right) / 2; mSort(nums, tmpNums, left, center); mSort(nums, tmpNums, center + 1 , right); merge(nums, tmpNums, left, center + 1, right); &#125;&#125; merge函数12345678910111213141516171819202122232425262728293031323334void merge(int nums[], int tmpNums[], int lPos, int rPos, int rightEnd)&#123; int i, leftEnd, numsElement, tmpPos; leftEnd = rPos - 1; tmpPos = lPos; numsElement = rightEnd - lPos + 1; while (lPos &lt;= leftEnd &amp;&amp; rPos &lt;= rightEnd) &#123; if (nums[lPos] &lt;= nums[rPos]) &#123; tmpNums[tmpPos++] = nums[lPos++]; &#125; else &#123; tmpNums[tmpPos++] = nums[rPos++]; &#125; &#125; while (lPos &lt;= leftEnd) &#123; tmpNums[tmpPos++] = nums[lPos++]; &#125; while (rPos &lt;= rightEnd) &#123; tmpNums[tmpPos++] = nums[rPos++]; &#125; for (i = 0; i &lt; numsElement; i++, rightEnd--) &#123; nums[rightEnd] = tmpNums[rightEnd]; &#125;&#125; mergeSort函数1234567891011121314void mergeSort(int nums[], int N)&#123; int *tmpNums; tmpNums = malloc(N * sizeof(int)); if (tmpNums != NULL) &#123; mSort(nums, tmpNums, 0, N - 1); free(tmpNums); &#125; else &#123; printf(\"No space for tmp array\"); &#125;&#125; main函数123456789101112#include&lt;stdio.h&gt;int main(int argc, char *argv[])&#123; int nums[10] = &#123; 5, 3, 4, 1, 6, 10, 12, 2, 23, 9 &#125;; mergeSort(nums, 10); int i; for (i = 0; i&lt;10; i++) &#123; printf(\"%d\\n\", nums[i]); &#125;&#125; 归并排序的分析假设N是2的幂，从而我们总可以将它分裂成均为偶数的两部分。对于N-1，归并排序时间是常数，我们将记为1.否则，对N个数归并并排序的用时等于完成两个大小为N/2的递归排序所用的时间再加上合并的时间， 它是线性的。下面方程给出准确的表示：$$ T(1) = 1 $$$$ T(N) = 2T(\\frac N2) + N $$将上式两边同时除以N有：$$ \\frac{T(N)}{N} = {T(\\frac N2)\\over(\\frac N2)} + 1 $$该方程对2的幂的任意的N是成立的，我们还可以写成：$$ {T(\\frac N2)\\over(\\frac N2)} = {T(\\frac N4)\\over(\\frac N4)} +1 $$$$ ...$$$$ {T(2)\\over2} = {T(1)\\over1} + 1 $$将上式相加，并约掉可以得到：$$ {T(N)\\over N} = {T(1)\\over1} + logN $$两边同时乘以N得到：$$ T(N) = N + NlogN = O(NlogN) $$","categories":[{"name":"排序","slug":"排序","permalink":"http://blog.iamxcc.com/categories/排序/"}],"tags":[{"name":"排序算法","slug":"排序算法","permalink":"http://blog.iamxcc.com/tags/排序算法/"}]},{"title":"C函数qsort的用法","slug":"C函数qsort用法","date":"2016-07-30T07:37:31.000Z","updated":"2016-08-14T11:13:54.903Z","comments":true,"path":"2016/07/30/C函数qsort用法/","link":"","permalink":"http://blog.iamxcc.com/2016/07/30/C函数qsort用法/","excerpt":"qsort()函数是ANSI C标准中提供的，其声明在stdlib.h文件中，是根据二分法写的，其时间复杂度为n*log(n)。","text":"qsort()函数是ANSI C标准中提供的，其声明在stdlib.h文件中，是根据二分法写的，其时间复杂度为n*log(n)。为了了解 排序方式排序方式有很多种，比如：选择排序、冒泡排序、归并排序、快速排序等等。顾名思义快速排序是目前公认的一种比较好的排序算法，其比选择排序、冒泡排序都要快。因为它的速度很快，所以系统也在库里实现这个算法，便于我们使用，这个函数就是qsort了。 qsort简介qsort的函数原型是:1void qsort(void* base, size_t nelem, size_t width, cmp) 其中： *base为要排序的数组 nelem为要排序的数组的长度 width为每个数组元素的大小(以字节为单位) cmp为自己定义的比较函数，其作用在于方便使用者实现对数组、字符串、结构体等结构进行升序或降序排列。 cmp函数1int cmp(const void *a, const void *b) cmp函数中有两个元素作为参数，返回一个int值，如果比较函数返回大于0，qsort就认为a&gt;b；如果返回等于0，qsort就认为a=b；如果返回小于0，qsort就认为a小于b。因此，qsort函数知道元素大小，就可以把大的放到前面去。如果你把cmp函数的返回值1与-1的位置调换，那么就造成了升降序的差别了。 实例操作为了加深理解，下面以数组、字符串、结构体为例说明情况 对int数组进行排序12345int nums[100];int cmp ( const void *a , const void *b )&#123; return *(int *)a - *(int *)b; &#125;qsort(num,100,sizeof(num[0]),cmp); 对char类型数组排序12345char word[100];int cmp( const void *a , const void *b )&#123; return *(char *)a - *(int *)b;&#125;qsort(word,100,sizeof(word[0]),cmp); 对double类型数组排序12345double nums[100];int cmp( const void *a , const void *b )&#123; return *(double *)a - *(double *)b;&#125;qsort(nums,100,sizeof(nums[0]),cmp); 对结构体类型排序1234567891011struct Node&#123; double data; int other; &#125;s[100]//按照data的值从小到大将结构体排序,关于结构体内的排序关键数据data的类型可以很多种，//参考上面的例子写int cmp( const void *a ,const void *b)&#123; return (*(Node *)a).data - (*(Node *)b).data ? 1 : -1; &#125;qsort(s,100,sizeof(s[0]),cmp); 对结构体二级排序123456789101112131415struct Node&#123; int x; int y; &#125;s[100];//按照x从小到大排序，当x相等时按照y从大到小排序int cmp( const void *a , const void *b )&#123; struct Node *c = (Node *)a; struct Node *d = (Node *)b; if(c-&gt;x != d-&gt;x) return c-&gt;x - d-&gt;x; else return d-&gt;y - c-&gt;y;&#125;qsort(s,100,sizeof(s[0]),cmp); 对字符串进行排序12345678910struct Node &#123; int data; char str[100]; &#125;s[100];//按照结构体中字符串str的字典顺序排序int cmp ( const void *a , const void *b )&#123; return strcmp( (*(Node *)a)-&gt;str , (*(Node *)b)-&gt;str );&#125;qsort(s,100,sizeof(s[0]),cmp);","categories":[{"name":"C语言","slug":"C语言","permalink":"http://blog.iamxcc.com/categories/C语言/"}],"tags":[{"name":"C语言","slug":"C语言","permalink":"http://blog.iamxcc.com/tags/C语言/"}]},{"title":"win10取消开机密码","slug":"win10取消开机密码","date":"2016-07-30T07:16:48.000Z","updated":"2016-07-30T23:19:17.582Z","comments":true,"path":"2016/07/30/win10取消开机密码/","link":"","permalink":"http://blog.iamxcc.com/2016/07/30/win10取消开机密码/","excerpt":"每次自己或者帮家人取消win10开机密码时，都要上网查一下攻略，虽然很简单，但是为了下次不那么麻烦。","text":"每次自己或者帮家人取消win10开机密码时，都要上网查一下攻略，虽然很简单，但是为了下次不那么麻烦。这里就把这个教程记录下来。 步骤 首先，在电脑中点击桌面左下角的开始菜单图标，在出现的开始菜单界面中的搜索框中输入netplwiz，然后在搜索结果中点击最上面的netplwiz。或者cmd+R再输入netplwiz也一样。 然后在弹出的界面中定位到用户或者user选项卡菜单界面，取消勾选要使用本计算机，用户必须...，然后点击确定按钮，如图所示。 输入你的电脑的登录密码，并且重新确认一下，最后点击“确定”按钮保存退出。 这样下次开机的时候就不用输入密码，不过如果是睡眠重启的话还是需要密码的。","categories":[{"name":"Win10","slug":"Win10","permalink":"http://blog.iamxcc.com/categories/Win10/"}],"tags":[{"name":"Win10","slug":"Win10","permalink":"http://blog.iamxcc.com/tags/Win10/"}]},{"title":"Git上传时出现error","slug":"git上传时出现error","date":"2016-07-27T05:24:55.000Z","updated":"2016-07-30T07:30:39.698Z","comments":true,"path":"2016/07/27/git上传时出现error/","link":"","permalink":"http://blog.iamxcc.com/2016/07/27/git上传时出现error/","excerpt":"今天使用git上传文件到github上时出现错误，提示是error: src refspec master does not match any，后来上网查了一下，问题解决了。","text":"今天使用git上传文件到github上时出现错误，提示是error: src refspec master does not match any，后来上网查了一下，问题解决了。为了防止以后再遇到类似问题又给忘记了，所以还是把这个方法简单记录在此。 git工作大致流程 1、在github上创建项目 2、使用git clone https://github.com/xxxxxxx/xxxxx.git克隆到本地 3、编辑项目 4、git add . （将改动添加到暂存区） 5、git commit -m “提交说明” 6、git push origin master 将本地更改推送到远程master分支。 这样你就完成了向远程仓库的推送。 解决措施如果在github的remote上已经有了文件，会出现错误。此时应当先pull一下，即：1git pull origin master 然后再进行：1git push origin master 这样就不会出现错误提示了。","categories":[{"name":"Git","slug":"Git","permalink":"http://blog.iamxcc.com/categories/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://blog.iamxcc.com/tags/Git/"}]},{"title":"Git命令add和commit的区别","slug":"Git命令add和commit的区别","date":"2016-07-27T00:42:34.000Z","updated":"2016-07-27T05:25:47.684Z","comments":true,"path":"2016/07/27/Git命令add和commit的区别/","link":"","permalink":"http://blog.iamxcc.com/2016/07/27/Git命令add和commit的区别/","excerpt":"要想弄明白git add和git commit的区别，首先我们需要知道三个概念：工作区(Working Directory)、版本库(Repository)、暂存区(Stage or index)。","text":"要想弄明白git add和git commit的区别，首先我们需要知道三个概念：工作区(Working Directory)、版本库(Repository)、暂存区(Stage or index)。 工作区当你在开发一个项目时，主目录就是你的工作区。 版本库工作区中有一个隐藏目录.git，这个就是git的版本库了。 暂存区Git的版本库里存了很多文件，其中包括称为Stage或index的暂存区，还有一个git为我们自动创建的第一个分支master，以及指向master的一个指针HEAD。下面就是三个区的示意图：图片来着廖雪峰老师的 博客。 区别git add和git commit的区别就在于：git add把文件添加进去，实际上就是把文件修改添加到暂存区；git commit提交更改，实际上就是把暂存区的所有内容提交到当前分支。因为我们创建Git版本库时，Git自动为我们创建了唯一一个master分支。所以，git commit就是往master分支上提交更改。你可以简单理解为，需要提交的文件修改通通放到暂存区，然后，一次性提交暂存区的所有修改。 所以要想将修改提交到master中一定要先git add到暂存区中，再git commit到master分支。","categories":[{"name":"Git","slug":"Git","permalink":"http://blog.iamxcc.com/categories/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://blog.iamxcc.com/tags/Git/"}]},{"title":"Win下Sublime3美化","slug":"Sublime3美化","date":"2016-07-26T11:20:15.000Z","updated":"2016-07-30T23:19:58.881Z","comments":true,"path":"2016/07/26/Sublime3美化/","link":"","permalink":"http://blog.iamxcc.com/2016/07/26/Sublime3美化/","excerpt":"虽然sublime3没有atom的高颜值，但是稍微美化一下也是上得了台面的，再加上极快的启动速度，简直是我心中的神器。","text":"虽然sublime3没有atom的高颜值，但是稍微美化一下也是上得了台面的，再加上极快的启动速度，简直是我心中的神器。 主题美化使用过很多sublime3的主题，最后在laracasts视频中发现了一款十分漂亮的主题Material Theme。废话不多说，下面是教程：首先在sublime中Ctrl+Shift+p出现一个输入面板，再在面板上输入install package确认后再次出现一个面板，此时输入Material theme确认后等待安装即可。安装完成后在Preference-&gt;Setting-User中输入一下代码：12&quot;color_scheme&quot;: &quot;Packages/Material Theme/schemes/Material-Theme.tmTheme&quot;,&quot;theme&quot;: &quot;Material-Theme.sublime-theme&quot;, 最后再重启一下即可。当然这个主题还有一些其他的设置，想要更详细的设置请看官网 PackageControl 编程字体的选择曾经有段时间我不断在寻找最舒服的编程字体，包括什么Source Code Pro、DeJaVu Sans Mono、Droid Sans Mono、CamingoCode、Courier New等等，但是都不太满意。比如Source Code Pro中i的头尖尖的看着让我感到别扭。其他几种各有各的缺点。最后终于发现了Fira Code，这是Firefox设计的一款字体。废话不多说上图说明：","categories":[{"name":"Sublime","slug":"Sublime","permalink":"http://blog.iamxcc.com/categories/Sublime/"}],"tags":[{"name":"Win10","slug":"Win10","permalink":"http://blog.iamxcc.com/tags/Win10/"},{"name":"Sublime","slug":"Sublime","permalink":"http://blog.iamxcc.com/tags/Sublime/"}]},{"title":"Sublime3快捷键整理","slug":"Sublime3快捷键整理","date":"2016-07-26T10:59:51.000Z","updated":"2016-07-30T23:20:06.672Z","comments":true,"path":"2016/07/26/Sublime3快捷键整理/","link":"","permalink":"http://blog.iamxcc.com/2016/07/26/Sublime3快捷键整理/","excerpt":"Sublime Text 3是我最喜欢而且使用最多的一个编辑器，因为他启动速度快，界面可以美化的十分性感与优雅。","text":"Sublime Text 3是我最喜欢而且使用最多的一个编辑器，因为他启动速度快，界面可以美化的十分性感与优雅。虽然自由度没有atom这么高，但是atom相比于Sublime速度实在是有点慢。下面是我整理的一些常用快捷键： Ctrl + g 跳转到相应的行Ctrl + m 在括号起始位置和终止位置之间切换Ctrl + Shift + m 选中括号内内容Ctrl + Shift + k 删除光标所在行Ctrl + Shift + up 当前行向上移动Ctrl + Shift + down 当前行向下移动Ctrl + l 选择光标所在行ctrl + t 交换相邻的两个字母","categories":[{"name":"Sublime","slug":"Sublime","permalink":"http://blog.iamxcc.com/categories/Sublime/"}],"tags":[{"name":"Sublime","slug":"Sublime","permalink":"http://blog.iamxcc.com/tags/Sublime/"}]},{"title":"WinSnap:带阴影的截图才是好截图","slug":"WinSnap-带阴影的截图才是好截图","date":"2016-07-26T09:39:20.000Z","updated":"2016-07-30T23:19:03.997Z","comments":true,"path":"2016/07/26/WinSnap-带阴影的截图才是好截图/","link":"","permalink":"http://blog.iamxcc.com/2016/07/26/WinSnap-带阴影的截图才是好截图/","excerpt":"我认为 OS X 内建的截图工具的最大优点就是自动加阴影。正所谓「再小的需求也应该被满足，是的，你可能发现了上文中所有","text":"我认为 OS X 内建的截图工具的最大优点就是自动加阴影。正所谓「再小的需求也应该被满足，是的，你可能发现了上文中所有的截图都是带有阴影的，真的就是 OS X 截图的那种阴影诶！ 如果你也像我一样对这个阴影喜爱有加，你一定需要 WinSnap 这款应用。仅仅 2MB，你便能够在 Windows 上完全实现 OS X 内建截图的效果，阴影和快捷键都不在话下，有过之无不及。 下载地址是：WinSnap ,这个是免安装版本的，下载后可以直接用了。上面的图片恰好是WinSnap热键的自定义菜单，可以根据自己的习惯调节一下","categories":[{"name":"Win10","slug":"Win10","permalink":"http://blog.iamxcc.com/categories/Win10/"}],"tags":[{"name":"Win10","slug":"Win10","permalink":"http://blog.iamxcc.com/tags/Win10/"},{"name":"工具","slug":"工具","permalink":"http://blog.iamxcc.com/tags/工具/"}]},{"title":"Win10上使用Mactype","slug":"Win10上使用Mactype","date":"2016-07-26T02:21:47.000Z","updated":"2016-07-30T23:19:36.867Z","comments":true,"path":"2016/07/26/Win10上使用Mactype/","link":"","permalink":"http://blog.iamxcc.com/2016/07/26/Win10上使用Mactype/","excerpt":"由于window系统上字体渲染很不舒服，故我一直使用mactype来改善一下。但是升级到win10后发现一打开mactype就出现黑屏或者打开界面显示有问题。","text":"由于window系统上字体渲染很不舒服，故我一直使用mactype来改善一下。但是升级到win10后发现一打开mactype就出现黑屏或者打开界面显示有问题。后面查了一些教程后发现在win10上还需要做一些文件替换。下面是教程： 安装首先，安装mactype，到网上随便找一个下载即可。这里提供了百度网盘的下载路径 Mactype。安装的话没什么需要特别注意的。 文件替换安装完成后，先不要打开mactype否则可能会出现黑屏等等问题。先打开mactype的安装目录，像我是在C:\\Program Files (x86)\\MacType这里，这时候用EasyHk32.dll、EasyHk64.dll、MacType.dll、MacType64.dll文件替换掉mactype安装目录下的对应文件。替换文件在刚刚提供的百度网盘里面有。此时打开mactype再设置一番就大功告成了。下面是效果图：可以看到效果还是十分明显的，mactype加载方式我是使用兼容加载的，用注册表加载可能很方便但是会导致较慢的开机速度。","categories":[{"name":"Mactype","slug":"Mactype","permalink":"http://blog.iamxcc.com/categories/Mactype/"}],"tags":[{"name":"Mactype","slug":"Mactype","permalink":"http://blog.iamxcc.com/tags/Mactype/"},{"name":"Win10","slug":"Win10","permalink":"http://blog.iamxcc.com/tags/Win10/"}]},{"title":"99%的人都理解错了HTTP中GET与POST的区别","slug":"99-的人都理解错了HTTP中GET与POST的区别","date":"2016-07-25T05:38:30.000Z","updated":"2016-07-30T23:20:41.884Z","comments":true,"path":"2016/07/25/99-的人都理解错了HTTP中GET与POST的区别/","link":"","permalink":"http://blog.iamxcc.com/2016/07/25/99-的人都理解错了HTTP中GET与POST的区别/","excerpt":"GET和POST是HTTP请求的两种基本方法，要说它们的区别，接触过WEB开发的人都能说出一二。最直观的区别就是GET把参数包含在URL中，POST通过request body传递参数。","text":"GET和POST是HTTP请求的两种基本方法，要说它们的区别，接触过WEB开发的人都能说出一二。最直观的区别就是GET把参数包含在URL中，POST通过request body传递参数。你可能自己写过无数个GET和POST请求，或者已经看过很多权威网站总结出的他们的区别，你非常清楚知道什么时候该用什么。当你在面试中被问到这个问题，你的内心充满了自信和喜悦。你轻轻松松的给出了一个“标准答案”： GET在浏览器回退时是无害的，而POST会再次提交请求。 GET产生的URL地址可以被Bookmark，而POST不可以。 GET请求会被浏览器主动cache，而POST不会，除非手动设置。 GET请求只能进行url编码，而POST支持多种编码方式。 GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。 GET请求在URL中传送的参数是有长度限制的，而POST么有。 对参数的数据类型，GET只接受ASCII字符，而POST没有限制。 GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。 GET参数通过URL传递，POST放在Request body中。（本标准答案参考自w3schools）“很遗憾，这不是我们要的回答！”请告诉我真相。。。如果我告诉你GET和POST本质上没有区别你信吗？让我们扒下GET和POST的外衣，坦诚相见吧！ GET和POST是什么？HTTP协议中的两种发送请求的方法。HTTP是什么？HTTP是基于TCP/IP的关于数据如何在万维网中如何通信的协议。HTTP的底层是TCP/IP。所以GET和POST的底层也是TCP/IP，也就是说，GET/POST都是TCP链接。GET和POST能做的事情是一样一样的。你要给GET加上request body，给POST带上url参数，技术上是完全行的通的。 那么，“标准答案”里的那些区别是怎么回事？ 在我大万维网世界中，TCP就像汽车，我们用TCP来运输数据，它很可靠，从来不会发生丢件少件的现象。但是如果路上跑的全是看起来一模一样的汽车，那这个世界看起来是一团混乱，送急件的汽车可能被前面满载货物的汽车拦堵在路上，整个交通系统一定会瘫痪。为了避免这种情况发生，交通规则HTTP诞生了。HTTP给汽车运输设定了好几个服务类别，有GET, POST, PUT, DELETE等等，HTTP规定，当执行GET请求的时候，要给汽车贴上GET的标签（设置method为GET），而且要求把传送的数据放在车顶上（url中）以方便记录。如果是POST请求，就要在车上贴上POST的标签，并把货物放在车厢里。当然，你也可以在GET的时候往车厢内偷偷藏点货物，但是这是很不光彩；也可以在POST的时候在车顶上也放一些数据，让人觉得傻乎乎的。HTTP只是个行为准则，而TCP才是GET和POST怎么实现的基本。 但是，我们只看到HTTP对GET和POST参数的传送渠道（url还是requrest body）提出了要求。“标准答案”里关于参数大小的限制又是从哪来的呢？ 在我大万维网世界中，还有另一个重要的角色：运输公司。不同的浏览器（发起http请求）和服务器（接受http请求）就是不同的运输公司。 虽然理论上，你可以在车顶上无限的堆货物（url中无限加参数）。但是运输公司可不傻，装货和卸货也是有很大成本的，他们会限制单次运输量来控制风险，数据量太大对浏览器和服务器都是很大负担。业界不成文的规定是，（大多数）浏览器通常都会限制url长度在2K个字节，而（大多数）服务器最多处理64K大小的url。超过的部分，恕不处理。如果你用GET服务，在request body偷偷藏了数据，不同服务器的处理方式也是不同的，有些服务器会帮你卸货，读出数据，有些服务器直接忽略，所以，虽然GET可以带request body，也不能保证一定能被接收到哦。 好了，现在你知道，GET和POST本质上就是TCP链接，并无差别。但是由于HTTP的规定和浏览器/服务器的限制，导致他们在应用过程中体现出一些不同。 你以为本文就这么结束了？ 我们的大BOSS还等着出场呢。。。 这位BOSS有多神秘？当你试图在网上找“GET和POST的区别”的时候，那些你会看到的搜索结果里，从没有提到他。他究竟是什么呢。。。 GET和POST还有一个重大区别，简单的说：GET产生一个TCP数据包；POST产生两个TCP数据包。 长的说：对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。 也就是说，GET只需要汽车跑一趟就把货送到了，而POST得跑两趟，第一趟，先去和服务器打个招呼“嗨，我等下要送一批货来，你们打开门迎接我”，然后再回头把货送过去。 因为POST需要两步，时间上消耗的要多一点，看起来GET比POST更有效。因此Yahoo团队有推荐用GET替换POST来优化网站性能。但这是一个坑！跳入需谨慎。为什么？ GET与POST都有自己的语义，不能随便混用。 据研究，在网络环境好的情况下，发一次包的时间和发两次包的时间差别基本可以无视。而在网络环境差的情况下，两次包的TCP在验证数据包完整性上，有非常大的优点。 并不是所有浏览器都会在POST中发送两次包，Firefox就只发送一次。 现在，当面试官再问你“GET与POST的区别”的时候，你的内心是不是这样的？","categories":[{"name":"HTTP","slug":"HTTP","permalink":"http://blog.iamxcc.com/categories/HTTP/"}],"tags":[{"name":"HTTP","slug":"HTTP","permalink":"http://blog.iamxcc.com/tags/HTTP/"},{"name":"GET","slug":"GET","permalink":"http://blog.iamxcc.com/tags/GET/"},{"name":"POST","slug":"POST","permalink":"http://blog.iamxcc.com/tags/POST/"}]},{"title":"Research directions for IOT","slug":"Research directions for IOT","date":"2016-07-20T00:57:18.000Z","updated":"2016-07-26T03:06:06.709Z","comments":true,"path":"2016/07/20/Research directions for IOT/","link":"","permalink":"http://blog.iamxcc.com/2016/07/20/Research directions for IOT/","excerpt":"As each individual system has its own assumptions and strategy to control the physical world variables without much knowledge of the other systems,","text":"As each individual system has its own assumptions and strategy to control the physical world variables without much knowledge of the other systems, which leads to conflicts when these systems are integrated without careful consideration. 1.What`s the problem of dependency in IOT?As each individual system has its own assumptions and strategy to control the physical world variables without much knowledge of the other systems, which leads to conflicts when these systems are integrated without careful consideration. Such problems arise in the cyber part mainly because each application has assumptions on the physical world entities without knowing how other applications work. Let’s use an example to better illustrate “what the problem of dependency” are: a home health care application may detect depression and decide to turn on all the lights. On the other hand, the energy management application may decide to turn off lights when no motion is detected. Detecting and resolving such dependency problems is important for correctness of operation of interacting IoT systems. The problem of dependencies are: App interdependency: It arises when one app relies on another app. If the independent app makes an error, the error may propagate and affect all the dependent apps and may cause a lot of conflicts in the system.t Control dependency for the sensors and actuators: It arises when multiple apps want to control a sensor in different ways.For example, App1 wants to run a humidifier and App2 wants to run a dehumidifier at the same time. Missing dependency: It arises when app developers forget to specify the dependency information of their apps. For example, App1 forgets to specify its dependency on light L1 in its meta data., but at runtime it tries to control L1. 2.What`s the major technologies to address the dependency issues in IOT?Cyber Physical system(CPS)We can propose a integrated CPS, a utility sensing and actuation system that provides comprehensive strategies to specify, detect, and resolve conflicts.This system consideres a comprehensive spectrum of dependencies and treating each system as an app. Each system communicates with its sensors and actuators and performs computations for taking appropriate control decisions to actuate on the physical world entities. App developers specify dependency information as meta data within their apps and their apps are put in an app store. Users can choose and install apps from the app store. This system can use the meta-data to detect and resolve conflicts at app installation time and at run-time. Let`s take some examples to introduce this ststem: addressing requirement dependency: This system reqiures developers to specify the requirement of each app in a manifest file written in XML.just like this : 123456789101112&lt;requirement&gt; &lt;device&gt; &lt;device_type&gt; x10_motion_sensor &lt;/device_type&gt; &lt;container&gt; room &lt;/container&gt; &lt;level&gt; strict &lt;/level&gt; &lt;/device&gt; &lt;device&gt; &lt;device_type&gt; x10_contact_sensor &lt;/device_type&gt; &lt;container&gt; window, door &lt;/container&gt; &lt;level&gt; strict &lt;/level&gt; &lt;/device&gt; &lt;/requirement&gt; Requirements can be either strict or loose. The motion sensor requirement is strict, which means that the app will not work without the motion sensors.But the app will still work without the contact sensors. adderssing actuator control dependency: Resolving control dependency of the actuators in a wrong way may cause death, e.g, granting an app’s request to turn off the breathing machine to save energy while it is being used by another health app.therefore, this system will detect such conflicts when two apps try to access the same device at the same time and resolve the conflict in favor of the higher priority app.It requires app developers to specify in XMLeffect,emphasis, and condition for each actuator that app wants to control. EffectEffect specifies the effect of an app on the environment when using a particular device.Two apps may be using completely different devices, but are conflicting with each orher by causing opposite effects.The XML tags can be increase, decrease, and change.For example, App1 may specify:123456&lt;device&gt; &lt;device_name&gt; humidifier &lt;/device_name&gt; &lt;effect&gt; &lt;humidity&gt; increase &lt;/humidity&gt; &lt;/effect&gt;&lt;/device&gt; On the other hand, App2 mey specify:123456&lt;device&gt; &lt;device_name&gt; humidifier &lt;/device_name&gt; &lt;effect&gt; &lt;humidity&gt; increase &lt;/humidity&gt; &lt;/effect&gt;&lt;/device&gt; When two apps have an opposite effect, they will not conflict. When two apps have an opposite effect, there is a chance that they will conflict at runtime. When two apps have the same effect, or mixed effect, system will look into emphasis andconditionto determine whether these apps will conflict or not. EmphasisEmphasis is based on the insight that not all control operations are equally important to an app, and emphasis allows an app to specify which device operation is more important than others.The security app mentioinsed above specifies its emphasis for controlling lights:123&lt;emphasis&gt; &lt;operation&gt; On() &lt;/operation&gt;&lt;/emphasis&gt; The energy app mentioned above specified above specifies its emphasis for controlling lights:1234&lt;emphasis&gt; &lt;operation&gt; On() &lt;/operation&gt; &lt;operation&gt; Off() &lt;/operation&gt;&lt;/emphasis&gt; when two apps have the same emphasis, then they are not conflicting with each other. if the emphasis of two apps is different, then they may be conflicting(also depends on conditions). ConditionTwo apps are not conflicting if they operate on a device with a mutually exclusive condition.The conditions can be categorized into two groups: (1)conditions based on time.(2)conditions based on event. Here are some example:1234&lt;start_time&gt; 20:00:00&lt;/start_time&gt;&lt;end_time&gt; 21:00:00 &lt;/end_time&gt;&lt;night&gt; duration &lt;/night&gt;&lt;sunset&gt; begin &lt;/sunset&gt; 3.What’s the questions and gaps that need to be filled in IoT system with examples?####SecurityA fundamental problem that must be solved in IOT is dealing with security problem.It worth to think about 3 security problem as follow: dependency issues – Do you know when something goes wrong?The aforementioned paragraph suggests that resolving control dependency of the actuators in a wrong way may cause death, e.g, granting an app’s request to turn off the breathing machine to save energy while it is being used by another health app. Data Encryption – Is your data protected?At a glance, many developers may be inclined to use SSL for secure communications. However, this can be problematic in an M2M application due to the additional processing power and memory required in a device to support SSL, and the increased wireless data costs that are a product of the increase in network communications overhead. Controlling access – Who can access your data/system?While encryption is demanded for private information, in some instances, confidentiality may be far less important than access and authentication. For example, the data transmitted with a wireless command to open your car door may not be confidential, but it is critical that no unauthorized parties have access to unlock the door through that system. PrivacyDespite the immense potential of IoT in the various spheres, the whole communication infrastructure of the IoT is flawed from the security standpoint and is susceptible to loss of privacy for the end users. Some of the most prominent security issues plaguing the entire developing IoT system arise out of the security issues present in the technologies used in IoT for information relay from one device to another. As such some of the prominent security issues stemming out from the communication technology are the following:( Wireless Sensor Networks (WSN) ) DoS attack on the physical layer:The physical layer of a wireless sensor network carries out the function of selection and generation of carrier frequency, modulation and demodulation, encryption and decryption, transmission and reception of data. This layer of the wireless sensor network is attacked mainly through Jamming: In this type of DoS attack occupies the communication channel between the nodes thus preventing them from communicating with each other. Node tampering: Physical tampering of the node to extract sensitive information is known as node tampering. DoS attack on the link layer:The link layer of WSN multiplexes the various data streams, provides detection of data frame, MAC and error control. Moreover the link layer ensures point-point or pointmultipoint reliability . The DoS attacks taking place in this layer are: Collision: This type of DoS attack can be initiated whentwo nodes simultaneously transmit packets of data on the same frequency channel. Unfairness: As described in , unfairness is a repeated collision based attack. It can also be referred to as exhaustion based attacks. Battery Exhaustion: This type of DoS attack causes unusually high traffic in a channel making its accessibility very limited to the nodes. Such a disruption in the channel is caused by a large number of requests (Request To Send) and transmissions over the channel. DoS attack on the network layer:The main function of the network layer of WSN is routing. The specific DoS attacks taking place in this layer are: Spoofing, replaying and misdirection of traffic. Hello flood attack: This attack causes high traffic in channels by congesting the channel with an unusually high number of useless messages. Here a single malicious node sends a useless message which is then replayed by the attacker to create a high traffic. Homing: In case of homing attack, a search is made in the traffic for cluster heads and key managers which have the capability to shut down the entire network. DoS attack on the transport layer:This layer of the WSN architecture provides reliability of data transmission and avoids congestion resulting from high traffic in the routers. The DoS attacks in this layer are: Flooding: It refers to deliberate congestion of communication channels through relay of unnecessary messages and high traffic. De-synchronization: In de-synchronization attack, fake messages are created at one or both endpoints requesting retransmissions for correction of non-existent error. This results in loss of energy in one or both the end-points in carrying out the spoofed instructions. ####Data ChallengeThe technologies to address the big data challenge already exist, like Hadoop or NoSQL, providing horizontal scalability, high capacity and parallel processing at prices that make them affordable and economical.With the development of wearables for consumers and the emerging use of smart machines the portion of IoT as a subset of big data will grow quickly forcing enterprises to think their infrastructure to enable scalability and to make them cost effective. ####Server TechnologiesThe impact of IoT on the server market will be largely focused on increased investment in key vertical industries and organizations related to those industries where IoT can be profitable, or add significant value.Some organizations that manage and consume data collected from a huge array of devices will require additional compute capacity and may well increase server budgets if there is a business case for it. ####Data Center NetworkExisting data center WAN (Wide Area Network) links have been built for moderate-bandwidth requirements created by our current use of technology. However, as the amount of data being transferred is set to increase dramatically, the need for expanded bandwidth grows.The result of all this, the research points out, is that because of the scale of the data being created it will no longer be economically feasible to store data at a single location. Reference[1] S. Munir and J. Stankovic, “DepSys: Dependency aware integration of systems for smart homes,” in Proc. ACM/IEEE Int. Conf. Cyber Phys. Syst.,Apr. 2014.[2] J. Stankovic, “When sensor, and actuator networks cover the world,invited keynote article,” ETRI J., vol. 30, no. 5, pp. 627–633, Oct. 2008.[3] Security. http://embedded-computing.com/guest-blogs/5-security-questions-for-your-next-iot-deployment/[4] Tuhin Borgohain, Uday Kumar, Sugata Sanyal. “Survey of Security and Privacy Issues of Internet of Things“. Fri, 9 Jan 2015.[5] “7 Big Problems with the Internet of Things”. http://www.cmswire.com/cms/internet-of-things/7-big-problems-with-the-internet-of-things-024571.php","categories":[{"name":"物联网","slug":"物联网","permalink":"http://blog.iamxcc.com/categories/物联网/"}],"tags":[{"name":"物联网","slug":"物联网","permalink":"http://blog.iamxcc.com/tags/物联网/"}]},{"title":"sass安装","slug":"sass安装","date":"2016-06-19T14:59:33.000Z","updated":"2016-07-30T23:20:15.928Z","comments":true,"path":"2016/06/19/sass安装/","link":"","permalink":"http://blog.iamxcc.com/2016/06/19/sass安装/","excerpt":"Sass 是最早的 CSS 预处理语言，有比 LESS 更为强大的功能，不过其一开始的缩进式语法（Sass老版本语法)并不能被大众接受","text":"Sass 是最早的 CSS 预处理语言，有比 LESS 更为强大的功能，不过其一开始的缩进式语法（Sass老版本语法)并不能被大众接受，不过由于其强大的功能和 Ruby on Rails 的大力推动，还是有很多开发者选择了 Sass。Sass 是采用 Ruby 语言编写的一款 CSS 预处理语言，它诞生于2007年，是最大的成熟的 CSS 预处理语言。最初它是为了配合 HAML（一种缩进式 HTML 预编译器）而设计的，因此有着和 HTML 一样的缩进式风格。 Ruby安装在 Windows 平台下安装 Ruby 需要先有 Ruby 安装包，大家可以到 Ruby 的 官网下载对应需要的 Ruby 版本。Ruby 安装文件下载好后，可以按应用软件安装步骤进行安装 Ruby。在安装过程中，个人建议将其安装在 C 盘下，在安装过程中选择第二个选项（不选中，就会出现编译时找不到Ruby环境的情况），如下图所示： Ruby 安装完成后，在开始菜单中找到新安装的 Ruby，并启动 Ruby 的 Command 控制面板，如下图所示： Sass安装当你的电脑中安装好 Ruby 之后，接下来就可以安装 Sass 了。同样的在windows下安装 Sass 有多种方法。但这几种方法都是非常的简单，只需要在你的命令终端输入一行命令即可。 1、通过命令安装 Sass打开电脑的命令终端，输入下面的命令：1gem install sass 提醒一下，在使用 Mac 的同学，可能需要在上面的命令前加上”sudo”，才能正常安装：1sudo gem install sass 如果上面的方法没有安装成功，可以使用下面的两种方法。 2、通过 Compass 来安装 Sass除了使用 gem 命令来安装 Sass 之外，还可以通过安装 compass 来安装 Sass，因为 Compass 是基于 Sass 开发的一个框架。也就是说，你安装了 Compass，也就同时安装好了 Sass。 同样的在你的命令终端输入下面的命令： 1sudo gem install sass 执行完上面的命令之后，就开始安装 Compass 和 Sass。 注：Compass 是一个成熟的、基于 Sass 开发的一个框架，这里面集成了很多写好的 mixins 和 Sass 函数。不过在此暂不做过多阐述。 3、本地安装Sass由于有时候直接使用上面的命令安装会让你无法正常实现安装（网络受限原因），当碰到这种情况之时，那么安装需要特殊去处理，可以通过下面的方法来实现 Sass 的正常安装： 可以到 Rubygems 网站上将 Sass 的安装包（http://rubygems.org/gems/sass）下载下来，然后在命令终端输入： 1gem install &lt;把下载的安装包拖到这里&gt; 直接回车即可安装成功。 注：在 iOSX和win10系统平台，可以直接将下载的安装包拖到 “gem install” 后面。 4、淘宝 RubyGems 镜像安装 Sass除了下载 Sass 安装包到本地安装之外，碰到网络原因无法安装时还可以使用淘宝 RubyGems 镜像安装 Sass。只是我们需要通过 gem sources 命令来配置源，先移除默认的 https://rubygems.org 源，然后添加淘宝的源 https://ruby.taobao.org： 第一步：移动默认的源 1gem sources --remove https://rubygems.org/ 第二步：指定淘宝的源 1gem sources -a https://ruby.taobao.org/ 第三步：查看指定的源是不是淘宝源 1gem sources -l 返回结果如下： 12*** CURRENT SOURCES ***https://ruby.taobao.org 请确保只有 ruby.taobao.org。如果无误之后，执行下面的命令： 1gem install sass","categories":[{"name":"Sass","slug":"Sass","permalink":"http://blog.iamxcc.com/categories/Sass/"}],"tags":[{"name":"Sass","slug":"Sass","permalink":"http://blog.iamxcc.com/tags/Sass/"},{"name":"css","slug":"css","permalink":"http://blog.iamxcc.com/tags/css/"}]},{"title":"Git系列之安装","slug":"Git系列之安装","date":"2016-06-16T05:34:53.000Z","updated":"2016-07-27T05:25:40.577Z","comments":true,"path":"2016/06/16/Git系列之安装/","link":"","permalink":"http://blog.iamxcc.com/2016/06/16/Git系列之安装/","excerpt":"最早Git是在Linux上开发的，很长一段时间内，Git也只能在Linux和Unix系统上跑。不过，慢慢地有人把它移植到了Windows上。","text":"最早Git是在Linux上开发的，很长一段时间内，Git也只能在Linux和Unix系统上跑。不过，慢慢地有人把它移植到了Windows上。现在，Git可以在Linux、Unix、Mac和Windows这几大平台上正常运行了。这里主要讲windows下Git的安装，其他平台的可以到网上去搜索解决。win下安装十分简单，因为Git官网已经将其打包了，直接下载下来双击然后按照步骤安装即可。这里是Git官网 安装安装完成后，在开始菜单里找到“Git”-&gt;“Git Bash”，弹出一个类似命令行窗口的东西，就说明Git安装成功！如下图所示：","categories":[{"name":"Git","slug":"Git","permalink":"http://blog.iamxcc.com/categories/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://blog.iamxcc.com/tags/Git/"}]},{"title":"通信协议之Http","slug":"通信协议之Http","date":"2016-06-16T02:54:50.000Z","updated":"2016-07-30T23:20:50.892Z","comments":true,"path":"2016/06/16/通信协议之Http/","link":"","permalink":"http://blog.iamxcc.com/2016/06/16/通信协议之Http/","excerpt":"生活中我们接触的比较多的通信协议有HTTP、TCP、UDP等等。特别是HTTP协议，因为我们每天上网在浏览器中","text":"生活中我们接触的比较多的通信协议有HTTP、TCP、UDP等等。特别是HTTP协议，因为我们每天上网在浏览器中输入的网址基本都可以看到以http://开头的字符串。那么什么是通信协议呢？简而言之就是通信时所遵守的规则，只有双方按照这个规则“说话”，对方才能理解或为之服务。这里只是很口语化的解释，详细的解释可以到这里查看： 百度百科 维基百科 HTTP、TCP、UDP的区别TCP/IP是个协议组，可分为四个层次：网络接口层、网络层、传输层和应用层。 在网络层有IP协议、ICMP协议、ARP协议、RARP协议和BOOTP协议。 在传输层中有TCP协议与UDP协议。 在应用层有FTP、HTTP、TELNET、SMTP、DNS等协议。因此，HTTP本身就是一个协议，是从Web服务器传输超文本到本地浏览器的传送协议。 什么是HTTP协议HTTP全称是HyperText Transfer Protocal，即：超文本传输协议，从1990年开始就在WWW上广泛应用，是现今在WWW上应用最多的协议， Http是应用层协议，当你上网浏览网页的时候，浏览器和Web服务器之间就会通过HTTP在Internet上进行数据的发送和接收。Http是一个基于请求/响应模式的、无状态的协议。即我们通常所说的Request/Response。 URLURL(Uniform Resource Locator) 地址用于描述一个网络上的资源, 基本格式如下12345678schema://host[:port#]/path/.../[?query-string][#anchor]scheme 指定低层使用的协议(例如：http, https, ftp)host HTTP服务器的IP地址或者域名port# HTTP服务器的默认端口是80，这种情况下端口号可以省略。如果使用了别的端口，必须指明，例如 http://www.cnblogs.com:8080/path 访问资源的路径query-string 发送给http服务器的数据anchor- 锚 URL 的一个例子1234567http://www.mywebsite.com/sj/test/test.aspx?name=sviergn&amp;x=true#stuffSchema: httphost: www.mywebsite.compath: /sj/test/test.aspxQuery String: name=sviergn&amp;x=trueAnchor: stuff HTTP的Request/Response先看Request 消息的结构,Request消息分为3部分 第一部分叫Request line。 第二部分叫Request header。 第三部分是body. header和body之间有个空行。 第一行中的Method表示请求方法,比如”POST”,”GET”, Path-to-resoure表示请求的资源， Http/version-number 表示HTTP协议的版本号当使用的是”GET” 方法的时候， body是为空的比如我们打开博客园首页的request 如下GET http://www.cnblogs.com/ HTTP/1.1Host: www.cnblogs.com抽象的东西，难以理解，老感觉是虚的， 所谓眼见为实, 实际见到的东西，我们才能理解和记忆。 我们今天用Fiddler，实际的看看Request和Response.下面我们打开Fiddler 捕捉一个博客园登录的Request 然后分析下它的结构, 在Inspectors tab下以Raw的方式可以看到完整的Request的消息。如下图：","categories":[{"name":"HTTP","slug":"HTTP","permalink":"http://blog.iamxcc.com/categories/HTTP/"}],"tags":[{"name":"HTTP","slug":"HTTP","permalink":"http://blog.iamxcc.com/tags/HTTP/"},{"name":"通信协议","slug":"通信协议","permalink":"http://blog.iamxcc.com/tags/通信协议/"}]},{"title":"wampserver配置多站点","slug":"wampserver配置多站点","date":"2016-06-14T04:54:06.000Z","updated":"2016-07-30T23:19:46.917Z","comments":true,"path":"2016/06/14/wampserver配置多站点/","link":"","permalink":"http://blog.iamxcc.com/2016/06/14/wampserver配置多站点/","excerpt":"一般而言，当我们在本地调试网站时都会有多个站点。这时候为了方便区分各个网站，就需要设置多站点，即给每个站点取一个网址。","text":"一般而言，当我们在本地调试网站时都会有多个站点。这时候为了方便区分各个网站，就需要设置多站点，即给每个站点取一个网址。当然，这个网址只能在本地打开。这里，就介绍一下wampserver在win10下怎么设置多站点。 修改wampserver配置文件在wampserver安装位置\\bin\\apache\\apache\\apache2.4.17\\conf\\httpd.conf文件中查找Include conf/extra/httpd-vhosts.conf，去掉前面的注释#。打开wampserver安装位置\\bin\\apache\\apache\\apache2.4.17\\conf\\extra/httpd-vhosts.conf文件；在最后加入类似内容：（文件路径是自己安装程序的路径） 1234&lt;VirtualHost *:80&gt; DocumentRoot \"D:/wamp/www/blog\"(这是你放程序的文件路径) ServerName www.yoursite.com （这是自己定义的域名）&lt;/VirtualHost&gt; 修改windows下的hosts文件通过win+R在run下输入drivers，打开etc\\hosts文件，在最后加入127.0.0.1 www.yoursite.com （这是自己定义的域名） 结论123456# localhost name resolution is handled within DNS itself.# 127.0.0.1 localhost# ::1 localhost127.0.0.1 blog.iamxcc.com127.0.0.1 www.sf.com 以上是我的hosts文件内容，可以看出我定义了两个站点一个是blog.iamxcc.com, 另一个是www.sf.com。 123456789&lt;VirtualHost *:80&gt; DocumentRoot \"D:\\Web\\wamp64\\www\\my-site\\blog\" ServerName blog.iamxcc.com&lt;/VirtualHost&gt;&lt;VirtualHost *:80&gt; DocumentRoot \"D:\\Web\\wamp64\\www\\my-site\\sf\" ServerName www.sf.com&lt;/VirtualHost&gt; 其中blog.iamxcc.com指向位于D:\\Web\\wamp64\\www\\my-site\\blog下的站点，www.sf.com指向D:\\Web\\wamp64\\www\\my-site\\blog下的站点。到此为止，wampserver配置多任务已经成功。","categories":[{"name":"Wampserver","slug":"Wampserver","permalink":"http://blog.iamxcc.com/categories/Wampserver/"}],"tags":[{"name":"Wampserver","slug":"Wampserver","permalink":"http://blog.iamxcc.com/tags/Wampserver/"},{"name":"Wordpress","slug":"Wordpress","permalink":"http://blog.iamxcc.com/tags/Wordpress/"}]},{"title":"c语言交换a、b的方法","slug":"c语言交换a、b的方法","date":"2016-06-13T15:42:03.000Z","updated":"2016-07-30T23:20:27.691Z","comments":true,"path":"2016/06/13/c语言交换a、b的方法/","link":"","permalink":"http://blog.iamxcc.com/2016/06/13/c语言交换a、b的方法/","excerpt":"C语言中要实现两个变量值的交换一般而言可以分为两种方法：不引入中间变量和引入中间变量。具体代码如下：","text":"C语言中要实现两个变量值的交换一般而言可以分为两种方法：不引入中间变量和引入中间变量。具体代码如下： 常规方法一般而言，在C语言中交换a、b两个值时，我们常用的是使用指针来交换。具体的代码如下：1234567void swap(int *a ,int *b) //通过指针交换两者的值&#123; int c; c = *a; *a = *b; *b= c;&#125; 通过异或来实现除了上面的方法，还有一种更加简洁的办法如下：123456void swap(int &amp;a,int &amp;b) //通过异或交换两者的值&#123; a =a^b; b= a^b; a = b^a;&#125;","categories":[{"name":"C语言","slug":"C语言","permalink":"http://blog.iamxcc.com/categories/C语言/"}],"tags":[{"name":"C语言","slug":"C语言","permalink":"http://blog.iamxcc.com/tags/C语言/"},{"name":"算法","slug":"算法","permalink":"http://blog.iamxcc.com/tags/算法/"}]},{"title":"一加通过adb刷机","slug":"一加通过adb刷机","date":"2016-05-27T15:26:19.000Z","updated":"2016-07-30T23:20:53.029Z","comments":true,"path":"2016/05/27/一加通过adb刷机/","link":"","permalink":"http://blog.iamxcc.com/2016/05/27/一加通过adb刷机/","excerpt":"经常刷Android机的朋友应该知道刷机方法有两种：一种是线刷，另一种是卡刷。两种方式都十分简单。下面就两种方法分别介绍：","text":"经常刷Android机的朋友应该知道刷机方法有两种：一种是线刷，另一种是卡刷。两种方式都十分简单。下面就两种方法分别介绍： 线刷包与卡刷包的区别1.名字的不同一般而言，名字中带有fastboot的都是线刷包 2.文件中的区别卡刷包线刷包 adb 刷机1adb sideload rom.zip","categories":[{"name":"Android","slug":"Android","permalink":"http://blog.iamxcc.com/categories/Android/"}],"tags":[{"name":"Oneplus","slug":"Oneplus","permalink":"http://blog.iamxcc.com/tags/Oneplus/"},{"name":"Android","slug":"Android","permalink":"http://blog.iamxcc.com/tags/Android/"}]},{"title":"Hello World","slug":"hello-world","date":"2015-06-12T05:34:53.000Z","updated":"2016-08-13T06:29:32.105Z","comments":true,"path":"2015/06/12/hello-world/","link":"","permalink":"http://blog.iamxcc.com/2015/06/12/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info.","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[{"name":"随笔","slug":"随笔","permalink":"http://blog.iamxcc.com/categories/随笔/"}],"tags":[]}]}