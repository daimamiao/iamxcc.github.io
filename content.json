{"meta":{"title":"Iamxcc","subtitle":null,"description":"This is the moment","author":"XCC","url":"http://yoursite.com"},"pages":[{"title":"","date":"2016-06-21T02:03:29.832Z","updated":"2016-05-17T23:30:47.000Z","comments":true,"path":"google46447695f1c84c21.html","permalink":"http://yoursite.com/google46447695f1c84c21.html","excerpt":"","text":"google-site-verification: google46447695f1c84c21.html"},{"title":"分类","date":"2016-08-04T11:10:57.697Z","updated":"2016-08-04T11:10:57.697Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"About","date":"2016-07-24T12:53:31.331Z","updated":"2016-07-24T12:53:31.331Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"The blog theme you may fall in love with, coming to Hexo. Preview InstallationInstall1$ git clone https://github.com/ppoffice/hexo-theme-icarus.git themes/icarus Icarus requires Hexo 3.0 and above. Enable Rename themes\\icarus\\_config.yml.example to themes\\icarus\\_config.yml; Copy themes\\icarus\\_config.yml.site.example to your hexo blog’s root directory and rename it to _config.yml; Copy themes\\icarus\\_source\\* into your hexo blog’s directory source; Then modify theme setting in _config.yml to icarus. Update12cd themes/icarusgit pull ConfigurationTheme configuration example1234567891011121314151617181920212223242526272829303132333435363738394041# Headermenu: Home: . Archives: archives Categories: categories # you need to add extra page to enable this, please see the config below. Tags: tags # you need to add extra page to enable this, please see the config below. About: about# Contentexcerpt_link: Read Morefancybox: true# Sidebarsidebar: rightwidgets:- recent_posts- category- tag- tagcloud- archivethumbnail: true# Contactscontacts: github: http://github.com/ppoffice/hexo-theme-icarus twitter: '#' facebook: '#' dribbble: '#' rss: atom.xml# Linkslinks: Hexo: http://hexo.io# Miscellaneousgoogle_analytics:favicon: favicon.pngtwitter:google_plus:fb_admins:fb_app_id: excerpt_link - Cooperate with &lt;!-- more --&gt; tag to show only part of the article in index pages. fancybox - Enable Fancybox. contacts - Your social network links, RSS link, etc. widgets - Widgets displaying in sidebar. thumbnail - Whether to show post thumbnails in the sidebar and archive pages. links - Links displayed in the link widget. google_analytics - Google Analytics ID. favicon - Favicon path. Site configuration example123456789101112131415# Sitetitle: Icarussubtitle:description: Hexo theme - Icarusauthor: PPOfficeauthor_title: 'Web Developer &amp; Designer'avatar: css/images/avatar.pnglocation: 'Harbin, China'language: entimezone:...# Disqusdisqus_shortname: author - Your name. author_title - Title to your occupation. avatar - Your avatar image link. location - Where you live in. disqus_shortname - Your Disqus shortname. Post Thumbnail &amp; BannerYou can add a thumbnail and a banner to each post by adding the following lines into your post source files’ front-matter:123456title: Demodate: 2015-01-01...# add thosethumbnail: http://example.com/thumbnail.jpgbanner: http://example.com/banner.jpg Custom Categories &amp; Tags PagesTo enable custom categories page and tags page, just copy the categories folder and tags folder under your theme’s _source foler into your site’s source folder. Then edit theme’s _config.yml and add the following lines:123456# Headermenu: ... Categories: categories # -&gt; add this line Tags: tags # -&gt; and add this line ... LanguagesEnglish and Simplified Chinese are the default languages of the theme. You can add translations in the languages folder and change the default language in blog’s _config.yml. 1language: zh-CN FeaturesProfile SidebarA nice place to show yourself. You can add your own information in your site’s _config.yml Post Banner &amp; ThumbnailThanks to atika, you can now add thumbnails and banners to every post to create better reading experience. Responsive LayoutIcarus knows on what screen size you are browsering the website, and reorganize the layout to fit your device. Custom Categories &amp; Tags PagesGet your categories and tags listed in single pages to make your blog more methodic. FancyboxIcarus uses Fancybox to showcase your photos. You can use Markdown syntax or fancybox tag plugin to add your photos. 1![img caption](img url) SidebarIcarus provides 6 built-in widgets: recent_posts category archives tag tagcloud links All of them are enabled by default. You can edit them in widget setting. DevelopmentRequirements Grunt 0.4+ Hexo 3.0+ Grunt tasks default - Download Fancybox and Font Awesome. fontawesome - Only download Font Awesome. fancybox - Only download Fancybox. clean - Clean temporarily files and downloaded files."},{"title":"search","date":"2016-07-26T15:35:55.179Z","updated":"2016-05-16T06:06:40.000Z","comments":true,"path":"search/index.html","permalink":"http://yoursite.com/search/index.html","excerpt":"","text":""},{"title":"标签","date":"2016-08-04T11:11:07.073Z","updated":"2016-08-04T11:11:07.073Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"NULL,'\\0',0,'/0'和\"0\"的区别","slug":"0-、0、0、-0-、NULL","date":"2016-08-05T13:03:42.000Z","updated":"2016-08-05T13:29:20.946Z","comments":true,"path":"2016/08/05/0-、0、0、-0-、NULL/","link":"","permalink":"http://yoursite.com/2016/08/05/0-、0、0、-0-、NULL/","excerpt":"最近发现对于NULL,’\\0’,0,’/0’和”0”的区别有点混淆了。所以在查阅资料之后，将笔记记录在此处，免得下次忘记了可以看看。","text":"最近发现对于NULL,’\\0’,0,’/0’和”0”的区别有点混淆了。所以在查阅资料之后，将笔记记录在此处，免得下次忘记了可以看看。 NULLNULL 即空指针，在C和C++中的形式不一样，msdn上有如下的内容那个：1234567#if !defined(NULL)&amp;&amp;defined(__NEEDS_NULL) #ifdef __cplusplus #define NULL 0 #else #define NULL ((void *)0) #endif#endif NULL 在c中用（void*）0表示，在c++中用0表示。 ‘\\0’和’0’ ‘\\0’表示字符串结束，它在ASCII中的值为0（数值0，非字符‘0’。所以在数值上NULL, ‘\\0’,0是一样的，都是0，但’0’就不同了，在ASCII码中编码为48，所以字符0和上述三个值不同。 在内存中NULL 和&#39;\\0&#39; 和&#39;0&#39;都是一个8位的char类型，NULL 和’\\0’ 值一样，都是0，以数字方式读取就是0，以字符串读取时就是’\\0’或者null（和编译器有关）。 而&#39;0&#39;在内存存储着48，以字符读取就是&#39;0&#39;,以数字读取就是48，至于0，可能是char ,int ,float,double等类型，但是值和NULL和&#39;\\0&#39;一样，都是0。 ‘/0’和’\\0’我在写C代码时，经常把’\\0’写成’/0’。其实这两者之间差别很大的。因为’/0’表示的是两个字符了，一个是’/‘, 另一个’0’。而’\\0’表示的字符串结束，值为0。 “0”“0”表示的是字符串，即在存储中存储了两个内容，一个是’0’(即字符0)，另一个是字符串结束符’\\0’(也即数字0)。 举例为了说明情况，下面列举了几个例子。1234567891011printf(\"%d\",'0'); ==&gt;48printf(\"%c\",'0'); ==&gt;0printf(\"%c\",0); ==&gt;空（即NULL）printf(\"%d\",0); ==&gt;0那么0+'0',0+'\\0'分别是什么呢？printf(\"%c\",0+'\\0'); ==&gt;空（NULL）//先转换成int,然后ASCII编码相加为0，%c输出，转换成char,所以输出NULLprintf(\"%d\",0+'\\0'); ==&gt;0 //先转换成int，然后ASCII编码相加为0, %d输出，不用转换，输出数字0printf(\"%c\",0+'0'); ==&gt;0printf(\"%d\",0+'0'); ==&gt;48","categories":[{"name":"C语言","slug":"C语言","permalink":"http://yoursite.com/categories/C语言/"}],"tags":[{"name":"C语言","slug":"C语言","permalink":"http://yoursite.com/tags/C语言/"}]},{"title":"LeetCode 263: Ugly Number","slug":"LeetCode-263-Ugly-Number","date":"2016-08-05T11:28:12.000Z","updated":"2016-08-05T11:29:54.368Z","comments":true,"path":"2016/08/05/LeetCode-263-Ugly-Number/","link":"","permalink":"http://yoursite.com/2016/08/05/LeetCode-263-Ugly-Number/","excerpt":"Write a program to check whether a given number is an ugly number. Ugly numbers are positive numbers whose prime factors only include 2, 3, 5.","text":"Write a program to check whether a given number is an ugly number. Ugly numbers are positive numbers whose prime factors only include 2, 3, 5. For example, 6, 8 are ugly while 14 is not ugly since it includes another prime factor 7. Note that 1 is typically treated as an ugly number. 代码C语言版本：12345678bool isUgly(int num) &#123; for (int i=2; i&lt;6 &amp;&amp; num; i++) &#123; while (num % i == 0) &#123; num /= i; &#125; &#125; return num == 1;&#125; 1012 / 1012 test cases passed.Status: AcceptedRuntime: 4 ms","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/tags/LeetCode/"},{"name":"Math","slug":"Math","permalink":"http://yoursite.com/tags/Math/"}]},{"title":"LeetCode 58: Length of Last Word","slug":"LeetCode-58-Length-of-Last-Word","date":"2016-08-05T10:23:40.000Z","updated":"2016-08-05T10:25:00.248Z","comments":true,"path":"2016/08/05/LeetCode-58-Length-of-Last-Word/","link":"","permalink":"http://yoursite.com/2016/08/05/LeetCode-58-Length-of-Last-Word/","excerpt":"Given a string s consists of upper/lower-case alphabets and empty space characters ‘ ‘, return the length of last word in the string.","text":"Given a string s consists of upper/lower-case alphabets and empty space characters ‘ ‘, return the length of last word in the string. If the last word does not exist, return 0.Note: A word is defined as a character sequence consists of non-space characters only. For example,Given s = &quot;Hello World&quot;,return 5. 代码C语言版本：12345678910111213141516171819int isChar(char p) &#123; return ('a'&lt;=p &amp;&amp; p&lt;='z')||('A'&lt;=p &amp;&amp; p&lt;='Z'); &#125; int lengthOfLastWord(char* s) &#123; int size = strlen(s); int begin; int end = size - 1; if (size &lt; 1) &#123; return 0; &#125; while(end &gt;= 0 &amp;&amp; s[end] == ' ') &#123; end--; &#125; begin = end; while ( begin &gt;= 0 &amp;&amp; isChar(s[begin])) &#123; begin--; &#125; return end - begin;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/tags/LeetCode/"},{"name":"String","slug":"String","permalink":"http://yoursite.com/tags/String/"}]},{"title":"LeetCode 13: Roman to Integer","slug":"LeetCode-13-Roman-to-Integer","date":"2016-08-05T09:34:44.000Z","updated":"2016-08-05T09:56:07.168Z","comments":true,"path":"2016/08/05/LeetCode-13-Roman-to-Integer/","link":"","permalink":"http://yoursite.com/2016/08/05/LeetCode-13-Roman-to-Integer/","excerpt":"Given a roman numeral, convert it to an integer.3999 / 3999 test cases passed.","text":"Given a roman numeral, convert it to an integer.3999 / 3999 test cases passed. 代码C语言版本：123456789101112131415161718192021222324int romanCharToInt(char c)&#123; switch (c) &#123; case 'I': return 1; case 'V': return 5; case 'X': return 10; case 'L': return 50; case 'C': return 100; case 'D': return 500; case 'M': return 1000; default: return 0; &#125;&#125;int romanToInt(char* s) &#123; int res = 0; int size = strlen(s); for (int i = 0; i &lt; size; i++) &#123; if (romanCharToInt(s[i]) &lt; romanCharToInt(s[i + 1]))&#123; res -= romanCharToInt(s[i]); &#125; else &#123; res += romanCharToInt(s[i]); &#125; &#125; return res;&#125; 3999 / 3999 test cases passed.Status: AcceptedRuntime: 24 msC++版本：123456789101112131415161718192021222324252627class Solution &#123;public: int romanToInt(string s) &#123; int num = 0; int size = s.size(); for (int i = 0; i &lt; size; i++) &#123; if (i &lt; (size - 1) &amp;&amp; romanCharToInt(s[i]) &lt; romanCharToInt(s[i + 1])) &#123; num -= romanCharToInt(s[i]); &#125; else &#123; num += romanCharToInt(s[i]); &#125; &#125; return num; &#125; int romanCharToInt(char c) &#123; switch (c) &#123; case 'I': return 1; case 'V': return 5; case 'X': return 10; case 'L': return 50; case 'C': return 100; case 'D': return 500; case 'M': return 1000; default: return 0; &#125; &#125;&#125;; 3999 / 3999 test cases passed.Status: AcceptedRuntime: 36 msjava版本：123456789101112131415161718192021222324252627282930public class Solution &#123; public int romanToInt(String s) &#123; //：Ⅰ（1）Ⅴ（5）Ⅹ（10）L（50）C（100）D（500）M（1000） // rules:位于大数的后面时就作为加数；位于大数的前面就作为减数 //eg：Ⅲ=3,Ⅳ=4,Ⅵ=6,ⅩⅨ=19,ⅩⅩ=20,ⅩLⅤ=45,MCMⅩⅩC=1980 //\"DCXXI\" if(s == null || s.length() == 0) return 0; int len = s.length(); HashMap&lt;Character,Integer&gt; map = new HashMap&lt;Character,Integer&gt;(); map.put('I',1); map.put('V',5); map.put('X',10); map.put('L',50); map.put('C',100); map.put('D',500); map.put('M',1000); int result = map.get(s.charAt(len -1)); int pivot = result; for(int i = len -2; i&gt;= 0;i--)&#123; int cur = map.get(s.charAt(i)); if(cur &gt;= pivot)&#123; result += cur; &#125;else&#123; result -= cur; &#125; pivot = cur; &#125; return result; &#125;&#125; 3999 / 3999 test cases passed.Status: AcceptedRuntime: 24 ms","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/tags/LeetCode/"},{"name":"String","slug":"String","permalink":"http://yoursite.com/tags/String/"}]},{"title":"LeetCode 344: Reverse String","slug":"LeetCode-344-Reverse-String","date":"2016-08-05T09:12:25.000Z","updated":"2016-08-05T09:18:56.336Z","comments":true,"path":"2016/08/05/LeetCode-344-Reverse-String/","link":"","permalink":"http://yoursite.com/2016/08/05/LeetCode-344-Reverse-String/","excerpt":"Write a function that takes a string as input and returns the string reversed. Example: Given s = &quot;hello&quot;, return &quot;olleh&quot;.","text":"Write a function that takes a string as input and returns the string reversed. Example: Given s = &quot;hello&quot;, return &quot;olleh&quot;. 代码C语言版本：12345678910111213char* reverseString(char* s) &#123; int left = 0; int right = strlen(s) - 1; while (left&lt;right)&#123; s[left] ^= s[right]; s[right] ^= s[left]; s[left] ^= s[right]; left++; right--; &#125; return s;&#125; 476 / 476 test cases passed.Status: AcceptedRuntime: 4 msC++版本：12345678910class Solution &#123;public: string reverseString(string s) &#123; int l = 0, r = s.size() - 1; while (l &lt; r)&#123; swap(s[l++], s[r--]); &#125; return s; &#125;&#125;; 476 / 476 test cases passed.Status: AcceptedRuntime: 12 ms","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/tags/LeetCode/"},{"name":"String","slug":"String","permalink":"http://yoursite.com/tags/String/"}]},{"title":"LeetCode 2: Add Two Numbers","slug":"LeetCode-2-Add-Two-Numbers","date":"2016-08-05T08:52:42.000Z","updated":"2016-08-05T08:56:47.608Z","comments":true,"path":"2016/08/05/LeetCode-2-Add-Two-Numbers/","link":"","permalink":"http://yoursite.com/2016/08/05/LeetCode-2-Add-Two-Numbers/","excerpt":"You are given two linked lists representing two non-negative numbers. The digits are stored in reverse order and each of their nodes contain a single digit.","text":"You are given two linked lists representing two non-negative numbers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list. Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)Output: 7 -&gt; 0 -&gt; 8 代码C语言版本：12345678910111213141516171819202122232425262728293031323334/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * struct ListNode *next; * &#125;; */struct ListNode* addTwoNumbers(struct ListNode* l1, struct ListNode* l2) &#123; struct ListNode* c1 = l1; struct ListNode* c2 = l2; struct ListNode* sentinel = (struct ListNode*)malloc(sizeof(struct ListNode)); struct ListNode* dummy = sentinel; int sum = 0; while ( c1 || c2) &#123; sum /= 10; if ( c1 )&#123; sum += c1 -&gt; val; c1 = c1 -&gt; next; &#125; if ( c2 )&#123; sum += c2 -&gt; val; c2 = c2 -&gt; next; &#125; dummy -&gt; next = (struct ListNode*)malloc(sizeof(struct ListNode)); dummy -&gt; next -&gt; val = sum % 10; dummy = dummy -&gt; next; &#125; if ( sum / 10 == 1 ) &#123; dummy -&gt; next = (struct ListNode*)malloc(sizeof(struct ListNode)); dummy -&gt; next -&gt; val = 1; &#125; return sentinel -&gt; next;&#125; C++版本：1234567891011121314151617181920212223/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) &#123; ListNode preheader(-1), *curr=&amp;preheader; int carry=0; while(l1 || l2 || carry) &#123; curr-&gt;next = new ListNode(((l1?l1-&gt;val:0)+(l2?l2-&gt;val:0)+carry)%10); curr = curr-&gt;next; carry = ((l1?l1-&gt;val:0)+(l2?l2-&gt;val:0)+carry)/10; l1?l1=l1-&gt;next:0; l2?l2=l2-&gt;next:0; &#125; return preheader.next; &#125;&#125;; 1558 / 1558 test cases passed.Status: AcceptedRuntime: 40 ms","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/tags/LeetCode/"},{"name":"Linked List","slug":"Linked-List","permalink":"http://yoursite.com/tags/Linked-List/"}]},{"title":"LeetCode 147: Insertion Sort List","slug":"LeetCode-147-Insertion-Sort-List","date":"2016-08-05T06:22:38.000Z","updated":"2016-08-05T06:24:14.239Z","comments":true,"path":"2016/08/05/LeetCode-147-Insertion-Sort-List/","link":"","permalink":"http://yoursite.com/2016/08/05/LeetCode-147-Insertion-Sort-List/","excerpt":"Sort a linked list using insertion sort.","text":"Sort a linked list using insertion sort. 代码C语言版本：1234567891011121314151617181920212223242526272829/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * struct ListNode *next; * &#125;; */struct ListNode* insertionSortList(struct ListNode* head) &#123; if ( !head ) &#123; return head; &#125; struct ListNode* helper; helper -&gt; next = NULL; struct ListNode* cur = head; struct ListNode* behind = NULL; struct ListNode* pre = helper; while ( cur ) &#123; behind = cur -&gt; next; while ( pre -&gt; next &amp;&amp; pre-&gt;next-&gt;val &lt; cur-&gt;val ) &#123; pre = pre -&gt; next; &#125; cur -&gt; next = pre -&gt; next; pre -&gt; next = cur; pre = helper; cur = behind; &#125; return helper -&gt; next;&#125; 21 / 21 test cases passed.Status: AcceptedRuntime: 64 ms","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/tags/LeetCode/"},{"name":"Linked List","slug":"Linked-List","permalink":"http://yoursite.com/tags/Linked-List/"}]},{"title":"LeetCode 86: Partition List","slug":"LeetCode-86-Partition-List","date":"2016-08-05T03:27:08.000Z","updated":"2016-08-05T03:29:19.485Z","comments":true,"path":"2016/08/05/LeetCode-86-Partition-List/","link":"","permalink":"http://yoursite.com/2016/08/05/LeetCode-86-Partition-List/","excerpt":"Given a linked list and a value x, partition it such that all nodes less than x come before nodes greater than or equal to x.","text":"Given a linked list and a value x, partition it such that all nodes less than x come before nodes greater than or equal to x.You should preserve the original relative order of the nodes in each of the two partitions.For example,Given 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;2 and x = 3,return 1-&gt;2-&gt;2-&gt;4-&gt;3-&gt;5. 代码C语言版本：12345678910111213141516171819202122232425262728293031/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * struct ListNode *next; * &#125;; */struct ListNode* partition(struct ListNode* head, int x) &#123; if ( !head ) &#123; return NULL; &#125; struct ListNode *smaller, *smallerHeader; smallerHeader -&gt; next = head; smaller = smallerHeader; struct ListNode *bigger, *biggerHeader; biggerHeader -&gt; next = head; bigger = biggerHeader; while ( head ) &#123; if ( head -&gt; val &lt; x ) &#123; smaller -&gt; next = head; smaller = head; &#125;else &#123; bigger -&gt; next = head; bigger = head; &#125; head = head -&gt; next; &#125; bigger -&gt; next = NULL; smaller -&gt; next = biggerHeader -&gt; next; return smallerHeader -&gt; next;&#125; 166 / 166 test cases passed.Status: AcceptedRuntime: 4 ms","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/tags/LeetCode/"},{"name":"Linked List","slug":"Linked-List","permalink":"http://yoursite.com/tags/Linked-List/"}]},{"title":"LeetCode 350: Intersection of Two Arrays II","slug":"LeetCode-350-Intersection-of-Two-Arrays-II","date":"2016-08-04T23:25:38.000Z","updated":"2016-08-04T23:28:32.643Z","comments":true,"path":"2016/08/05/LeetCode-350-Intersection-of-Two-Arrays-II/","link":"","permalink":"http://yoursite.com/2016/08/05/LeetCode-350-Intersection-of-Two-Arrays-II/","excerpt":"Given two arrays, write a function to compute their intersection. Example: Given nums1 = [1, 2, 2, 1], nums2 = [2, 2], return [2, 2].","text":"Given two arrays, write a function to compute their intersection. Example: Given nums1 = [1, 2, 2, 1], nums2 = [2, 2], return [2, 2]. Note: Each element in the result should appear as many times as it shows in both arrays. The result can be in any order. 思路代码C语言版本：1234567891011121314151617181920212223242526int cmp(const int* a, const int* b)&#123; return *a - *b;&#125;/** * Return an array of size *returnSize. * Note: The returned array must be malloced, assume caller calls free(). */int* intersect(int* nums1, int nums1Size, int* nums2, int nums2Size, int* returnSize) &#123; qsort(nums1, nums1Size, sizeof(int), cmp); qsort(nums2, nums2Size, sizeof(int), cmp); int i = 0, j = 0, k = 0; int* intersect = (int*)malloc(sizeof(int)*(nums1Size+nums2Size)); while ( i &lt; nums1Size &amp;&amp; j &lt; nums2Size ) &#123; if ( nums1[i] &lt; nums2[j]) &#123; i++; &#125;else if ( nums1[i] &gt; nums2[j] ) &#123; j++; &#125;else &#123; intersect[k++] = nums1[i]; i++; j++; &#125; &#125; *returnSize = k; return intersect;&#125; 60 / 60 test cases passed.Status: AcceptedRuntime: 4 ms","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/tags/LeetCode/"},{"name":"Linked List","slug":"Linked-List","permalink":"http://yoursite.com/tags/Linked-List/"}]},{"title":"LeetCode 328: Odd Even Linked List","slug":"LeetCode-328-Odd-Even-Linked-List","date":"2016-08-04T13:47:47.000Z","updated":"2016-08-04T14:34:11.923Z","comments":true,"path":"2016/08/04/LeetCode-328-Odd-Even-Linked-List/","link":"","permalink":"http://yoursite.com/2016/08/04/LeetCode-328-Odd-Even-Linked-List/","excerpt":"Given a singly linked list, group all odd nodes together followed by the even nodes. Please note here we are talking about the node number and not the value in the nodes.","text":"Given a singly linked list, group all odd nodes together followed by the even nodes. Please note here we are talking about the node number and not the value in the nodes. You should try to do it in place. The program should run in O(1) space complexity and O(nodes) time complexity. Example:Given 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL,return 1-&gt;3-&gt;5-&gt;2-&gt;4-&gt;NULL. Note:The relative order inside both the even and odd groups should remain as it was in the input.The first node is considered odd, the second node even and so on … 代码C语言版本：1234567891011121314151617181920212223242526272829/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * struct ListNode *next; * &#125;; */struct ListNode* oddEvenList(struct ListNode* head) &#123; if ( !head || !(head -&gt; next) )&#123; return head; &#125; struct ListNode* slow = head; struct ListNode* fast = head -&gt; next; struct ListNode* oddHead = head; struct ListNode* evenHead = head -&gt; next; while ( fast &amp;&amp; fast -&gt; next )&#123; slow -&gt; next = fast -&gt; next; slow = fast -&gt; next; if ( !slow -&gt; next )&#123; fast -&gt; next = NULL; break; &#125; fast -&gt; next = slow -&gt; next; fast = slow -&gt; next; &#125; slow -&gt; next = evenHead; return oddHead; &#125; 70 / 70 test cases passed.Status: AcceptedRuntime: 4 ms","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/tags/LeetCode/"},{"name":"Linked List","slug":"Linked-List","permalink":"http://yoursite.com/tags/Linked-List/"}]},{"title":"LeetCode 142: Linked List Cycle II","slug":"LeetCode-142-Linked-List-Cycle-II","date":"2016-08-04T04:49:05.000Z","updated":"2016-08-04T04:54:50.934Z","comments":true,"path":"2016/08/04/LeetCode-142-Linked-List-Cycle-II/","link":"","permalink":"http://yoursite.com/2016/08/04/LeetCode-142-Linked-List-Cycle-II/","excerpt":"Given a linked list, return the node where the cycle begins. If there is no cycle, return null. Note: Do not modify the linked list. Follow up: Can you solve it without using extra space?","text":"Given a linked list, return the node where the cycle begins. If there is no cycle, return null. Note: Do not modify the linked list. Follow up: Can you solve it without using extra space? 思路还是使用快慢指针的做法，先判断是否有环，没环的话直接返回null，否则在有环的情况下，在slow指针和fast指针第一次相遇处，让fast指针停下，slow继续前进，与此同时，一个从head开始的rHead指针也一起前进。最后rHead与slow指针相遇处就是环的开始之处。 代码C语言版本：12345678910111213141516171819202122232425262728/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * struct ListNode *next; * &#125;; */struct ListNode *detectCycle(struct ListNode *head) &#123; struct ListNode* fast = head; struct ListNode* slow = head; struct ListNode* rHead = head; while (fast &amp;&amp; fast -&gt; next) &#123; fast = fast -&gt; next -&gt; next; slow = slow -&gt; next; if (slow == fast)&#123; break; &#125; &#125; if ( !fast || !fast -&gt; next)&#123; return false; &#125; while ( slow != rHead)&#123; rHead = rHead -&gt; next; slow = slow -&gt; next; &#125; return rHead;&#125; 16 / 16 test cases passed.Status: AcceptedRuntime: 8 ms","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/tags/LeetCode/"},{"name":"Linked List","slug":"Linked-List","permalink":"http://yoursite.com/tags/Linked-List/"}]},{"title":"LeetCode 234: Palindrome Linked List","slug":"LeetCode-234-Palindrome-Linked-List","date":"2016-08-03T14:21:55.000Z","updated":"2016-08-03T14:24:52.044Z","comments":true,"path":"2016/08/03/LeetCode-234-Palindrome-Linked-List/","link":"","permalink":"http://yoursite.com/2016/08/03/LeetCode-234-Palindrome-Linked-List/","excerpt":"Given a singly linked list, determine if it is a palindrome. Follow up: Could you do it in O(n) time and O(1) space?","text":"Given a singly linked list, determine if it is a palindrome. Follow up: Could you do it in O(n) time and O(1) space? 思路这道题让我们判断一个链表是否为回文链表，LeetCode中关于回文串的题共有六道，除了这道，其他的五道为 Palindrome Number 验证回文数字， Validate Palindrome 验证回文字符串， Palindrome Partitioning 拆分回文串，Palindrome Partitioning II 拆分回文串之二 和 Longest Palindromic Substring 最长回文串.链表比字符串难的地方就在于不能通过坐标来直接访问，而只能从头开始遍历到某个位置。那么根据回文串的特点，我们需要比较对应位置的值是否相等，那么我们首先需要找到链表的中点，这个可以用快慢指针来实现，使用方法可以参见之前的两篇Convert Sorted List to Binary Search Tree 将有序链表转为二叉搜索树 和 Reorder List 链表重排序，我们使用快慢指针找中点的原理是fast和slow两个指针，每次快指针走两步，慢指针走一步，等快指针走完时，慢指针的位置就是中点。我们还需要用栈，每次慢指针走一步，都把值存入栈中，等到达中点时，链表的前半段都存入栈中了，由于栈的后进先出的性质，就可以和后半段链表按照回文对应的顺序比较了。 代码C语言版本：12345678910111213141516171819202122232425262728293031323334353637383940/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * struct ListNode *next; * &#125;; */struct ListNode* reverseList(struct ListNode* head) &#123; if (NULL == head)&#123; return head; &#125; struct ListNode *p = head; struct ListNode *pNext; p = head-&gt;next; head-&gt;next = NULL; while (p != NULL)&#123; pNext = p-&gt;next; p-&gt;next = head; head = p; p = pNext; &#125; return head;&#125;bool isPalindrome(struct ListNode* head) &#123; struct ListNode* fast = head; struct ListNode* slow = head; while ( fast != NULL &amp;&amp; fast-&gt;next != NULL) &#123; slow = slow -&gt; next; fast = fast -&gt; next -&gt; next; &#125; ///reverse the bottom half list struct ListNode* rHead = reverseList(slow); while(head != NULL &amp;&amp; rHead != NULL)&#123; if(head-&gt;val != rHead-&gt;val) return false; head = head-&gt;next; rHead = rHead-&gt;next; &#125; return true;&#125; 22 / 22 test cases passed.Status: AcceptedRuntime: 12 ms","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/tags/LeetCode/"},{"name":"Linked List","slug":"Linked-List","permalink":"http://yoursite.com/tags/Linked-List/"}]},{"title":"LeetCode 83: Remove Duplicates from Sorted List","slug":"LeetCode-83-Remove-Duplicates-from-Sorted-List","date":"2016-08-03T13:46:45.000Z","updated":"2016-08-03T13:49:34.684Z","comments":true,"path":"2016/08/03/LeetCode-83-Remove-Duplicates-from-Sorted-List/","link":"","permalink":"http://yoursite.com/2016/08/03/LeetCode-83-Remove-Duplicates-from-Sorted-List/","excerpt":"Given a sorted linked list, delete all duplicates such that each element appear only once. For example, Given 1-&gt;1-&gt;2, return 1-&gt;2.Given 1-&gt;1-&gt;2-&gt;3-&gt;3, return 1-&gt;2-&gt;3.","text":"Given a sorted linked list, delete all duplicates such that each element appear only once. For example, Given 1-&gt;1-&gt;2, return 1-&gt;2.Given 1-&gt;1-&gt;2-&gt;3-&gt;3, return 1-&gt;2-&gt;3. 思路由于链表已经排好序，所以直接循环查找重复的节点，没什么好说的，比较简单。 代码C语言版本：1234567891011121314151617181920212223/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * struct ListNode *next; * &#125;; */struct ListNode* deleteDuplicates(struct ListNode* head) &#123; struct ListNode* p = head; if ( head )&#123; while ( p -&gt; next )&#123; if (p -&gt; val != p -&gt; next -&gt; val )&#123; p = p -&gt; next; &#125;else&#123; struct ListNode* tmp = p -&gt; next; p -&gt; next = p -&gt; next -&gt; next; free( tmp ); &#125; &#125; &#125; return head;&#125; 164 / 164 test cases passed.Status: AcceptedRuntime: 4 ms","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/tags/LeetCode/"},{"name":"Linked List","slug":"Linked-List","permalink":"http://yoursite.com/tags/Linked-List/"}]},{"title":"LeetCode 141: Linked List Cycle","slug":"LeetCode-141-Linked-List-Cycle","date":"2016-08-03T13:15:18.000Z","updated":"2016-08-03T14:04:32.004Z","comments":true,"path":"2016/08/03/LeetCode-141-Linked-List-Cycle/","link":"","permalink":"http://yoursite.com/2016/08/03/LeetCode-141-Linked-List-Cycle/","excerpt":"Given a linked list, determine if it has a cycle in it. Follow up: Can you solve it without using extra space?","text":"Given a linked list, determine if it has a cycle in it. Follow up: Can you solve it without using extra space? 思路设两个指针即快慢指针，只要是一个环，那么跑得快的总能追上跑得慢的。 代码C语言版本：12345678910111213141516171819202122/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * struct ListNode *next; * &#125;; */bool hasCycle(struct ListNode *head) &#123; struct ListNode* fast = head; struct ListNode* slow = head; while ( fast &amp;&amp; fast -&gt; next )&#123; fast = fast -&gt; next -&gt; next; slow = slow -&gt; next; if (fast == slow)&#123; return true; &#125; &#125; return false;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/tags/LeetCode/"},{"name":"Linked List","slug":"Linked-List","permalink":"http://yoursite.com/tags/Linked-List/"}]},{"title":"LeetCode 19: Remove Nth Node From End of List","slug":"LeetCode-19-Remove-Nth-Node-From-End-of-List","date":"2016-08-03T10:35:26.000Z","updated":"2016-08-03T10:37:59.938Z","comments":true,"path":"2016/08/03/LeetCode-19-Remove-Nth-Node-From-End-of-List/","link":"","permalink":"http://yoursite.com/2016/08/03/LeetCode-19-Remove-Nth-Node-From-End-of-List/","excerpt":"Given a linked list, remove the nth node from the end of list and return its head. For example,Given linked list: 1-&gt;2-&gt;3-&gt;4-&gt;5, and n = 2.","text":"Given a linked list, remove the nth node from the end of list and return its head. For example,Given linked list: 1-&gt;2-&gt;3-&gt;4-&gt;5, and n = 2.After removing the second node from the end, the linked list becomes 1-&gt;2-&gt;3-&gt;5.Note:Given n will always be valid.Try to do this in one pass. 思路两个指针，当一个指向末尾时，另一个恰好指向要删除节点的前一个节点处。 代码C语言版本：12345678910111213141516171819202122232425/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * struct ListNode *next; * &#125;; */struct ListNode* removeNthFromEnd(struct ListNode* head, int n) &#123; struct ListNode* front = head; struct ListNode* behind = head; while ( front )&#123; front = front -&gt; next; if ( n-- &lt; 0 )&#123; behind = behind-&gt;next; &#125; &#125; if (n == 0) &#123; head = head-&gt;next; &#125;else &#123; behind-&gt;next = behind-&gt;next-&gt;next; &#125; return head;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/tags/LeetCode/"},{"name":"Linked List","slug":"Linked-List","permalink":"http://yoursite.com/tags/Linked-List/"}]},{"title":"LeetCode 160: Intersection of Two Linked Lists","slug":"LeetCode-160-Intersection-of-Two-Linked-Lists","date":"2016-08-03T03:26:12.000Z","updated":"2016-08-03T06:15:12.439Z","comments":true,"path":"2016/08/03/LeetCode-160-Intersection-of-Two-Linked-Lists/","link":"","permalink":"http://yoursite.com/2016/08/03/LeetCode-160-Intersection-of-Two-Linked-Lists/","excerpt":"Write a program to find the node at which the intersection of two singly linked lists begins.For example, the following two linked lists:","text":"Write a program to find the node at which the intersection of two singly linked lists begins.For example, the following two linked lists:123456A: a1 → a2 ↘ c1 → c2 → c3 ↗ B: b1 → b2 → b3begin to intersect at node c1. Notes: If the two linked lists have no intersection at all, return null. The linked lists must retain their original structure after the function returns. You may assume there are no cycles anywhere in the entire linked structure. Your code should preferably run in O(n) time and use only O(1) memory. 代码C语言版本：123456789101112131415161718192021222324252627282930313233343536373839404142434445/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * struct ListNode *next; * &#125;; */struct ListNode *getIntersectionNode(struct ListNode *headA, struct ListNode *headB) &#123; struct ListNode *LA, *LB; struct ListNode *h1, *h2; int lenA=0, lenB=0, step=0; if(!headA || !headB) return NULL; LA = headA; LB = headB; while(LA)&#123; lenA++; LA = LA-&gt;next; &#125; while(LB)&#123; lenB++; LB = LB-&gt;next; &#125; if(lenA &gt;= lenB&#123; step = lenA - lenB; h1 = headA; h2 = headB; &#125;else&#123; step = lenB - lenA; h1 = headB; h2 = headA; &#125; while(h1 &amp;&amp; step)&#123; step--; h1 = h1-&gt;next; &#125; while(h1 &amp;&amp; h2)&#123; if(h1-&gt;val == h2-&gt;val) return h1; h1 = h1-&gt;next; h2 = h2-&gt;next; &#125; return NULL;&#125; 42 / 42 test cases passed.Status: AcceptedRuntime: 32 ms","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/tags/LeetCode/"},{"name":"Linked List","slug":"Linked-List","permalink":"http://yoursite.com/tags/Linked-List/"}]},{"title":"LeetCode 203: Remove Linked List Elements","slug":"LeetCode-203-Remove-Linked-List-Elements","date":"2016-08-02T14:58:14.000Z","updated":"2016-08-03T02:03:57.765Z","comments":true,"path":"2016/08/02/LeetCode-203-Remove-Linked-List-Elements/","link":"","permalink":"http://yoursite.com/2016/08/02/LeetCode-203-Remove-Linked-List-Elements/","excerpt":"Remove all elements from a linked list of integers that have value val. Example Given: 1 --&gt; 2 --&gt; 6 --&gt; 3 --&gt; 4 --&gt; 5 --&gt; 6, val = 6. Return: 1 --&gt; 2 --&gt; 3 --&gt; 4 --&gt; 5.","text":"Remove all elements from a linked list of integers that have value val. Example Given: 1 --&gt; 2 --&gt; 6 --&gt; 3 --&gt; 4 --&gt; 5 --&gt; 6, val = 6. Return: 1 --&gt; 2 --&gt; 3 --&gt; 4 --&gt; 5. 思路两个指针, 一样的就删, 不一样就next. 代码C语言版本：1234567891011121314151617181920212223/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * struct ListNode *next; * &#125;; */struct ListNode* removeElements(struct ListNode* head, int val) &#123; struct ListNode* dummy; dummy -&gt; next = head; struct ListNode* p = dummy; struct ListNode* q = head; while(q != NULL) &#123; if(q-&gt;val == val) &#123; p-&gt;next = q-&gt;next; &#125; else &#123; p = p-&gt;next; &#125; q = q-&gt;next; &#125; return dummy-&gt;next; &#125; 63 / 63 test cases passed.Status: AcceptedRuntime: 12 ms 12345678st=&gt;start: Starte=&gt;endop=&gt;operation: My Operationcond=&gt;condition: Yes or No?st-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op 123Alice-&gt;Bob: Hello Bob, how are you?Note right of Bob: Bob thinksBob--&gt;Alice: I am good thanks!","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/tags/LeetCode/"},{"name":"Linked List","slug":"Linked-List","permalink":"http://yoursite.com/tags/Linked-List/"}]},{"title":"LeetCode 371: Sum of Two integers","slug":"LeetCode-371-Sum-of-Two-integers","date":"2016-08-02T10:43:25.000Z","updated":"2016-08-02T11:00:20.352Z","comments":true,"path":"2016/08/02/LeetCode-371-Sum-of-Two-integers/","link":"","permalink":"http://yoursite.com/2016/08/02/LeetCode-371-Sum-of-Two-integers/","excerpt":"Calculate the sum of two integers a and b, but you are not allowed to use the operator + and -.Example: Given a = 1 and b = 2, return 3.","text":"Calculate the sum of two integers a and b, but you are not allowed to use the operator + and -.Example: Given a = 1 and b = 2, return 3. 题意计算a和b的和，但是不能使用+和-号。 思路这里要求我们不能用加法、减法等运算符来实现加法运算。这里应该使用位运算来实现加法运算，实际上，这也是计算机CPU内部实现加法运算的方案。x ^ y真值表: x y x^y 0 0 0 0 1 1 1 0 1 1 1 0 x &amp; y真值表: x y x&amp;y 0 0 0 0 1 0 1 0 0 1 1 1 我们可以基于以上的真值表用&amp;和^运算来实现加法，每一位的^运算得到每一位上的不加进位的和，用&amp;运算得到每一位的进位。 代码C语言版本：1234567891011int getSum(int a, int b) &#123; int sum = a; int carry = b; int tmp; while ( carry )&#123; tmp = sum; sum = sum ^ carry; carry = (carry &amp; tmp) &lt;&lt; 1; &#125; return sum;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/tags/LeetCode/"},{"name":"Bit Manupulation","slug":"Bit-Manupulation","permalink":"http://yoursite.com/tags/Bit-Manupulation/"}]},{"title":"LeetCode 24: Swap Nodes in Pairs","slug":"LeetCode-24-Swap-Nodes-in-Pairs","date":"2016-08-02T09:17:28.000Z","updated":"2016-08-02T09:22:49.264Z","comments":true,"path":"2016/08/02/LeetCode-24-Swap-Nodes-in-Pairs/","link":"","permalink":"http://yoursite.com/2016/08/02/LeetCode-24-Swap-Nodes-in-Pairs/","excerpt":"Given a linked list, swap every two adjacent nodes and return its head. For example, Given 1-&gt;2-&gt;3-&gt;4, you should return the list as 2-&gt;1-&gt;4-&gt;3.","text":"Given a linked list, swap every two adjacent nodes and return its head. For example, Given 1-&gt;2-&gt;3-&gt;4, you should return the list as 2-&gt;1-&gt;4-&gt;3.Your algorithm should use only constant space. You may not modify the values in the list, only nodes itself can be changed. 题意考虑一个单链表， 交换每两个相邻的节点并返回头节点。比如，给出1-&gt;2-&gt;3-&gt;4，你应该返回2-&gt;1-&gt;4-&gt;3。 思路题目意思是给定一个单链表，交换两个相邻的节点。我的做法是先找到新链表的头结点，然后像交换两个变量的值的方式，来交换两个相邻的节点，这里需要注意的是，交换的时候，需要保存交换节点的前后节点，这里我用left、right去保存，为了交换之后，前后节点不丢失。 代码C语言版本：12345678910111213141516171819202122232425262728293031323334353637383940/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * struct ListNode *next; * &#125;; */struct ListNode* swapPairs(struct ListNode* head) &#123; struct ListNode *p, *q, *right, *left; struct ListNode * ret; if(!head || !head-&gt;next) return head; p = head; q = p-&gt;next; if(p &amp;&amp; q) ret = q; while(p &amp;&amp; q) &#123; right = q-&gt;next; q-&gt;next = p; left = p; p-&gt;next = right; p = right; if(!right || !right-&gt;next) break; if(right-&gt;next) &#123; q = p-&gt;next; left-&gt;next = q; &#125; &#125; return ret;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/tags/LeetCode/"},{"name":"Linked List","slug":"Linked-List","permalink":"http://yoursite.com/tags/Linked-List/"}]},{"title":"LeetCode 21: Merge Two Sorted Lists","slug":"LeetCode-21-Merge-Two-Sorted-Lists","date":"2016-08-02T02:45:27.000Z","updated":"2016-08-02T02:49:29.549Z","comments":true,"path":"2016/08/02/LeetCode-21-Merge-Two-Sorted-Lists/","link":"","permalink":"http://yoursite.com/2016/08/02/LeetCode-21-Merge-Two-Sorted-Lists/","excerpt":"Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists.","text":"Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists. 题意融合两个已经排好序的链表，并返回一个新表。 思路先找到表头，然后做个循环不断排序下去即可。 代码C语言版本：1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * struct ListNode *next; * &#125;; */struct ListNode* mergeTwoLists(struct ListNode* l1, struct ListNode* l2) &#123; if (l1 == NULL)&#123; return l2; &#125; if (l2 == NULL)&#123; return l1; &#125; struct ListNode* head = NULL; // find the first element if (l1-&gt;val &lt; l2-&gt;val)&#123; head = l1; l1 = l1-&gt;next; &#125;else&#123; head = l2; l2 = l2-&gt;next; &#125; struct ListNode* p = head; while(l1&amp;&amp;l2)&#123; if (l1-&gt;val &lt; l2-&gt;val)&#123; p-&gt;next = l1; l1 = l1-&gt;next; &#125;else&#123; p-&gt;next = l2; l2 = l2-&gt;next; &#125; p = p-&gt;next; &#125; if(l1)&#123; p-&gt;next=l1; &#125;else&#123; p-&gt;next=l2; &#125; return head;&#125; 结果：208 / 208 test cases passed.Status: AcceptedRuntime: 4 ms","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/tags/LeetCode/"},{"name":"Linked List","slug":"Linked-List","permalink":"http://yoursite.com/tags/Linked-List/"}]},{"title":"LeetCode 206: Reverse Linked List","slug":"LeetCode-206-Reverse-Linked-List","date":"2016-08-02T00:30:43.000Z","updated":"2016-08-02T00:36:18.089Z","comments":true,"path":"2016/08/02/LeetCode-206-Reverse-Linked-List/","link":"","permalink":"http://yoursite.com/2016/08/02/LeetCode-206-Reverse-Linked-List/","excerpt":"Reverse a singly linked list.Hint: A linked list can be reversed either iteratively or recursively. Could you implement both?","text":"Reverse a singly linked list.Hint: A linked list can be reversed either iteratively or recursively. Could you implement both? 题意翻转该单链表 思路使用迭代法或者递归法皆可实现。 代码C语言版本：iteratively(迭代方法)12345678910111213141516171819202122/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * struct ListNode *next; * &#125;; */struct ListNode* reverseList(struct ListNode* head) &#123; if (NULL == head)&#123; return head; &#125; struct ListNode *p = head; p = head-&gt;next; head-&gt;next = NULL; while (p != NULL)&#123; struct ListNode *pNext = p-&gt;next; p-&gt;next = head; head = p; p = pNext; &#125; return head;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/tags/LeetCode/"},{"name":"Linked List","slug":"Linked-List","permalink":"http://yoursite.com/tags/Linked-List/"}]},{"title":"LeetCode 136: Single Number","slug":"LeetCode-136-Single-Number","date":"2016-08-01T15:43:43.000Z","updated":"2016-08-02T00:32:47.031Z","comments":true,"path":"2016/08/01/LeetCode-136-Single-Number/","link":"","permalink":"http://yoursite.com/2016/08/01/LeetCode-136-Single-Number/","excerpt":"Given an array of integers, every element appears twice except for one. Find that single one.","text":"Given an array of integers, every element appears twice except for one. Find that single one. Note:Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory? 题意考虑一个整数数组， 除了一个整数外其他整数都出现了两次，请把这个整数找出来。 思路我们知道两个相同的整数异或会为0，而0跟任何整数异或等于该整数。所以只要把数组的整数不断取出并异或，最后的结果就是那个值。 代码C语言版本：1234567int singleNumber(int* nums, int numsSize) &#123; int res = 0; for (int i = 0; i &lt; numsSize; i++)&#123; res ^= nums[i]; &#125; return res;&#125; 结果：15 / 15 test cases passed.Status: AcceptedRuntime: 8 ms","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/tags/LeetCode/"},{"name":"Bit Manupulation","slug":"Bit-Manupulation","permalink":"http://yoursite.com/tags/Bit-Manupulation/"}]},{"title":"51NOD 1005: 排序","slug":"51NOD-1005-排序","date":"2016-07-31T16:31:39.000Z","updated":"2016-07-31T16:36:51.004Z","comments":true,"path":"2016/08/01/51NOD-1005-排序/","link":"","permalink":"http://yoursite.com/2016/08/01/51NOD-1005-排序/","excerpt":"题目描述：给出N个整数，对着N个整数进行排序。","text":"题目描述：给出N个整数，对着N个整数进行排序。 input第1行：整数的数量N（1 &lt;= N &lt;= 50000)第2 - N + 1行：待排序的整数（-10^9 &lt;= A[i] &lt;= 10^9） output共n行，按照递增序输出排序好的数据。 input示例554321 output示例1234512345678910111213141516171819202122#include &lt;stdio.h&gt;int cmp(const int* a, const int* b)&#123; return *a - *b;&#125;int main()&#123; int numsSize, nums[50000]; scanf(\"%d\", &amp;numsSize); for(int i=0; i&lt;numsSize; i++) &#123; scanf(\"%d\", &amp;nums[i]); &#125; qsort(nums, numsSize, sizeof(int), cmp); for(int i=0; i&lt;numsSize; i++) &#123; printf(\"%d\\n\", nums[i]); &#125; return 0;&#125;","categories":[{"name":"51NOD","slug":"51NOD","permalink":"http://yoursite.com/categories/51NOD/"}],"tags":[{"name":"51NOD","slug":"51NOD","permalink":"http://yoursite.com/tags/51NOD/"}]},{"title":"贪心算法入门","slug":"贪心算法入门","date":"2016-07-31T16:10:35.000Z","updated":"2016-07-31T16:14:27.492Z","comments":true,"path":"2016/08/01/贪心算法入门/","link":"","permalink":"http://yoursite.com/2016/08/01/贪心算法入门/","excerpt":"","text":"123456789101112131415161718192021222324252627#include&lt;stdio.h&gt;#include&lt;string.h&gt;int cmp(const char* a, const char* b)&#123; return *a - *b;&#125;int main()&#123; char str[100]; scanf(\"%s\", str); int strSize; strSize = strlen(str); qsort(str, strSize, sizeof(char), cmp); int res = 26; int maxValue = 26; for (int i = strSize - 1; i &gt;= 1; i--) &#123; if (str[i] != str[i - 1]) &#123; maxValue--; &#125; res += maxValue; &#125; printf(\"%d\", res);&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/categories/算法/"}],"tags":[{"name":"贪心算法","slug":"贪心算法","permalink":"http://yoursite.com/tags/贪心算法/"}]},{"title":"LeetCode 229: Majority Element II","slug":"LeetCode-229-Majority-Element-II","date":"2016-07-31T14:29:46.000Z","updated":"2016-08-02T00:32:08.475Z","comments":true,"path":"2016/07/31/LeetCode-229-Majority-Element-II/","link":"","permalink":"http://yoursite.com/2016/07/31/LeetCode-229-Majority-Element-II/","excerpt":"Given an integer array of size n, find all elements that appear more than ⌊ n/3 ⌋ times. The algorithm should run in linear time and in O(1) space.","text":"Given an integer array of size n, find all elements that appear more than ⌊ n/3 ⌋ times. The algorithm should run in linear time and in O(1) space.Hint: How many majority elements could it possibly have? Do you have a better hint? Suggest it! 题意思路这道题让我们求出现次数大于n/3的众数，而且限定了时间和空间复杂度，那么就不能排序，也不能使用哈希表，这么苛刻的限制条件只有一种方法能解了，那就是摩尔投票法 Moore Voting，这种方法在之前那道题Majority Element 求众数中也使用了。题目中给了一条很重要的提示，让我们先考虑可能会有多少个众数。那么有了这个信息，我们使用投票法的核心是找出两个候选众数进行投票，需要两遍遍历，第一遍历找出两个候选众数，第二遍遍历重新投票验证这两个候选众数是否为众数即可，选候选众数方法和前面那篇Majority Element 求众数一样，由于之前那题题目中限定了一定会有众数存在，故而省略了验证候选众数的步骤，这道题却没有这种限定，即满足要求的众数可能不存在，所以要有验证。代码如下： 代码C语言版本：123456789101112131415161718192021222324252627282930313233343536373839404142/** * Return an array of size *returnSize. * Note: The returned array must be malloced, assume caller calls free(). */int* majorityElement(int* nums, int numsSize, int* returnSize) &#123; int* res = (int*)malloc(sizeof(int)*numsSize); int firstNum = 0, secondNum = 0, countFN = 0, countSN = 0; for(int i=0; i&lt;numsSize; i++)&#123; if (nums[i] == firstNum)&#123; countFN++; &#125;else if (nums[i] == secondNum)&#123; countSN++; &#125;else if (countFN == 0)&#123; firstNum = nums[i]; countFN = 1; &#125;else if (countSN == 0)&#123; secondNum = nums[i]; countSN = 1; &#125;else&#123; countFN--; countSN--; &#125; &#125; countFN = countSN = 0; for (int i=0; i&lt;numsSize; i++) &#123; if (nums[i] == firstNum)&#123; ++countFN; &#125; else if (nums[i] == secondNum)&#123; ++countSN; &#125; &#125; if (countFN &gt; numsSize/3)&#123; res[0] = firstNum; &#125; if (countSN &gt; numsSize/3)&#123; res[1] = secondNum; &#125; *returnSize = numsSize; return res; &#125; C++版本：12345678910111213141516171819202122class Solution &#123;public: vector&lt;int&gt; majorityElement(vector&lt;int&gt;&amp; nums) &#123; vector&lt;int&gt; res; int m = 0, n = 0, cm = 0, cn = 0; for (auto &amp;a : nums) &#123; if (a == m) ++cm; else if (a ==n) ++cn; else if (cm == 0) m = a, cm = 1; else if (cn == 0) n = a, cn = 1; else --cm, --cn; &#125; cm = cn = 0; for (auto &amp;a : nums) &#123; if (a == m) ++cm; else if (a == n) ++cn; &#125; if (cm &gt; nums.size() / 3) res.push_back(m); if (cn &gt; nums.size() / 3) res.push_back(n); return res; &#125;&#125;;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/tags/LeetCode/"},{"name":"Array","slug":"Array","permalink":"http://yoursite.com/tags/Array/"}]},{"title":"LeetCode 169 Majority Element","slug":"LeetCode-169-Majority-Element","date":"2016-07-31T13:40:08.000Z","updated":"2016-08-03T08:17:54.905Z","comments":true,"path":"2016/07/31/LeetCode-169-Majority-Element/","link":"","permalink":"http://yoursite.com/2016/07/31/LeetCode-169-Majority-Element/","excerpt":"Given an array of size n, find the majority element. The majority element is the element that appears more than n/2 times.","text":"Given an array of size n, find the majority element. The majority element is the element that appears more than n/2 times.You may assume that the array is non-empty and the majority element always exist in the array. 题意代码C语言版本：1234567891011121314int majorityElement(int* nums, int numsSize) &#123; int major=nums[0], count = 1; for(int i=1; i&lt;numsSize;i++)&#123; if(count==0)&#123; count++; major=nums[i]; &#125;else if(major==nums[i])&#123; count++; &#125;else&#123; count--; &#125; &#125; return major;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/tags/LeetCode/"},{"name":"Array","slug":"Array","permalink":"http://yoursite.com/tags/Array/"}]},{"title":"LeetCode 238: Product of Array Except Self","slug":"LeetCode-238-Product-of-Array-Except-Self","date":"2016-07-31T13:28:39.000Z","updated":"2016-08-03T08:18:02.665Z","comments":true,"path":"2016/07/31/LeetCode-238-Product-of-Array-Except-Self/","link":"","permalink":"http://yoursite.com/2016/07/31/LeetCode-238-Product-of-Array-Except-Self/","excerpt":"Given an array of n integers where n &gt; 1, nums, return an array output such that output[i] is equal to the product of all the elements of nums except nums[i].","text":"Given an array of n integers where n &gt; 1, nums, return an array output such that output[i] is equal to the product of all the elements of nums except nums[i].Solve it without division and in O(n).For example, given [1,2,3,4], return [24,12,8,6]. 题意代码1234567891011121314151617/** * Return an array of size *returnSize. * Note: The returned array must be malloced, assume caller calls free(). */int* productExceptSelf(int* nums, int numsSize, int* returnSize) &#123; int* res = (int*)malloc(sizeof(int)*numsSize); //the result array; for (int i = 0, tmp = 1; i &lt; numsSize; i++) &#123; res[i] = tmp; tmp *= nums[i]; &#125; for (int i = numsSize - 1, tmp = 1; i &gt;= 0; i--) &#123; res[i] *= tmp; tmp *= nums[i]; &#125; *returnSize = numsSize; return res;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/tags/LeetCode/"},{"name":"Array","slug":"Array","permalink":"http://yoursite.com/tags/Array/"}]},{"title":"异或^的妙用","slug":"异或-的妙用","date":"2016-07-31T08:33:10.000Z","updated":"2016-07-31T10:15:51.434Z","comments":true,"path":"2016/07/31/异或-的妙用/","link":"","permalink":"http://yoursite.com/2016/07/31/异或-的妙用/","excerpt":"最近在做一些算法题的时候，发现了异或很好使，经常有一些很妙的点子是通过它来实现的。所以特别在这里记录一下","text":"最近在做一些算法题的时候，发现了异或很好使，经常有一些很妙的点子是通过它来实现的。所以特别在这里记录一下，方便下次使用与学习。 两数交换如果不用这三个参数就实现两数的交换的话，可以使用异或^来实现,代码如下：123456void swap(int &amp;a,int &amp;b) //通过异或交换两者的值&#123; a =a^b; b= a^b; a = b^a;&#125; 找出0, 1, 2, …, n序列中缺了哪个数这是LeetCode 268 Missing Number的题，代码如下:1234567int missingNumber(int* nums, int numsSize) &#123; int res = numsSize; for(int i = 0; i &lt; numsSize; i++)&#123; res ^= i ^ nums[i]; &#125; return res;&#125; 暂时只有这两个妙处，下次还有的话，再添加。","categories":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/categories/算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"}]},{"title":"LeetCode 268: Missing Number","slug":"Leetcode-268-Missing-Number-C语言","date":"2016-07-31T07:55:31.000Z","updated":"2016-08-03T08:18:09.353Z","comments":true,"path":"2016/07/31/Leetcode-268-Missing-Number-C语言/","link":"","permalink":"http://yoursite.com/2016/07/31/Leetcode-268-Missing-Number-C语言/","excerpt":"Given an array containing n distinct numbers taken from 0, 1, 2, …, n, find the one that is missing from the array.","text":"Given an array containing n distinct numbers taken from 0, 1, 2, …, n, find the one that is missing from the array.For example,Given nums = [0, 1, 3] return 2.Note: Your algorithm should run in linear runtime complexity. Could you implement it using only constant extra space complexity? 题意考虑一个包含n个不同数字的数组，以0, 1, 2, …, n,的顺序排列，找到一个数组中缺失的数字。比如，nums = [0, 1, 3]则返回2。 程序以我这渣渣水平，一看到题目就想到了一个很渣的算法，如下：123456789101112131415161718192021222324int cmp(const int* a, const int* b)&#123; return *a - *b;&#125;int missingNumber(int* nums, int numsSize) &#123; int left = 0; int right = 1; int flag = 0; qsort(nums, numsSize, sizeof(int), cmp); if (numsSize == 1)&#123; return nums[0]?0:1; &#125; while (right&lt;numsSize)&#123; if ( (nums[right]-nums[left]) != 1 )&#123; flag++; return nums[right]-1; &#125; left++; right++; &#125; if (!flag)&#123; return nums[0]?0:(nums[numsSize-1]+1); &#125; return false;&#125; 结果可以想象得到：121 / 121 test cases passed.Status: AcceptedRuntime: 28 ms看了一下，结果果然很渣，打败了4.37%的人。后来上网学习到了一种很吊的：1234567int missingNumber(int* nums, int numsSize) &#123; int res = numsSize; for(int i = 0; i &lt; numsSize; i++)&#123; res ^= i ^ nums[i]; &#125; return res;&#125; 结果很感人：121 / 121 test cases passed.Status: AcceptedRuntime: 12 ms","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/tags/LeetCode/"},{"name":"Array","slug":"Array","permalink":"http://yoursite.com/tags/Array/"}]},{"title":"hexo主题中使用mathjax来支持LaTex公式","slug":"hexo主题中使用mathjax来支持latex公式","date":"2016-07-31T05:19:44.000Z","updated":"2016-07-31T06:42:08.750Z","comments":true,"path":"2016/07/31/hexo主题中使用mathjax来支持latex公式/","link":"","permalink":"http://yoursite.com/2016/07/31/hexo主题中使用mathjax来支持latex公式/","excerpt":"今天发现在要写很多公式时，页面显示会有点乱。或者要表达一些复杂的符号时，发现不知道怎么写出来。","text":"今天发现在要写很多公式时，页面显示会有点乱。或者要表达一些复杂的符号时，发现不知道怎么写出来。后来上网查了一下发现有mathjax这个东西，实在好用。 使用步骤因为mathjax这个js文件每次加载都有点慢，而且很多时候并用不到这个插件，所以我们的策略是按是否需要使用为前提而加载。而且如果哪天我们都不需要mathjax了，我们还要加上全局的控制的功能。所以为了实现上面的功能，我们需要修改几个文件。 主题的_config.yml文件在主题文件夹下的_config.yml中加入下面的代码，为了实现全局的控制，这里加上enable: true, false的话就会全站禁止了12345678# ---------------------------------------------------------------# Third Party Services Settings # ---------------------------------------------------------------# MathJax Supportmathjax: enable: true cdn: http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML 上面的cdn觉得慢的话，可以自己找一个。 按文章加载在文章需要调用 Mathjax 时, 只需在 front-matter 前加上 mathjax: true 即可, 即12345678---title: hexo主题中使用mathjax来支持LaTex公式date: 2016-07-31 13:19:44tags: [LaTex, hexo]categories: hexothumbnail: http://7xveyh.com1.z0.glb.clouddn.com/latex_latin_symbols.jpgmathjax: true--- 加载mathjax文件有了上面的修改，这时候就可以按需要加载mathjax脚本文件了。我主题加载js文件都是在script.ejs中判断后加载的(你们可以根据自己的情况来处理)，所以这里加上下面这段代码：123&lt;% if (page.mathjax)&#123; %&gt; &lt;%- partial(&apos;plugin/mathjax&apos;) %&gt;&lt;% &#125; %&gt; 上面代码说明如果mardkown文件中写了上面说的mathjax: ture，那么if条件为ture，则加载plugin/mathjax mathjax.ejs文件123456789101112131415161718192021&lt;% if (theme.mathjax.enable)&#123; %&gt; &lt;script type=\"text/x-mathjax-config\"&gt; MathJax.Hub.Config(&#123; tex2jax: &#123; inlineMath: [ ['$','$'], [\"\\\\(\",\"\\\\)\"] ], processEscapes: true, skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'] &#125; &#125;); &lt;/script&gt; &lt;script type=\"text/x-mathjax-config\"&gt; MathJax.Hub.Queue(function() &#123; var all = MathJax.Hub.getAllJax(), i; for (i=0; i &lt; all.length; i += 1) &#123; all[i].SourceElement().parentNode.className += ' has-jax'; &#125; &#125;); &lt;/script&gt; &lt;script type=\"text/javascript\" src=\"&lt;%= theme.mathjax.cdn %&gt;\"&gt;&lt;/script&gt;&lt;% &#125; %&gt; 可以看到代码中的theme.mathjax.cdn就是主题配置文件中的mathjax下的cdn啦。 说明我的主题使用的是ejs模板语言写的，如果是swig或者其他语言，还要稍微修改一下，具体怎么改可以上网搜索一下。下面放张效果图：","categories":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/categories/hexo/"}],"tags":[{"name":"LaTex","slug":"LaTex","permalink":"http://yoursite.com/tags/LaTex/"},{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"}]},{"title":"归并排序","slug":"归并排序","date":"2016-07-31T03:06:33.000Z","updated":"2016-07-31T06:01:29.389Z","comments":true,"path":"2016/07/31/归并排序/","link":"","permalink":"http://yoursite.com/2016/07/31/归并排序/","excerpt":"归并排序以O(NlogN)最坏情形运行时间运行，而所使用的比较次数几乎是最优的。它是递归算法一个很好的实例。","text":"归并排序以O(NlogN)最坏情形运行时间运行，而所使用的比较次数几乎是最优的。它是递归算法一个很好的实例。这个算法中基本的操作是合并两个已排序的表。因为这两个表是已排序的，所以若将输出放到第三个表中时则该算法可以通过对输入数据一趟排序来完成。 归并排序代码归并排序分为三个函数，分别是：mSort函数、merge函数、mergeSort函数。其中merge函数是将不断输入的数据排序并归并。mSort函数是利用递归的想法分而治之，分治是递归非常有力的用法。mergeSort函数是起到调用前面两个函数与分配临时空间的作用。 mSort函数123456789101112void mSort( int nums[], int tmpNums[], int left, int right )&#123; int center; if ( left &lt; right ) &#123; center = (left + right) / 2; mSort(nums, tmpNums, left, center); mSort(nums, tmpNums, center + 1 , right); merge(nums, tmpNums, left, center + 1, right); &#125;&#125; merge函数12345678910111213141516171819202122232425262728293031323334void merge(int nums[], int tmpNums[], int lPos, int rPos, int rightEnd)&#123; int i, leftEnd, numsElement, tmpPos; leftEnd = rPos - 1; tmpPos = lPos; numsElement = rightEnd - lPos + 1; while (lPos &lt;= leftEnd &amp;&amp; rPos &lt;= rightEnd) &#123; if (nums[lPos] &lt;= nums[rPos]) &#123; tmpNums[tmpPos++] = nums[lPos++]; &#125; else &#123; tmpNums[tmpPos++] = nums[rPos++]; &#125; &#125; while (lPos &lt;= leftEnd) &#123; tmpNums[tmpPos++] = nums[lPos++]; &#125; while (rPos &lt;= rightEnd) &#123; tmpNums[tmpPos++] = nums[rPos++]; &#125; for (i = 0; i &lt; numsElement; i++, rightEnd--) &#123; nums[rightEnd] = tmpNums[rightEnd]; &#125;&#125; mergeSort函数1234567891011121314void mergeSort(int nums[], int N)&#123; int *tmpNums; tmpNums = malloc(N * sizeof(int)); if (tmpNums != NULL) &#123; mSort(nums, tmpNums, 0, N - 1); free(tmpNums); &#125; else &#123; printf(\"No space for tmp array\"); &#125;&#125; main函数123456789101112#include&lt;stdio.h&gt;int main(int argc, char *argv[])&#123; int nums[10] = &#123; 5, 3, 4, 1, 6, 10, 12, 2, 23, 9 &#125;; mergeSort(nums, 10); int i; for (i = 0; i&lt;10; i++) &#123; printf(\"%d\\n\", nums[i]); &#125;&#125; 归并排序的分析假设N是2的幂，从而我们总可以将它分裂成均为偶数的两部分。对于N-1，归并排序时间是常数，我们将记为1.否则，对N个数归并并排序的用时等于完成两个大小为N/2的递归排序所用的时间再加上合并的时间， 它是线性的。下面方程给出准确的表示：$$ T(1) = 1 $$$$ T(N) = 2T(\\frac N2) + N $$将上式两边同时除以N有：$$ \\frac{T(N)}{N} = {T(\\frac N2)\\over(\\frac N2)} + 1 $$该方程对2的幂的任意的N是成立的，我们还可以写成：$$ {T(\\frac N2)\\over(\\frac N2)} = {T(\\frac N4)\\over(\\frac N4)} +1 $$$$ ...$$$$ {T(2)\\over2} = {T(1)\\over1} + 1 $$将上式相加，并约掉可以得到：$$ {T(N)\\over N} = {T(1)\\over1} + logN $$两边同时乘以N得到：$$ T(N) = N + NlogN = O(NlogN) $$","categories":[{"name":"排序","slug":"排序","permalink":"http://yoursite.com/categories/排序/"}],"tags":[{"name":"排序算法","slug":"排序算法","permalink":"http://yoursite.com/tags/排序算法/"}]},{"title":"Leetcode 283: Move Zeroes","slug":"Leetcode-283-Move-Zeroes","date":"2016-07-30T10:48:47.000Z","updated":"2016-08-03T08:18:14.081Z","comments":true,"path":"2016/07/30/Leetcode-283-Move-Zeroes/","link":"","permalink":"http://yoursite.com/2016/07/30/Leetcode-283-Move-Zeroes/","excerpt":"Given an array nums, write a function to move all 0’s to the end of it while maintaining the relative order of the non-zero elements.","text":"Given an array nums, write a function to move all 0’s to the end of it while maintaining the relative order of the non-zero elements.For example, given nums = [0, 1, 0, 3, 12], after calling your function, nums should be [1, 3, 12, 0, 0].Note: You must do this in-place without making a copy of the array. Minimize the total number of operations. 题意考虑一个数组，写一个函数使用该数组的0移动到数组尾部，而非零的数保持一定的顺序。比如，给一个数组nums =[0, 1, 0, 3, 12],经过该函数处理后，nums应该变为[1, 3, 12, 0, 0]; 程序(C语言)123456789101112131415161718192021void swap(int* nums, int left, int right)&#123; if (left == right)&#123; return; &#125;else&#123; nums[left] ^= nums[right]; nums[right] ^= nums[left]; nums[left] ^= nums[right]; &#125;&#125;void moveZeroes(int* nums, int numsSize)&#123; int left = 0; int right = 0; while (right &lt; numsSize)&#123; if (nums[right] != 0)&#123; swap(nums, left, right); left++; &#125; right++; &#125;&#125; 结果21 / 21 test cases passed.Status: AcceptedRuntime: 8 ms","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/tags/LeetCode/"},{"name":"Array","slug":"Array","permalink":"http://yoursite.com/tags/Array/"}]},{"title":"Leetcode 217: Contains Duplicate","slug":"Leetcode-217-Contains-Duplicate","date":"2016-07-30T10:34:47.000Z","updated":"2016-08-03T08:17:41.745Z","comments":true,"path":"2016/07/30/Leetcode-217-Contains-Duplicate/","link":"","permalink":"http://yoursite.com/2016/07/30/Leetcode-217-Contains-Duplicate/","excerpt":"Given an array of integers, find if the array contains any duplicates. Your function should return true if any value appears at least twice in the array","text":"Given an array of integers, find if the array contains any duplicates. Your function should return true if any value appears at least twice in the array,and it should return false if every element is distinct. 题意大概为, 考虑一个整型的数组，找出是否该数组有重复的数。如果有数出现超过两次，那么你的函数返回ture，否则返回false。 程序(C语言)12345678910111213141516int cmp(const int* a, const int* b)&#123; return *a - *b;&#125;bool containsDuplicate(int* nums, int numsSize) &#123; qsort(nums, numsSize, sizeof(int), cmp); if (numsSize &lt; 2)&#123; return false; &#125; int i; for (i=0; i&lt;(numsSize-1); i++)&#123; if (nums[i] == nums[i+1])&#123; return true; &#125; &#125; return false;&#125; 结果16 / 16 test cases passed.Status: AcceptedRuntime: 12 ms","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/tags/LeetCode/"},{"name":"Array","slug":"Array","permalink":"http://yoursite.com/tags/Array/"}]},{"title":"C函数qsort的用法","slug":"C函数qsort用法","date":"2016-07-30T07:37:31.000Z","updated":"2016-07-30T23:18:34.435Z","comments":true,"path":"2016/07/30/C函数qsort用法/","link":"","permalink":"http://yoursite.com/2016/07/30/C函数qsort用法/","excerpt":"qsort()函数是ANSI C标准中提供的，其声明在stdlib.h文件中，是根据二分发写的，其时间复杂度为n*log(n)。","text":"qsort()函数是ANSI C标准中提供的，其声明在stdlib.h文件中，是根据二分发写的，其时间复杂度为n*log(n)。为了了解 排序方式排序方式有很多种，比如：选择排序、冒泡排序、归并排序、快速排序等等。顾名思义快速排序是目前公认的一种比较好的排序算法，其比选择排序、冒泡排序都要快。因为它的速度很快，所以系统也在库里实现这个算法，便于我们使用，这个函数就是qsort了。 qsort简介qsort的函数原型是:1void qsort(void* base, size_t nelem, size_t width, cmp) 其中： *base为要排序的数组 nelem为要排序的数组的长度 width为每个数组元素的大小(以字节为单位) cmp为自己定义的比较函数，其作用在于方便使用者实现对数组、字符串、结构体等结构进行升序或降序排列。 cmp函数1int cmp(const void *a, const void *b) cmp函数中有两个元素作为参数，返回一个int值，如果比较函数返回大于0，qsort就认为a&gt;b；如果返回等于0，qsort就认为a=b；如果返回小于0，qsort就认为a小于b。因此，qsort函数知道元素大小，就可以把大的放到前面去。如果你把cmp函数的返回值1与-1的位置调换，那么就造成了升降序的差别了。 实例操作为了加深理解，下面以数组、字符串、结构体为例说明情况 对int数组进行排序12345int nums[100];int cmp ( const void *a , const void *b )&#123; return *(int *)a - *(int *)b; &#125;qsort(num,100,sizeof(num[0]),cmp); 对char类型数组排序12345char word[100];int cmp( const void *a , const void *b )&#123; return *(char *)a - *(int *)b;&#125;qsort(word,100,sizeof(word[0]),cmp); 对double类型数组排序12345double nums[100];int cmp( const void *a , const void *b )&#123; return *(double *)a - *(double *)b;&#125;qsort(nums,100,sizeof(nums[0]),cmp); 对结构体类型排序1234567891011struct Node&#123; double data; int other; &#125;s[100]//按照data的值从小到大将结构体排序,关于结构体内的排序关键数据data的类型可以很多种，//参考上面的例子写int cmp( const void *a ,const void *b)&#123; return (*(Node *)a).data - (*(Node *)b).data ? 1 : -1; &#125;qsort(s,100,sizeof(s[0]),cmp); 对结构体二级排序123456789101112131415struct Node&#123; int x; int y; &#125;s[100];//按照x从小到大排序，当x相等时按照y从大到小排序int cmp( const void *a , const void *b )&#123; struct Node *c = (Node *)a; struct Node *d = (Node *)b; if(c-&gt;x != d-&gt;x) return c-&gt;x - d-&gt;x; else return d-&gt;y - c-&gt;y;&#125;qsort(s,100,sizeof(s[0]),cmp); 对字符串进行排序12345678910struct Node &#123; int data; char str[100]; &#125;s[100];//按照结构体中字符串str的字典顺序排序int cmp ( const void *a , const void *b )&#123; return strcmp( (*(Node *)a)-&gt;str , (*(Node *)b)-&gt;str );&#125;qsort(s,100,sizeof(s[0]),cmp);","categories":[{"name":"C语言","slug":"C语言","permalink":"http://yoursite.com/categories/C语言/"}],"tags":[{"name":"C语言","slug":"C语言","permalink":"http://yoursite.com/tags/C语言/"}]},{"title":"win10取消开机密码","slug":"win10取消开机密码","date":"2016-07-30T07:16:48.000Z","updated":"2016-07-30T23:19:17.582Z","comments":true,"path":"2016/07/30/win10取消开机密码/","link":"","permalink":"http://yoursite.com/2016/07/30/win10取消开机密码/","excerpt":"每次自己或者帮家人取消win10开机密码时，都要上网查一下攻略，虽然很简单，但是为了下次不那么麻烦。","text":"每次自己或者帮家人取消win10开机密码时，都要上网查一下攻略，虽然很简单，但是为了下次不那么麻烦。这里就把这个教程记录下来。 步骤 首先，在电脑中点击桌面左下角的开始菜单图标，在出现的开始菜单界面中的搜索框中输入netplwiz，然后在搜索结果中点击最上面的netplwiz。或者cmd+R再输入netplwiz也一样。 然后在弹出的界面中定位到用户或者user选项卡菜单界面，取消勾选要使用本计算机，用户必须...，然后点击确定按钮，如图所示。 输入你的电脑的登录密码，并且重新确认一下，最后点击“确定”按钮保存退出。 这样下次开机的时候就不用输入密码，不过如果是睡眠重启的话还是需要密码的。","categories":[{"name":"Win10","slug":"Win10","permalink":"http://yoursite.com/categories/Win10/"}],"tags":[{"name":"Win10","slug":"Win10","permalink":"http://yoursite.com/tags/Win10/"}]},{"title":"Git上传时出现error","slug":"git上传时出现error","date":"2016-07-27T05:24:55.000Z","updated":"2016-07-30T07:30:39.698Z","comments":true,"path":"2016/07/27/git上传时出现error/","link":"","permalink":"http://yoursite.com/2016/07/27/git上传时出现error/","excerpt":"今天使用git上传文件到github上时出现错误，提示是error: src refspec master does not match any，后来上网查了一下，问题解决了。","text":"今天使用git上传文件到github上时出现错误，提示是error: src refspec master does not match any，后来上网查了一下，问题解决了。为了防止以后再遇到类似问题又给忘记了，所以还是把这个方法简单记录在此。 git工作大致流程 1、在github上创建项目 2、使用git clone https://github.com/xxxxxxx/xxxxx.git克隆到本地 3、编辑项目 4、git add . （将改动添加到暂存区） 5、git commit -m “提交说明” 6、git push origin master 将本地更改推送到远程master分支。 这样你就完成了向远程仓库的推送。 解决措施如果在github的remote上已经有了文件，会出现错误。此时应当先pull一下，即：1git pull origin master 然后再进行：1git push origin master 这样就不会出现错误提示了。","categories":[{"name":"Git","slug":"Git","permalink":"http://yoursite.com/categories/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://yoursite.com/tags/Git/"}]},{"title":"Git命令add和commit的区别","slug":"Git命令add和commit的区别","date":"2016-07-27T00:42:34.000Z","updated":"2016-07-27T05:25:47.684Z","comments":true,"path":"2016/07/27/Git命令add和commit的区别/","link":"","permalink":"http://yoursite.com/2016/07/27/Git命令add和commit的区别/","excerpt":"要想弄明白git add和git commit的区别，首先我们需要知道三个概念：工作区(Working Directory)、版本库(Repository)、暂存区(Stage or index)。","text":"要想弄明白git add和git commit的区别，首先我们需要知道三个概念：工作区(Working Directory)、版本库(Repository)、暂存区(Stage or index)。 工作区当你在开发一个项目时，主目录就是你的工作区。 版本库工作区中有一个隐藏目录.git，这个就是git的版本库了。 暂存区Git的版本库里存了很多文件，其中包括称为Stage或index的暂存区，还有一个git为我们自动创建的第一个分支master，以及指向master的一个指针HEAD。下面就是三个区的示意图：图片来着廖雪峰老师的 博客。 区别git add和git commit的区别就在于：git add把文件添加进去，实际上就是把文件修改添加到暂存区；git commit提交更改，实际上就是把暂存区的所有内容提交到当前分支。因为我们创建Git版本库时，Git自动为我们创建了唯一一个master分支。所以，git commit就是往master分支上提交更改。你可以简单理解为，需要提交的文件修改通通放到暂存区，然后，一次性提交暂存区的所有修改。 所以要想将修改提交到master中一定要先git add到暂存区中，再git commit到master分支。","categories":[{"name":"Git","slug":"Git","permalink":"http://yoursite.com/categories/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://yoursite.com/tags/Git/"}]},{"title":"Win下Sublime3美化","slug":"Sublime3美化","date":"2016-07-26T11:20:15.000Z","updated":"2016-07-30T23:19:58.881Z","comments":true,"path":"2016/07/26/Sublime3美化/","link":"","permalink":"http://yoursite.com/2016/07/26/Sublime3美化/","excerpt":"虽然sublime3没有atom的高颜值，但是稍微美化一下也是上得了台面的，再加上极快的启动速度，简直是我心中的神器。","text":"虽然sublime3没有atom的高颜值，但是稍微美化一下也是上得了台面的，再加上极快的启动速度，简直是我心中的神器。 主题美化使用过很多sublime3的主题，最后在laracasts视频中发现了一款十分漂亮的主题Material Theme。废话不多说，下面是教程：首先在sublime中Ctrl+Shift+p出现一个输入面板，再在面板上输入install package确认后再次出现一个面板，此时输入Material theme确认后等待安装即可。安装完成后在Preference-&gt;Setting-User中输入一下代码：12&quot;color_scheme&quot;: &quot;Packages/Material Theme/schemes/Material-Theme.tmTheme&quot;,&quot;theme&quot;: &quot;Material-Theme.sublime-theme&quot;, 最后再重启一下即可。当然这个主题还有一些其他的设置，想要更详细的设置请看官网 PackageControl 编程字体的选择曾经有段时间我不断在寻找最舒服的编程字体，包括什么Source Code Pro、DeJaVu Sans Mono、Droid Sans Mono、CamingoCode、Courier New等等，但是都不太满意。比如Source Code Pro中i的头尖尖的看着让我感到别扭。其他几种各有各的缺点。最后终于发现了Fira Code，这是Firefox设计的一款字体。废话不多说上图说明：","categories":[{"name":"Sublime","slug":"Sublime","permalink":"http://yoursite.com/categories/Sublime/"}],"tags":[{"name":"Sublime","slug":"Sublime","permalink":"http://yoursite.com/tags/Sublime/"},{"name":"Win10","slug":"Win10","permalink":"http://yoursite.com/tags/Win10/"}]},{"title":"Sublime3快捷键整理","slug":"Sublime3快捷键整理","date":"2016-07-26T10:59:51.000Z","updated":"2016-07-30T23:20:06.672Z","comments":true,"path":"2016/07/26/Sublime3快捷键整理/","link":"","permalink":"http://yoursite.com/2016/07/26/Sublime3快捷键整理/","excerpt":"Sublime Text 3是我最喜欢而且使用最多的一个编辑器，因为他启动速度快，界面可以美化的十分性感与优雅。","text":"Sublime Text 3是我最喜欢而且使用最多的一个编辑器，因为他启动速度快，界面可以美化的十分性感与优雅。虽然自由度没有atom这么高，但是atom相比于Sublime速度实在是有点慢。下面是我整理的一些常用快捷键： Ctrl + g 跳转到相应的行Ctrl + m 在括号起始位置和终止位置之间切换Ctrl + Shift + m 选中括号内内容Ctrl + Shift + k 删除光标所在行Ctrl + Shift + up 当前行向上移动Ctrl + Shift + down 当前行向下移动Ctrl + l 选择光标所在行ctrl + t 交换相邻的两个字母","categories":[{"name":"Sublime","slug":"Sublime","permalink":"http://yoursite.com/categories/Sublime/"}],"tags":[{"name":"Sublime","slug":"Sublime","permalink":"http://yoursite.com/tags/Sublime/"}]},{"title":"WinSnap:带阴影的截图才是好截图","slug":"WinSnap-带阴影的截图才是好截图","date":"2016-07-26T09:39:20.000Z","updated":"2016-07-30T23:19:03.997Z","comments":true,"path":"2016/07/26/WinSnap-带阴影的截图才是好截图/","link":"","permalink":"http://yoursite.com/2016/07/26/WinSnap-带阴影的截图才是好截图/","excerpt":"我认为 OS X 内建的截图工具的最大优点就是自动加阴影。正所谓「再小的需求也应该被满足，是的，你可能发现了上文中所有","text":"我认为 OS X 内建的截图工具的最大优点就是自动加阴影。正所谓「再小的需求也应该被满足，是的，你可能发现了上文中所有的截图都是带有阴影的，真的就是 OS X 截图的那种阴影诶！ 如果你也像我一样对这个阴影喜爱有加，你一定需要 WinSnap 这款应用。仅仅 2MB，你便能够在 Windows 上完全实现 OS X 内建截图的效果，阴影和快捷键都不在话下，有过之无不及。 下载地址是：WinSnap ,这个是免安装版本的，下载后可以直接用了。上面的图片恰好是WinSnap热键的自定义菜单，可以根据自己的习惯调节一下","categories":[{"name":"Win10","slug":"Win10","permalink":"http://yoursite.com/categories/Win10/"}],"tags":[{"name":"Win10","slug":"Win10","permalink":"http://yoursite.com/tags/Win10/"},{"name":"工具","slug":"工具","permalink":"http://yoursite.com/tags/工具/"}]},{"title":"Win10上使用Mactype","slug":"Win10上使用Mactype","date":"2016-07-26T02:21:47.000Z","updated":"2016-07-30T23:19:36.867Z","comments":true,"path":"2016/07/26/Win10上使用Mactype/","link":"","permalink":"http://yoursite.com/2016/07/26/Win10上使用Mactype/","excerpt":"由于window系统上字体渲染很不舒服，故我一直使用mactype来改善一下。但是升级到win10后发现一打开mactype就出现黑屏或者打开界面显示有问题。","text":"由于window系统上字体渲染很不舒服，故我一直使用mactype来改善一下。但是升级到win10后发现一打开mactype就出现黑屏或者打开界面显示有问题。后面查了一些教程后发现在win10上还需要做一些文件替换。下面是教程： 安装首先，安装mactype，到网上随便找一个下载即可。这里提供了百度网盘的下载路径 Mactype。安装的话没什么需要特别注意的。 文件替换安装完成后，先不要打开mactype否则可能会出现黑屏等等问题。先打开mactype的安装目录，像我是在C:\\Program Files (x86)\\MacType这里，这时候用EasyHk32.dll、EasyHk64.dll、MacType.dll、MacType64.dll文件替换掉mactype安装目录下的对应文件。替换文件在刚刚提供的百度网盘里面有。此时打开mactype再设置一番就大功告成了。下面是效果图：可以看到效果还是十分明显的，mactype加载方式我是使用兼容加载的，用注册表加载可能很方便但是会导致较慢的开机速度。","categories":[{"name":"Mactype","slug":"Mactype","permalink":"http://yoursite.com/categories/Mactype/"}],"tags":[{"name":"Win10","slug":"Win10","permalink":"http://yoursite.com/tags/Win10/"},{"name":"Mactype","slug":"Mactype","permalink":"http://yoursite.com/tags/Mactype/"}]},{"title":"99%的人都理解错了HTTP中GET与POST的区别","slug":"99-的人都理解错了HTTP中GET与POST的区别","date":"2016-07-25T05:38:30.000Z","updated":"2016-07-30T23:20:41.884Z","comments":true,"path":"2016/07/25/99-的人都理解错了HTTP中GET与POST的区别/","link":"","permalink":"http://yoursite.com/2016/07/25/99-的人都理解错了HTTP中GET与POST的区别/","excerpt":"GET和POST是HTTP请求的两种基本方法，要说它们的区别，接触过WEB开发的人都能说出一二。最直观的区别就是GET把参数包含在URL中，POST通过request body传递参数。","text":"GET和POST是HTTP请求的两种基本方法，要说它们的区别，接触过WEB开发的人都能说出一二。最直观的区别就是GET把参数包含在URL中，POST通过request body传递参数。你可能自己写过无数个GET和POST请求，或者已经看过很多权威网站总结出的他们的区别，你非常清楚知道什么时候该用什么。当你在面试中被问到这个问题，你的内心充满了自信和喜悦。你轻轻松松的给出了一个“标准答案”： GET在浏览器回退时是无害的，而POST会再次提交请求。 GET产生的URL地址可以被Bookmark，而POST不可以。 GET请求会被浏览器主动cache，而POST不会，除非手动设置。 GET请求只能进行url编码，而POST支持多种编码方式。 GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。 GET请求在URL中传送的参数是有长度限制的，而POST么有。 对参数的数据类型，GET只接受ASCII字符，而POST没有限制。 GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。 GET参数通过URL传递，POST放在Request body中。（本标准答案参考自w3schools）“很遗憾，这不是我们要的回答！”请告诉我真相。。。如果我告诉你GET和POST本质上没有区别你信吗？让我们扒下GET和POST的外衣，坦诚相见吧！ GET和POST是什么？HTTP协议中的两种发送请求的方法。HTTP是什么？HTTP是基于TCP/IP的关于数据如何在万维网中如何通信的协议。HTTP的底层是TCP/IP。所以GET和POST的底层也是TCP/IP，也就是说，GET/POST都是TCP链接。GET和POST能做的事情是一样一样的。你要给GET加上request body，给POST带上url参数，技术上是完全行的通的。 那么，“标准答案”里的那些区别是怎么回事？ 在我大万维网世界中，TCP就像汽车，我们用TCP来运输数据，它很可靠，从来不会发生丢件少件的现象。但是如果路上跑的全是看起来一模一样的汽车，那这个世界看起来是一团混乱，送急件的汽车可能被前面满载货物的汽车拦堵在路上，整个交通系统一定会瘫痪。为了避免这种情况发生，交通规则HTTP诞生了。HTTP给汽车运输设定了好几个服务类别，有GET, POST, PUT, DELETE等等，HTTP规定，当执行GET请求的时候，要给汽车贴上GET的标签（设置method为GET），而且要求把传送的数据放在车顶上（url中）以方便记录。如果是POST请求，就要在车上贴上POST的标签，并把货物放在车厢里。当然，你也可以在GET的时候往车厢内偷偷藏点货物，但是这是很不光彩；也可以在POST的时候在车顶上也放一些数据，让人觉得傻乎乎的。HTTP只是个行为准则，而TCP才是GET和POST怎么实现的基本。 但是，我们只看到HTTP对GET和POST参数的传送渠道（url还是requrest body）提出了要求。“标准答案”里关于参数大小的限制又是从哪来的呢？ 在我大万维网世界中，还有另一个重要的角色：运输公司。不同的浏览器（发起http请求）和服务器（接受http请求）就是不同的运输公司。 虽然理论上，你可以在车顶上无限的堆货物（url中无限加参数）。但是运输公司可不傻，装货和卸货也是有很大成本的，他们会限制单次运输量来控制风险，数据量太大对浏览器和服务器都是很大负担。业界不成文的规定是，（大多数）浏览器通常都会限制url长度在2K个字节，而（大多数）服务器最多处理64K大小的url。超过的部分，恕不处理。如果你用GET服务，在request body偷偷藏了数据，不同服务器的处理方式也是不同的，有些服务器会帮你卸货，读出数据，有些服务器直接忽略，所以，虽然GET可以带request body，也不能保证一定能被接收到哦。 好了，现在你知道，GET和POST本质上就是TCP链接，并无差别。但是由于HTTP的规定和浏览器/服务器的限制，导致他们在应用过程中体现出一些不同。 你以为本文就这么结束了？ 我们的大BOSS还等着出场呢。。。 这位BOSS有多神秘？当你试图在网上找“GET和POST的区别”的时候，那些你会看到的搜索结果里，从没有提到他。他究竟是什么呢。。。 GET和POST还有一个重大区别，简单的说：GET产生一个TCP数据包；POST产生两个TCP数据包。 长的说：对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。 也就是说，GET只需要汽车跑一趟就把货送到了，而POST得跑两趟，第一趟，先去和服务器打个招呼“嗨，我等下要送一批货来，你们打开门迎接我”，然后再回头把货送过去。 因为POST需要两步，时间上消耗的要多一点，看起来GET比POST更有效。因此Yahoo团队有推荐用GET替换POST来优化网站性能。但这是一个坑！跳入需谨慎。为什么？ GET与POST都有自己的语义，不能随便混用。 据研究，在网络环境好的情况下，发一次包的时间和发两次包的时间差别基本可以无视。而在网络环境差的情况下，两次包的TCP在验证数据包完整性上，有非常大的优点。 并不是所有浏览器都会在POST中发送两次包，Firefox就只发送一次。 现在，当面试官再问你“GET与POST的区别”的时候，你的内心是不是这样的？","categories":[{"name":"HTTP","slug":"HTTP","permalink":"http://yoursite.com/categories/HTTP/"}],"tags":[{"name":"HTTP","slug":"HTTP","permalink":"http://yoursite.com/tags/HTTP/"},{"name":"GET","slug":"GET","permalink":"http://yoursite.com/tags/GET/"},{"name":"POST","slug":"POST","permalink":"http://yoursite.com/tags/POST/"}]},{"title":"Research directions for IOT","slug":"Research directions for IOT","date":"2016-07-20T00:57:18.000Z","updated":"2016-07-26T03:06:06.709Z","comments":true,"path":"2016/07/20/Research directions for IOT/","link":"","permalink":"http://yoursite.com/2016/07/20/Research directions for IOT/","excerpt":"As each individual system has its own assumptions and strategy to control the physical world variables without much knowledge of the other systems,","text":"As each individual system has its own assumptions and strategy to control the physical world variables without much knowledge of the other systems, which leads to conflicts when these systems are integrated without careful consideration. 1.What`s the problem of dependency in IOT?As each individual system has its own assumptions and strategy to control the physical world variables without much knowledge of the other systems, which leads to conflicts when these systems are integrated without careful consideration. Such problems arise in the cyber part mainly because each application has assumptions on the physical world entities without knowing how other applications work. Let’s use an example to better illustrate “what the problem of dependency” are: a home health care application may detect depression and decide to turn on all the lights. On the other hand, the energy management application may decide to turn off lights when no motion is detected. Detecting and resolving such dependency problems is important for correctness of operation of interacting IoT systems. The problem of dependencies are: App interdependency: It arises when one app relies on another app. If the independent app makes an error, the error may propagate and affect all the dependent apps and may cause a lot of conflicts in the system.t Control dependency for the sensors and actuators: It arises when multiple apps want to control a sensor in different ways.For example, App1 wants to run a humidifier and App2 wants to run a dehumidifier at the same time. Missing dependency: It arises when app developers forget to specify the dependency information of their apps. For example, App1 forgets to specify its dependency on light L1 in its meta data., but at runtime it tries to control L1. 2.What`s the major technologies to address the dependency issues in IOT?Cyber Physical system(CPS)We can propose a integrated CPS, a utility sensing and actuation system that provides comprehensive strategies to specify, detect, and resolve conflicts.This system consideres a comprehensive spectrum of dependencies and treating each system as an app. Each system communicates with its sensors and actuators and performs computations for taking appropriate control decisions to actuate on the physical world entities. App developers specify dependency information as meta data within their apps and their apps are put in an app store. Users can choose and install apps from the app store. This system can use the meta-data to detect and resolve conflicts at app installation time and at run-time. Let`s take some examples to introduce this ststem: addressing requirement dependency: This system reqiures developers to specify the requirement of each app in a manifest file written in XML.just like this : 123456789101112&lt;requirement&gt; &lt;device&gt; &lt;device_type&gt; x10_motion_sensor &lt;/device_type&gt; &lt;container&gt; room &lt;/container&gt; &lt;level&gt; strict &lt;/level&gt; &lt;/device&gt; &lt;device&gt; &lt;device_type&gt; x10_contact_sensor &lt;/device_type&gt; &lt;container&gt; window, door &lt;/container&gt; &lt;level&gt; strict &lt;/level&gt; &lt;/device&gt; &lt;/requirement&gt; Requirements can be either strict or loose. The motion sensor requirement is strict, which means that the app will not work without the motion sensors.But the app will still work without the contact sensors. adderssing actuator control dependency: Resolving control dependency of the actuators in a wrong way may cause death, e.g, granting an app’s request to turn off the breathing machine to save energy while it is being used by another health app.therefore, this system will detect such conflicts when two apps try to access the same device at the same time and resolve the conflict in favor of the higher priority app.It requires app developers to specify in XMLeffect,emphasis, and condition for each actuator that app wants to control. EffectEffect specifies the effect of an app on the environment when using a particular device.Two apps may be using completely different devices, but are conflicting with each orher by causing opposite effects.The XML tags can be increase, decrease, and change.For example, App1 may specify:123456&lt;device&gt; &lt;device_name&gt; humidifier &lt;/device_name&gt; &lt;effect&gt; &lt;humidity&gt; increase &lt;/humidity&gt; &lt;/effect&gt;&lt;/device&gt; On the other hand, App2 mey specify:123456&lt;device&gt; &lt;device_name&gt; humidifier &lt;/device_name&gt; &lt;effect&gt; &lt;humidity&gt; increase &lt;/humidity&gt; &lt;/effect&gt;&lt;/device&gt; When two apps have an opposite effect, they will not conflict. When two apps have an opposite effect, there is a chance that they will conflict at runtime. When two apps have the same effect, or mixed effect, system will look into emphasis andconditionto determine whether these apps will conflict or not. EmphasisEmphasis is based on the insight that not all control operations are equally important to an app, and emphasis allows an app to specify which device operation is more important than others.The security app mentioinsed above specifies its emphasis for controlling lights:123&lt;emphasis&gt; &lt;operation&gt; On() &lt;/operation&gt;&lt;/emphasis&gt; The energy app mentioned above specified above specifies its emphasis for controlling lights:1234&lt;emphasis&gt; &lt;operation&gt; On() &lt;/operation&gt; &lt;operation&gt; Off() &lt;/operation&gt;&lt;/emphasis&gt; when two apps have the same emphasis, then they are not conflicting with each other. if the emphasis of two apps is different, then they may be conflicting(also depends on conditions). ConditionTwo apps are not conflicting if they operate on a device with a mutually exclusive condition.The conditions can be categorized into two groups: (1)conditions based on time.(2)conditions based on event. Here are some example:1234&lt;start_time&gt; 20:00:00&lt;/start_time&gt;&lt;end_time&gt; 21:00:00 &lt;/end_time&gt;&lt;night&gt; duration &lt;/night&gt;&lt;sunset&gt; begin &lt;/sunset&gt; 3.What’s the questions and gaps that need to be filled in IoT system with examples?####SecurityA fundamental problem that must be solved in IOT is dealing with security problem.It worth to think about 3 security problem as follow: dependency issues – Do you know when something goes wrong?The aforementioned paragraph suggests that resolving control dependency of the actuators in a wrong way may cause death, e.g, granting an app’s request to turn off the breathing machine to save energy while it is being used by another health app. Data Encryption – Is your data protected?At a glance, many developers may be inclined to use SSL for secure communications. However, this can be problematic in an M2M application due to the additional processing power and memory required in a device to support SSL, and the increased wireless data costs that are a product of the increase in network communications overhead. Controlling access – Who can access your data/system?While encryption is demanded for private information, in some instances, confidentiality may be far less important than access and authentication. For example, the data transmitted with a wireless command to open your car door may not be confidential, but it is critical that no unauthorized parties have access to unlock the door through that system. PrivacyDespite the immense potential of IoT in the various spheres, the whole communication infrastructure of the IoT is flawed from the security standpoint and is susceptible to loss of privacy for the end users. Some of the most prominent security issues plaguing the entire developing IoT system arise out of the security issues present in the technologies used in IoT for information relay from one device to another. As such some of the prominent security issues stemming out from the communication technology are the following:( Wireless Sensor Networks (WSN) ) DoS attack on the physical layer:The physical layer of a wireless sensor network carries out the function of selection and generation of carrier frequency, modulation and demodulation, encryption and decryption, transmission and reception of data. This layer of the wireless sensor network is attacked mainly through Jamming: In this type of DoS attack occupies the communication channel between the nodes thus preventing them from communicating with each other. Node tampering: Physical tampering of the node to extract sensitive information is known as node tampering. DoS attack on the link layer:The link layer of WSN multiplexes the various data streams, provides detection of data frame, MAC and error control. Moreover the link layer ensures point-point or pointmultipoint reliability . The DoS attacks taking place in this layer are: Collision: This type of DoS attack can be initiated whentwo nodes simultaneously transmit packets of data on the same frequency channel. Unfairness: As described in , unfairness is a repeated collision based attack. It can also be referred to as exhaustion based attacks. Battery Exhaustion: This type of DoS attack causes unusually high traffic in a channel making its accessibility very limited to the nodes. Such a disruption in the channel is caused by a large number of requests (Request To Send) and transmissions over the channel. DoS attack on the network layer:The main function of the network layer of WSN is routing. The specific DoS attacks taking place in this layer are: Spoofing, replaying and misdirection of traffic. Hello flood attack: This attack causes high traffic in channels by congesting the channel with an unusually high number of useless messages. Here a single malicious node sends a useless message which is then replayed by the attacker to create a high traffic. Homing: In case of homing attack, a search is made in the traffic for cluster heads and key managers which have the capability to shut down the entire network. DoS attack on the transport layer:This layer of the WSN architecture provides reliability of data transmission and avoids congestion resulting from high traffic in the routers. The DoS attacks in this layer are: Flooding: It refers to deliberate congestion of communication channels through relay of unnecessary messages and high traffic. De-synchronization: In de-synchronization attack, fake messages are created at one or both endpoints requesting retransmissions for correction of non-existent error. This results in loss of energy in one or both the end-points in carrying out the spoofed instructions. ####Data ChallengeThe technologies to address the big data challenge already exist, like Hadoop or NoSQL, providing horizontal scalability, high capacity and parallel processing at prices that make them affordable and economical.With the development of wearables for consumers and the emerging use of smart machines the portion of IoT as a subset of big data will grow quickly forcing enterprises to think their infrastructure to enable scalability and to make them cost effective. ####Server TechnologiesThe impact of IoT on the server market will be largely focused on increased investment in key vertical industries and organizations related to those industries where IoT can be profitable, or add significant value.Some organizations that manage and consume data collected from a huge array of devices will require additional compute capacity and may well increase server budgets if there is a business case for it. ####Data Center NetworkExisting data center WAN (Wide Area Network) links have been built for moderate-bandwidth requirements created by our current use of technology. However, as the amount of data being transferred is set to increase dramatically, the need for expanded bandwidth grows.The result of all this, the research points out, is that because of the scale of the data being created it will no longer be economically feasible to store data at a single location. Reference[1] S. Munir and J. Stankovic, “DepSys: Dependency aware integration of systems for smart homes,” in Proc. ACM/IEEE Int. Conf. Cyber Phys. Syst.,Apr. 2014.[2] J. Stankovic, “When sensor, and actuator networks cover the world,invited keynote article,” ETRI J., vol. 30, no. 5, pp. 627–633, Oct. 2008.[3] Security. http://embedded-computing.com/guest-blogs/5-security-questions-for-your-next-iot-deployment/[4] Tuhin Borgohain, Uday Kumar, Sugata Sanyal. “Survey of Security and Privacy Issues of Internet of Things“. Fri, 9 Jan 2015.[5] “7 Big Problems with the Internet of Things”. http://www.cmswire.com/cms/internet-of-things/7-big-problems-with-the-internet-of-things-024571.php","categories":[{"name":"物联网","slug":"物联网","permalink":"http://yoursite.com/categories/物联网/"}],"tags":[{"name":"物联网","slug":"物联网","permalink":"http://yoursite.com/tags/物联网/"}]},{"title":"sass安装","slug":"sass安装","date":"2016-06-19T14:59:33.000Z","updated":"2016-07-30T23:20:15.928Z","comments":true,"path":"2016/06/19/sass安装/","link":"","permalink":"http://yoursite.com/2016/06/19/sass安装/","excerpt":"Sass 是最早的 CSS 预处理语言，有比 LESS 更为强大的功能，不过其一开始的缩进式语法（Sass老版本语法)并不能被大众接受","text":"Sass 是最早的 CSS 预处理语言，有比 LESS 更为强大的功能，不过其一开始的缩进式语法（Sass老版本语法)并不能被大众接受，不过由于其强大的功能和 Ruby on Rails 的大力推动，还是有很多开发者选择了 Sass。Sass 是采用 Ruby 语言编写的一款 CSS 预处理语言，它诞生于2007年，是最大的成熟的 CSS 预处理语言。最初它是为了配合 HAML（一种缩进式 HTML 预编译器）而设计的，因此有着和 HTML 一样的缩进式风格。 Ruby安装在 Windows 平台下安装 Ruby 需要先有 Ruby 安装包，大家可以到 Ruby 的 官网下载对应需要的 Ruby 版本。Ruby 安装文件下载好后，可以按应用软件安装步骤进行安装 Ruby。在安装过程中，个人建议将其安装在 C 盘下，在安装过程中选择第二个选项（不选中，就会出现编译时找不到Ruby环境的情况），如下图所示： Ruby 安装完成后，在开始菜单中找到新安装的 Ruby，并启动 Ruby 的 Command 控制面板，如下图所示： Sass安装当你的电脑中安装好 Ruby 之后，接下来就可以安装 Sass 了。同样的在windows下安装 Sass 有多种方法。但这几种方法都是非常的简单，只需要在你的命令终端输入一行命令即可。 1、通过命令安装 Sass打开电脑的命令终端，输入下面的命令：1gem install sass 提醒一下，在使用 Mac 的同学，可能需要在上面的命令前加上”sudo”，才能正常安装：1sudo gem install sass 如果上面的方法没有安装成功，可以使用下面的两种方法。 2、通过 Compass 来安装 Sass除了使用 gem 命令来安装 Sass 之外，还可以通过安装 compass 来安装 Sass，因为 Compass 是基于 Sass 开发的一个框架。也就是说，你安装了 Compass，也就同时安装好了 Sass。 同样的在你的命令终端输入下面的命令： 1sudo gem install sass 执行完上面的命令之后，就开始安装 Compass 和 Sass。 注：Compass 是一个成熟的、基于 Sass 开发的一个框架，这里面集成了很多写好的 mixins 和 Sass 函数。不过在此暂不做过多阐述。 3、本地安装Sass由于有时候直接使用上面的命令安装会让你无法正常实现安装（网络受限原因），当碰到这种情况之时，那么安装需要特殊去处理，可以通过下面的方法来实现 Sass 的正常安装： 可以到 Rubygems 网站上将 Sass 的安装包（http://rubygems.org/gems/sass）下载下来，然后在命令终端输入： 1gem install &lt;把下载的安装包拖到这里&gt; 直接回车即可安装成功。 注：在 iOSX和win10系统平台，可以直接将下载的安装包拖到 “gem install” 后面。 4、淘宝 RubyGems 镜像安装 Sass除了下载 Sass 安装包到本地安装之外，碰到网络原因无法安装时还可以使用淘宝 RubyGems 镜像安装 Sass。只是我们需要通过 gem sources 命令来配置源，先移除默认的 https://rubygems.org 源，然后添加淘宝的源 https://ruby.taobao.org： 第一步：移动默认的源 1gem sources --remove https://rubygems.org/ 第二步：指定淘宝的源 1gem sources -a https://ruby.taobao.org/ 第三步：查看指定的源是不是淘宝源 1gem sources -l 返回结果如下： 12*** CURRENT SOURCES ***https://ruby.taobao.org 请确保只有 ruby.taobao.org。如果无误之后，执行下面的命令： 1gem install sass","categories":[{"name":"Sass","slug":"Sass","permalink":"http://yoursite.com/categories/Sass/"}],"tags":[{"name":"Sass","slug":"Sass","permalink":"http://yoursite.com/tags/Sass/"},{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"}]},{"title":"Git系列之安装","slug":"Git系列之安装","date":"2016-06-16T05:34:53.000Z","updated":"2016-07-27T05:25:40.577Z","comments":true,"path":"2016/06/16/Git系列之安装/","link":"","permalink":"http://yoursite.com/2016/06/16/Git系列之安装/","excerpt":"最早Git是在Linux上开发的，很长一段时间内，Git也只能在Linux和Unix系统上跑。不过，慢慢地有人把它移植到了Windows上。","text":"最早Git是在Linux上开发的，很长一段时间内，Git也只能在Linux和Unix系统上跑。不过，慢慢地有人把它移植到了Windows上。现在，Git可以在Linux、Unix、Mac和Windows这几大平台上正常运行了。这里主要讲windows下Git的安装，其他平台的可以到网上去搜索解决。win下安装十分简单，因为Git官网已经将其打包了，直接下载下来双击然后按照步骤安装即可。这里是Git官网 安装安装完成后，在开始菜单里找到“Git”-&gt;“Git Bash”，弹出一个类似命令行窗口的东西，就说明Git安装成功！如下图所示：","categories":[{"name":"Git","slug":"Git","permalink":"http://yoursite.com/categories/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://yoursite.com/tags/Git/"}]},{"title":"通信协议之Http","slug":"通信协议之Http","date":"2016-06-16T02:54:50.000Z","updated":"2016-07-30T23:20:50.892Z","comments":true,"path":"2016/06/16/通信协议之Http/","link":"","permalink":"http://yoursite.com/2016/06/16/通信协议之Http/","excerpt":"生活中我们接触的比较多的通信协议有HTTP、TCP、UDP等等。特别是HTTP协议，因为我们每天上网在浏览器中","text":"生活中我们接触的比较多的通信协议有HTTP、TCP、UDP等等。特别是HTTP协议，因为我们每天上网在浏览器中输入的网址基本都可以看到以http://开头的字符串。那么什么是通信协议呢？简而言之就是通信时所遵守的规则，只有双方按照这个规则“说话”，对方才能理解或为之服务。这里只是很口语化的解释，详细的解释可以到这里查看： 百度百科 维基百科 HTTP、TCP、UDP的区别TCP/IP是个协议组，可分为四个层次：网络接口层、网络层、传输层和应用层。 在网络层有IP协议、ICMP协议、ARP协议、RARP协议和BOOTP协议。 在传输层中有TCP协议与UDP协议。 在应用层有FTP、HTTP、TELNET、SMTP、DNS等协议。因此，HTTP本身就是一个协议，是从Web服务器传输超文本到本地浏览器的传送协议。 什么是HTTP协议HTTP全称是HyperText Transfer Protocal，即：超文本传输协议，从1990年开始就在WWW上广泛应用，是现今在WWW上应用最多的协议， Http是应用层协议，当你上网浏览网页的时候，浏览器和Web服务器之间就会通过HTTP在Internet上进行数据的发送和接收。Http是一个基于请求/响应模式的、无状态的协议。即我们通常所说的Request/Response。 URLURL(Uniform Resource Locator) 地址用于描述一个网络上的资源, 基本格式如下12345678schema://host[:port#]/path/.../[?query-string][#anchor]scheme 指定低层使用的协议(例如：http, https, ftp)host HTTP服务器的IP地址或者域名port# HTTP服务器的默认端口是80，这种情况下端口号可以省略。如果使用了别的端口，必须指明，例如 http://www.cnblogs.com:8080/path 访问资源的路径query-string 发送给http服务器的数据anchor- 锚 URL 的一个例子1234567http://www.mywebsite.com/sj/test/test.aspx?name=sviergn&amp;x=true#stuffSchema: httphost: www.mywebsite.compath: /sj/test/test.aspxQuery String: name=sviergn&amp;x=trueAnchor: stuff HTTP的Request/Response先看Request 消息的结构,Request消息分为3部分 第一部分叫Request line。 第二部分叫Request header。 第三部分是body. header和body之间有个空行。 第一行中的Method表示请求方法,比如”POST”,”GET”, Path-to-resoure表示请求的资源， Http/version-number 表示HTTP协议的版本号当使用的是”GET” 方法的时候， body是为空的比如我们打开博客园首页的request 如下GET http://www.cnblogs.com/ HTTP/1.1Host: www.cnblogs.com抽象的东西，难以理解，老感觉是虚的， 所谓眼见为实, 实际见到的东西，我们才能理解和记忆。 我们今天用Fiddler，实际的看看Request和Response.下面我们打开Fiddler 捕捉一个博客园登录的Request 然后分析下它的结构, 在Inspectors tab下以Raw的方式可以看到完整的Request的消息。如下图：","categories":[{"name":"HTTP","slug":"HTTP","permalink":"http://yoursite.com/categories/HTTP/"}],"tags":[{"name":"HTTP","slug":"HTTP","permalink":"http://yoursite.com/tags/HTTP/"},{"name":"通信协议","slug":"通信协议","permalink":"http://yoursite.com/tags/通信协议/"}]},{"title":"wampserver配置多站点","slug":"wampserver配置多站点","date":"2016-06-14T04:54:06.000Z","updated":"2016-07-30T23:19:46.917Z","comments":true,"path":"2016/06/14/wampserver配置多站点/","link":"","permalink":"http://yoursite.com/2016/06/14/wampserver配置多站点/","excerpt":"一般而言，当我们在本地调试网站时都会有多个站点。这时候为了方便区分各个网站，就需要设置多站点，即给每个站点取一个网址。","text":"一般而言，当我们在本地调试网站时都会有多个站点。这时候为了方便区分各个网站，就需要设置多站点，即给每个站点取一个网址。当然，这个网址只能在本地打开。这里，就介绍一下wampserver在win10下怎么设置多站点。 修改wampserver配置文件在wampserver安装位置\\bin\\apache\\apache\\apache2.4.17\\conf\\httpd.conf文件中查找Include conf/extra/httpd-vhosts.conf，去掉前面的注释#。打开wampserver安装位置\\bin\\apache\\apache\\apache2.4.17\\conf\\extra/httpd-vhosts.conf文件；在最后加入类似内容：（文件路径是自己安装程序的路径） 1234&lt;VirtualHost *:80&gt; DocumentRoot \"D:/wamp/www/blog\"(这是你放程序的文件路径) ServerName www.yoursite.com （这是自己定义的域名）&lt;/VirtualHost&gt; 修改windows下的hosts文件通过win+R在run下输入drivers，打开etc\\hosts文件，在最后加入127.0.0.1 www.yoursite.com （这是自己定义的域名） 结论123456# localhost name resolution is handled within DNS itself.# 127.0.0.1 localhost# ::1 localhost127.0.0.1 blog.iamxcc.com127.0.0.1 www.sf.com 以上是我的hosts文件内容，可以看出我定义了两个站点一个是blog.iamxcc.com, 另一个是www.sf.com。 123456789&lt;VirtualHost *:80&gt; DocumentRoot \"D:\\Web\\wamp64\\www\\my-site\\blog\" ServerName blog.iamxcc.com&lt;/VirtualHost&gt;&lt;VirtualHost *:80&gt; DocumentRoot \"D:\\Web\\wamp64\\www\\my-site\\sf\" ServerName www.sf.com&lt;/VirtualHost&gt; 其中blog.iamxcc.com指向位于D:\\Web\\wamp64\\www\\my-site\\blog下的站点，www.sf.com指向D:\\Web\\wamp64\\www\\my-site\\blog下的站点。到此为止，wampserver配置多任务已经成功。","categories":[{"name":"Wampserver","slug":"Wampserver","permalink":"http://yoursite.com/categories/Wampserver/"}],"tags":[{"name":"Wampserver","slug":"Wampserver","permalink":"http://yoursite.com/tags/Wampserver/"},{"name":"Wordpress","slug":"Wordpress","permalink":"http://yoursite.com/tags/Wordpress/"}]},{"title":"c语言交换a、b的方法","slug":"c语言交换a、b的方法","date":"2016-06-13T15:42:03.000Z","updated":"2016-07-30T23:20:27.691Z","comments":true,"path":"2016/06/13/c语言交换a、b的方法/","link":"","permalink":"http://yoursite.com/2016/06/13/c语言交换a、b的方法/","excerpt":"C语言中要实现两个变量值的交换一般而言可以分为两种方法：不引入中间变量和引入中间变量。具体代码如下：","text":"C语言中要实现两个变量值的交换一般而言可以分为两种方法：不引入中间变量和引入中间变量。具体代码如下： 常规方法一般而言，在C语言中交换a、b两个值时，我们常用的是使用指针来交换。具体的代码如下：1234567void swap(int *a ,int *b) //通过指针交换两者的值&#123; int c; c = *a; *a = *b; *b= c;&#125; 通过异或来实现除了上面的方法，还有一种更加简洁的办法如下：123456void swap(int &amp;a,int &amp;b) //通过异或交换两者的值&#123; a =a^b; b= a^b; a = b^a;&#125;","categories":[{"name":"C语言","slug":"C语言","permalink":"http://yoursite.com/categories/C语言/"}],"tags":[{"name":"C语言","slug":"C语言","permalink":"http://yoursite.com/tags/C语言/"},{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"}]},{"title":"Hello World","slug":"hello-world","date":"2016-06-12T05:34:53.000Z","updated":"2016-08-03T08:53:03.529Z","comments":true,"path":"2016/06/12/hello-world/","link":"","permalink":"http://yoursite.com/2016/06/12/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info.","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/categories/随笔/"}],"tags":[]},{"title":"一加通过adb刷机","slug":"一加通过adb刷机","date":"2016-05-27T15:26:19.000Z","updated":"2016-07-30T23:20:53.029Z","comments":true,"path":"2016/05/27/一加通过adb刷机/","link":"","permalink":"http://yoursite.com/2016/05/27/一加通过adb刷机/","excerpt":"经常刷Android机的朋友应该知道刷机方法有两种：一种是线刷，另一种是卡刷。两种方式都十分简单。下面就两种方法分别介绍：","text":"经常刷Android机的朋友应该知道刷机方法有两种：一种是线刷，另一种是卡刷。两种方式都十分简单。下面就两种方法分别介绍： 线刷包与卡刷包的区别1.名字的不同一般而言，名字中带有fastboot的都是线刷包 2.文件中的区别卡刷包线刷包 adb 刷机1adb sideload rom.zip","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"Oneplus","slug":"Oneplus","permalink":"http://yoursite.com/tags/Oneplus/"},{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"}]}]}