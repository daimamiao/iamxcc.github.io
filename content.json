{"meta":{"title":"胡闹的日子","subtitle":null,"description":"人一切的痛苦，本质上都是对自己的无能的愤怒","author":"XCC","url":"http://blog.iamxcc.com"},"pages":[{"title":"","date":"2016-08-05T13:57:53.778Z","updated":"2016-08-05T13:57:53.778Z","comments":true,"path":"baidu_verify_8J7kG66Rha.html","permalink":"http://blog.iamxcc.com/baidu_verify_8J7kG66Rha.html","excerpt":"","text":"8J7kG66Rha"},{"title":"404","date":"2016-08-09T09:05:24.586Z","updated":"2016-08-09T09:05:24.586Z","comments":true,"path":"404.html","permalink":"http://blog.iamxcc.com/404.html","excerpt":"","text":""},{"title":"","date":"2016-06-21T02:03:29.832Z","updated":"2016-05-17T23:30:47.000Z","comments":true,"path":"google46447695f1c84c21.html","permalink":"http://blog.iamxcc.com/google46447695f1c84c21.html","excerpt":"","text":"google-site-verification: google46447695f1c84c21.html"},{"title":"About","date":"2016-08-07T23:55:06.007Z","updated":"2016-08-07T23:55:06.007Z","comments":true,"path":"about/index.html","permalink":"http://blog.iamxcc.com/about/index.html","excerpt":"","text":"The blog theme you may fall in love with, coming to Hexo. Preview InstallationInstall1$ git clone https://github.com/ppoffice/hexo-theme-icarus.git themes/icarus Icarus requires Hexo 3.0 and above. Enable Rename themes\\icarus\\_config.yml.example to themes\\icarus\\_config.yml; Copy themes\\icarus\\_config.yml.site.example to your hexo blog’s root directory and rename it to _config.yml; Copy themes\\icarus\\_source\\* into your hexo blog’s directory source; Then modify theme setting in _config.yml to icarus. Update12cd themes/icarusgit pull ConfigurationTheme configuration example1234567891011121314151617181920212223242526272829303132333435363738394041# Headermenu: Home: . Archives: archives Categories: categories # you need to add extra page to enable this, please see the config below. Tags: tags # you need to add extra page to enable this, please see the config below. About: about# Contentexcerpt_link: Read Morefancybox: true# Sidebarsidebar: rightwidgets:- recent_posts- category- tag- tagcloud- archivethumbnail: true# Contactscontacts: github: http://github.com/ppoffice/hexo-theme-icarus twitter: '#' facebook: '#' dribbble: '#' rss: atom.xml# Linkslinks: Hexo: http://hexo.io# Miscellaneousgoogle_analytics:favicon: favicon.pngtwitter:google_plus:fb_admins:fb_app_id: excerpt_link - Cooperate with &lt;!-- more --&gt; tag to show only part of the article in index pages. fancybox - Enable Fancybox. contacts - Your social network links, RSS link, etc. widgets - Widgets displaying in sidebar. thumbnail - Whether to show post thumbnails in the sidebar and archive pages. links - Links displayed in the link widget. google_analytics - Google Analytics ID. favicon - Favicon path. Site configuration example123456789101112131415# Sitetitle: Icarussubtitle:description: Hexo theme - Icarusauthor: PPOfficeauthor_title: 'Web Developer &amp; Designer'avatar: css/images/avatar.pnglocation: 'Harbin, China'language: entimezone:...# Disqusdisqus_shortname: author - Your name. author_title - Title to your occupation. avatar - Your avatar image link. location - Where you live in. disqus_shortname - Your Disqus shortname. Post Thumbnail &amp; BannerYou can add a thumbnail and a banner to each post by adding the following lines into your post source files’ front-matter:123456title: Demodate: 2015-01-01...# add thosethumbnail: http://example.com/thumbnail.jpgbanner: http://example.com/banner.jpg Custom Categories &amp; Tags PagesTo enable custom categories page and tags page, just copy the categories folder and tags folder under your theme’s _source foler into your site’s source folder. Then edit theme’s _config.yml and add the following lines:123456# Headermenu: ... Categories: categories # -&gt; add this line Tags: tags # -&gt; and add this line ... LanguagesEnglish and Simplified Chinese are the default languages of the theme. You can add translations in the languages folder and change the default language in blog’s _config.yml. 1language: zh-CN FeaturesProfile SidebarA nice place to show yourself. You can add your own information in your site’s _config.yml Post Banner &amp; ThumbnailThanks to atika, you can now add thumbnails and banners to every post to create better reading experience. Responsive LayoutIcarus knows on what screen size you are browsering the website, and reorganize the layout to fit your device. Custom Categories &amp; Tags PagesGet your categories and tags listed in single pages to make your blog more methodic. FancyboxIcarus uses Fancybox to showcase your photos. You can use Markdown syntax or fancybox tag plugin to add your photos. 1![img caption](img url) SidebarIcarus provides 6 built-in widgets: recent_posts category archives tag tagcloud links All of them are enabled by default. You can edit them in widget setting. DevelopmentRequirements Grunt 0.4+ Hexo 3.0+ Grunt tasks default - Download Fancybox and Font Awesome. fontawesome - Only download Font Awesome. fancybox - Only download Fancybox. clean - Clean temporarily files and downloaded files."},{"title":"分类","date":"2016-08-04T11:10:57.697Z","updated":"2016-08-04T11:10:57.697Z","comments":true,"path":"categories/index.html","permalink":"http://blog.iamxcc.com/categories/index.html","excerpt":"","text":""},{"title":"search","date":"2016-07-26T15:35:55.179Z","updated":"2016-05-16T06:06:40.000Z","comments":true,"path":"search/index.html","permalink":"http://blog.iamxcc.com/search/index.html","excerpt":"","text":""},{"title":"标签","date":"2016-08-04T11:11:07.073Z","updated":"2016-08-04T11:11:07.073Z","comments":true,"path":"tags/index.html","permalink":"http://blog.iamxcc.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"LeetCode 121: Best Time to Buy and Sell Stock I, II, III","slug":"LeetCode-121-Best-Time-to-Buy-and-Sell-Stock-I-II-III","date":"2016-08-11T05:56:26.000Z","updated":"2016-08-11T06:49:30.772Z","comments":true,"path":"2016/08/11/LeetCode-121-Best-Time-to-Buy-and-Sell-Stock-I-II-III/","link":"","permalink":"http://blog.iamxcc.com/2016/08/11/LeetCode-121-Best-Time-to-Buy-and-Sell-Stock-I-II-III/","excerpt":"Say you have an array for which the ith element is the price of a given stock on day i.If you were only permitted to complete at most one transaction","text":"Say you have an array for which the ith element is the price of a given stock on day i.If you were only permitted to complete at most one transaction (ie, buy one and sell one share of the stock), design an algorithm to find the maximum profit. Example 1: Input: [7, 1, 5, 3, 6, 4]Output: 5max. difference = 6-1 = 5 (not 7-1 = 6, as selling price needs to be larger than buying price) Example 2: Input: [7, 6, 4, 3, 1]Output: 0In this case, no transaction is done, i.e. max profit = 0. Code123456789101112int maxProfit(int* prices, int pricesSize) &#123; int low = prices[0]; int profit = 0; for (int i = 0; i &lt; pricesSize; i++) &#123; if (low &gt; prices[i]) &#123; low = prices[i]; &#125; else if (prices[i] - low &gt; profit) &#123; profit = prices[i] - low; &#125; &#125; return profit;&#125; Best Time to Buy and Sell Stock IISay you have an array for which the ith element is the price of a given stock on day i. Design an algorithm to find the maximum profit. You may complete as many transactions as you like (ie, buy one and sell one share of the stock multiple times). However, you may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).12345678910111213int maxProfit(int* prices, int pricesSize) &#123; int low = prices[0]; int profit = 0; for (int i = 0; i &lt; pricesSize; i++) &#123; if (low &gt; prices[i]) &#123; low = prices[i]; &#125; else &#123; profit = profit + prices[i] - low; low = prices[i]; &#125; &#125; return profit;&#125; Best Time to Buy and Sell Stock IIISay you have an array for which the ith element is the price of a given stock on day i. Design an algorithm to find the maximum profit. You may complete at most two transactions. Note:You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).12345678910111213141516171819202122232425262728293031323334int maxProfit(int* prices, int pricesSize) &#123; int maxProfit[pricesSize]; int maxRevealProfit[pricesSize]; maxProfit[0] = 0; maxRevealProfit[pricesSize - 1] = 0; int low = prices[0]; int profit = 0; for (int i = 0; i &lt; pricesSize; i++) &#123; if (low &gt; prices[i]) &#123; low = prices[i]; &#125; else if (prices[i] - low &gt; profit) &#123; profit = prices[i] - low; &#125; maxProfit[i] = profit; &#125; profit = 0; int high = prices[pricesSize - 1]; for (int i = pricesSize - 2; i &gt;= 0; i--) &#123; if (high &lt; prices[i]) &#123; high = prices[i]; &#125; else if (profit &lt; high - prices[i])&#123; profit = high - prices[i]; &#125; maxRevealProfit[i] = profit; &#125; int res = 0; for(int i = 0; i &lt; pricesSize; i++)&#123; int tmp = maxProfit[i] + maxRevealProfit[i]; if(res &lt; tmp) &#123; res = tmp; &#125; &#125; return res;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.iamxcc.com/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.iamxcc.com/tags/LeetCode/"},{"name":"Dynamic Programming","slug":"Dynamic-Programming","permalink":"http://blog.iamxcc.com/tags/Dynamic-Programming/"}]},{"title":"LeetCode 287: Find the Duplicate Number","slug":"LeetCode-287-Find-the-Duplicate-Number","date":"2016-08-11T03:40:43.000Z","updated":"2016-08-11T05:59:02.807Z","comments":true,"path":"2016/08/11/LeetCode-287-Find-the-Duplicate-Number/","link":"","permalink":"http://blog.iamxcc.com/2016/08/11/LeetCode-287-Find-the-Duplicate-Number/","excerpt":"Given an array nums containing n + 1 integers where each integer is between 1 and n (inclusive), prove that at least one duplicate number must exist.","text":"Given an array nums containing n + 1 integers where each integer is between 1 and n (inclusive), prove that at least one duplicate number must exist. Assume that there is only one duplicate number, find the duplicate one. Note: You must not modify the array (assume the array is read only). You must use only constant, O(1) extra space. Your runtime complexity should be less than O(n2). There is only one duplicate number in the array, but it could be repeated more than once. Code二分法实际上，我们可以根据抽屉原理简化刚才的暴力法。我们不一定要依次选择数，然后看是否有这个数的重复数，我们可以用二分法先选取n/2，按照抽屉原理，整个数组中如果小于等于n/2的数的数量大于n/2，说明1到n/2这个区间是肯定有重复数字的。比如6个抽屉，如果有7个袜子要放到抽屉里，那肯定有一个抽屉至少两个袜子。这里抽屉就是1到n/2的每一个数，而袜子就是整个数组中小于等于n/2的那些数。这样我们就能知道下次选择的数的范围，如果1到n/2区间内肯定有重复数字，则下次在1到n/2范围内找，否则在n/2到n范围内找。下次找的时候，还是找一半。123456789101112131415161718192021int findDuplicate(int* nums, int numsSize) &#123; int minValue = 1; int maxValue = numsSize - 1; int mid = 0; int count = 0; while(minValue &lt; maxValue) &#123; mid = (maxValue + minValue) / 2; for (int i = 0; i&lt; numsSize; i++) &#123; if (nums[i] &lt;= mid) &#123; count++; &#125; &#125; if (count &gt; mid) &#123; maxValue = mid; &#125; else &#123; minValue = mid + 1; &#125; count = 0; &#125; return minValue;&#125; 映射找环法假设数组中没有重复，那我们可以做到这么一点，就是将数组的下标和1到n每一个数一对一的映射起来。比如数组是213,则映射关系为0-&gt;2, 1-&gt;1, 2-&gt;3。假设这个一对一映射关系是一个函数f(n)，其中n是下标，f(n)是映射到的数。如果我们从下标为0出发，根据这个函数计算出一个值，以这个值为新的下标，再用这个函数计算，以此类推，直到下标超界。实际上可以产生一个类似链表一样的序列。比如在这个例子中有两个下标的序列，0-&gt;2-&gt;3。 但如果有重复的话，这中间就会产生多对一的映射，比如数组2131,则映射关系为0-&gt;2, {1，3}-&gt;1, 2-&gt;3。这样，我们推演的序列就一定会有环路了，这里下标的序列是0-&gt;2-&gt;3-&gt;1-&gt;1-&gt;1-&gt;1-&gt;…，而环的起点就是重复的数。 所以该题实际上就是找环路起点的题，和Linked List Cycle II一样。我们先用快慢两个下标都从0开始，快下标每轮映射两次，慢下标每轮映射一次，直到两个下标再次相同。这时候保持慢下标位置不变，再用一个新的下标从0开始，这两个下标都继续每轮映射一次，当这两个下标相遇时，就是环的起点，也就是重复的数。对这个找环起点算法不懂的，请参考Floyd’s Algorithm。123456789101112131415161718public class Solution &#123; public int findDuplicate(int[] nums) &#123; int slow = 0; int fast = 0; // 找到快慢指针相遇的地方 do&#123; slow = nums[slow]; fast = nums[nums[fast]]; &#125; while(slow != fast); int find = 0; // 用一个新指针从头开始，直到和慢指针相遇 while(find != slow)&#123; slow = nums[slow]; find = nums[find]; &#125; return find; &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.iamxcc.com/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.iamxcc.com/tags/LeetCode/"},{"name":"Array","slug":"Array","permalink":"http://blog.iamxcc.com/tags/Array/"}]},{"title":"LeetCode 100: Same Tree","slug":"LeetCode-100-Same-Tree","date":"2016-08-11T01:21:44.000Z","updated":"2016-08-11T01:25:25.602Z","comments":true,"path":"2016/08/11/LeetCode-100-Same-Tree/","link":"","permalink":"http://blog.iamxcc.com/2016/08/11/LeetCode-100-Same-Tree/","excerpt":"Given two binary trees, write a function to check if they are equal or not. Two binary trees are considered equal if they are structurally identical and the nodes have the same value.","text":"Given two binary trees, write a function to check if they are equal or not. Two binary trees are considered equal if they are structurally identical and the nodes have the same value. Code1234567891011121314151617181920/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * struct TreeNode *left; * struct TreeNode *right; * &#125;; */bool isSameTree(struct TreeNode* p, struct TreeNode* q) &#123; if (p == NULL &amp;&amp; q == NULL) &#123; return 1; &#125; else if (p == NULL || q == NULL) &#123; return 0; &#125; else &#123; if (p -&gt; val == q -&gt; val) &#123; return isSameTree(p -&gt; left, q -&gt; left) &amp;&amp; isSameTree(p -&gt; right, q -&gt; right); &#125; return 0; &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.iamxcc.com/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.iamxcc.com/tags/LeetCode/"},{"name":"Tree","slug":"Tree","permalink":"http://blog.iamxcc.com/tags/Tree/"}]},{"title":"PAT(Basic Level) 1001: 害死人不偿命的(3n+1)猜想","slug":"PAT-Basic-Level-1001-害死人不偿命的-3n-1-猜想","date":"2016-08-10T12:05:49.000Z","updated":"2016-08-10T15:39:58.142Z","comments":true,"path":"2016/08/10/PAT-Basic-Level-1001-害死人不偿命的-3n-1-猜想/","link":"","permalink":"http://blog.iamxcc.com/2016/08/10/PAT-Basic-Level-1001-害死人不偿命的-3n-1-猜想/","excerpt":"卡拉兹(Callatz)猜想：对任何一个自然数n，如果它是偶数，那么把它砍掉一半；如果它是奇数，那么把(3n+1)砍掉一半。","text":"卡拉兹(Callatz)猜想：对任何一个自然数n，如果它是偶数，那么把它砍掉一半；如果它是奇数，那么把(3n+1)砍掉一半。 这样一直反复砍下去，最后一定在某一步得到n=1。卡拉兹在1950年的世界数学家大会上公布了这个猜想，传说当时耶鲁大学师生齐动员，拼命想证明这个貌似很傻很天真的命题，结果闹得学生们无心学业，一心只证(3n+1)，以至于有人说这是一个阴谋，卡拉兹是在蓄意延缓美国数学界教学与科研的进展…… 我们今天的题目不是证明卡拉兹猜想，而是对给定的任一不超过1000的正整数n，简单地数一下，需要多少步（砍几下）才能得到n=1？ 输入格式：每个测试输入包含1个测试用例，即给出自然数n的值。 输出格式：输出从n计算到1需要的步数。 输入样例：3输出样例：5 code1234567891011121314151617181920212223#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;limits.h&gt;#include &lt;math.h&gt;int main() &#123; int num = 0; int count = 0; scanf(\"%d\", &amp;num); if (num == 0) &#123; return 0; &#125; while (num != 1) &#123; if (num % 2 == 0) &#123; num /= 2; count++; &#125; else &#123; num = (num * 3 + 1) / 2; count++; &#125; &#125; printf(\"%d/n\", count); return 0;&#125;","categories":[{"name":"PAT","slug":"PAT","permalink":"http://blog.iamxcc.com/categories/PAT/"}],"tags":[{"name":"PAT","slug":"PAT","permalink":"http://blog.iamxcc.com/tags/PAT/"}]},{"title":"L1-002: 打印沙漏","slug":"L1-002-打印沙漏","date":"2016-08-10T11:00:27.000Z","updated":"2016-08-10T14:19:24.680Z","comments":true,"path":"2016/08/10/L1-002-打印沙漏/","link":"","permalink":"http://blog.iamxcc.com/2016/08/10/L1-002-打印沙漏/","excerpt":"本题要求你写个程序把给定的符号打印成沙漏的形状。例如给定17个“*”，要求按下列格式打印","text":"本题要求你写个程序把给定的符号打印成沙漏的形状。例如给定17个“*”，要求按下列格式打印 12345***** *** * ******** 所谓“沙漏形状”，是指每行输出奇数个符号；各行符号中心对齐；相邻两行符号数差2；符号数先从大到小顺序递减到1，再从小到大顺序递增；首尾符号数相等。 给定任意N个符号，不一定能正好组成一个沙漏。要求打印出的沙漏能用掉尽可能多的符号。 输入格式： 输入在一行给出1个正整数N（&lt;=1000）和一个符号，中间以空格分隔。 输出格式： 首先打印出由给定符号组成的最大的沙漏形状，最后在一行中输出剩下没用掉的符号数。123456789输入样例：19 *输出样例：***** *** * ********2 代码1234567891011121314151617181920212223242526272829303132#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;limits.h&gt;#include &lt;math.h&gt;int main() &#123; int num = 0; char symbol; int max = 0; int times = 0; scanf(\"%d %c\", &amp;num, &amp;symbol); max = sqrt(2*(num + 1)) - 1; max = (max % 2) == 0 ? max - 1 : max; for (int i = 0; i &lt; max; i++) &#123; for (int j = 0; j &lt; max; j++) &#123; int temp = i &gt; max / 2 ? (max - i - 1) : i; if (temp &lt;= j &amp;&amp; j &lt;= max - 1 - temp) &#123; printf(\"%c\", symbol); &#125; else if (j &gt; max - 1 - temp) &#123; break; &#125; else &#123; printf(\" \"); &#125; &#125; printf(\"\\n\"); &#125; int left = pow((max + 1), 2) / 2 - 1; left = left &gt; 0 ? left : 0; printf(\"%d\\n\", num - left); return 0;&#125;","categories":[{"name":"PAT","slug":"PAT","permalink":"http://blog.iamxcc.com/categories/PAT/"}],"tags":[{"name":"PAT","slug":"PAT","permalink":"http://blog.iamxcc.com/tags/PAT/"}]},{"title":"LeetCode 349: Intersection of Two Arrays","slug":"LeetCode-349-Intersection-of-Two-Arrays","date":"2016-08-10T05:25:50.000Z","updated":"2016-08-10T14:18:47.912Z","comments":true,"path":"2016/08/10/LeetCode-349-Intersection-of-Two-Arrays/","link":"","permalink":"http://blog.iamxcc.com/2016/08/10/LeetCode-349-Intersection-of-Two-Arrays/","excerpt":"Given two arrays, write a function to compute their intersection.","text":"Given two arrays, write a function to compute their intersection. Example:Given nums1 = [1, 2, 2, 1], nums2 = [2, 2], return [2]. Note:Each element in the result must be unique.The result can be in any order. 代码12345678910111213141516171819202122232425262728int cmp(const int *a, const int *b) &#123; return *a - *b;&#125;/** * Return an array of size *returnSize. * Note: The returned array must be malloced, assume caller calls free(). */int* intersection(int* nums1, int nums1Size, int* nums2, int nums2Size, int* returnSize) &#123; qsort(nums1,nums1Size,sizeof(int),cmp); qsort(nums2,nums2Size,sizeof(int),cmp); int size = nums1Size &lt; nums2Size ? nums1Size : nums2Size; int* arr = (int*)malloc(sizeof(int)*size); //the size of the result will at most be size; int top = -1; int p1=0, p2=0; while(p1&lt;nums1Size &amp;&amp; p2&lt;nums2Size) &#123; if(nums1[p1] &gt; nums2[p2]) p2++; else if(nums1[p1] &lt; nums2[p2]) p1++; else //only collect the equal one; &#123; if(top==-1 || arr[top]!=nums1[p1]) //avoid duplicates; arr[++top] = nums1[p1]; p1++, p2++; &#125; &#125; *returnSize = top+1; return arr;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.iamxcc.com/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.iamxcc.com/tags/LeetCode/"},{"name":"Sort","slug":"Sort","permalink":"http://blog.iamxcc.com/tags/Sort/"}]},{"title":"LeetCode 242: Valid Anagram","slug":"LeetCode-242-Valid-Anagram","date":"2016-08-10T05:08:47.000Z","updated":"2016-08-10T14:19:08.593Z","comments":true,"path":"2016/08/10/LeetCode-242-Valid-Anagram/","link":"","permalink":"http://blog.iamxcc.com/2016/08/10/LeetCode-242-Valid-Anagram/","excerpt":"Given two strings s and t, write a function to determine if t is an anagram of s.","text":"Given two strings s and t, write a function to determine if t is an anagram of s. For example,s = “anagram”, t = “nagaram”, return true.s = “rat”, t = “car”, return false. Note:You may assume the string contains only lowercase alphabets. 代码123456789101112131415161718int cmp(const char *a, const char *b) &#123; return *a - *b;&#125;bool isAnagram(char* s, char* t) &#123; int lenS = strlen(s); int lenT = strlen(t); if (lenS != lenT) &#123; return false; &#125; qsort(s, lenS, sizeof(char), cmp); qsort(t, lenT, sizeof(char), cmp); for (int i = 0; i &lt; lenS; i++) &#123; if (s[i] != t[i]) &#123; return false; &#125; &#125; return true;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.iamxcc.com/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.iamxcc.com/tags/LeetCode/"},{"name":"Sort","slug":"Sort","permalink":"http://blog.iamxcc.com/tags/Sort/"}]},{"title":"LeetCode 191: Number of 1 Bits","slug":"LeetCode-191-Number-of-1-Bits","date":"2016-08-10T03:42:49.000Z","updated":"2016-08-10T03:43:36.392Z","comments":true,"path":"2016/08/10/LeetCode-191-Number-of-1-Bits/","link":"","permalink":"http://blog.iamxcc.com/2016/08/10/LeetCode-191-Number-of-1-Bits/","excerpt":"Write a function that takes an unsigned integer and returns the number of ’1’ bits it has (also known as the Hamming weight).","text":"Write a function that takes an unsigned integer and returns the number of ’1’ bits it has (also known as the Hamming weight). For example, the 32-bit integer ’11’ has binary representation 00000000000000000000000000001011, so the function should return 3. 代码12345678int hammingWeight(uint32_t n) &#123; int nums = 0; while ( n != 0) &#123; nums = nums + (n &amp; 1); n = n &gt;&gt; 1; &#125; return nums;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.iamxcc.com/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.iamxcc.com/tags/LeetCode/"},{"name":"Bit Manipulation","slug":"Bit-Manipulation","permalink":"http://blog.iamxcc.com/tags/Bit-Manipulation/"}]},{"title":"LeetCode 338: Counting Bits","slug":"LeetCode-338-Counting-Bits","date":"2016-08-10T03:23:44.000Z","updated":"2016-08-10T03:28:18.920Z","comments":true,"path":"2016/08/10/LeetCode-338-Counting-Bits/","link":"","permalink":"http://blog.iamxcc.com/2016/08/10/LeetCode-338-Counting-Bits/","excerpt":"Given a non negative integer number num. For every numbers i in the range 0 ≤ i ≤ num calculate the number of 1’s in their binary representation and return them as an array.","text":"Given a non negative integer number num. For every numbers i in the range 0 ≤ i ≤ num calculate the number of 1’s in their binary representation and return them as an array. Example:For num = 5 you should return [0,1,1,2,1,2]. Follow up: It is very easy to come up with a solution with run time O(n*sizeof(integer)). But can you do it in linear time O(n) /possibly in a single pass?Space complexity should be O(n).Can you do it like a boss? Do it without using any builtin function like __builtin_popcount in c++ or in any other language. 代码12345678910111213/** * Return an array of size *returnSize. * Note: The returned array must be malloced, assume caller calls free(). */int* countBits(int num, int* returnSize) &#123; int* res = (int*)malloc((num+1)*sizeof(int)); res[0] = 0; for (int i = 1; i &lt;= num; i++ ) &#123; res[i] = res[i&gt;&gt;1] + (i &amp; 1); &#125; *returnSize = num + 1; return res;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.iamxcc.com/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.iamxcc.com/tags/LeetCode/"},{"name":"Bit Manipulation","slug":"Bit-Manipulation","permalink":"http://blog.iamxcc.com/tags/Bit-Manipulation/"}]},{"title":"LeetCode 342: Power of Four","slug":"LeetCode-342-Power-of-Four","date":"2016-08-10T02:56:19.000Z","updated":"2016-08-10T03:03:48.001Z","comments":true,"path":"2016/08/10/LeetCode-342-Power-of-Four/","link":"","permalink":"http://blog.iamxcc.com/2016/08/10/LeetCode-342-Power-of-Four/","excerpt":"Given an integer (signed 32 bits), write a function to check whether it is a power of 4.","text":"Given an integer (signed 32 bits), write a function to check whether it is a power of 4. Example:Given num = 16, return true. Given num = 5, return false.Follow up: Could you solve it without loops/recursion? 思路首先我们可以列出4, 16, 64, 256这几个数的二进制来看一下规律，发现它们都是在偶数位为1，而且只有一位是1，其余位都是0。有了上面这个规律我们就可以结题了。首先，筛选只有一位是1，其余位是0的数，使用num &amp; (num-1)即可。再使用0x55555555与num作位与操作&amp;即可发现，不是我们所要的数经过这步后都是0。到此我们就可以判断出结果了。 代码123bool isPowerOfFour(int num) &#123; return num &gt; 0 &amp;&amp; (num&amp;(num-1)) == 0 &amp;&amp; (num &amp; 0x55555555) != 0;&#125; 1060 / 1060 test cases passed.Status: AcceptedRuntime: 4 ms","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.iamxcc.com/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.iamxcc.com/tags/LeetCode/"},{"name":"Bit Manipulation","slug":"Bit-Manipulation","permalink":"http://blog.iamxcc.com/tags/Bit-Manipulation/"}]},{"title":"Chrome52中Mactype无效怎么回退版本","slug":"Chrome52中Mactype无效怎么回退版本","date":"2016-08-10T02:18:59.000Z","updated":"2016-08-10T02:28:44.914Z","comments":true,"path":"2016/08/10/Chrome52中Mactype无效怎么回退版本/","link":"","permalink":"http://blog.iamxcc.com/2016/08/10/Chrome52中Mactype无效怎么回退版本/","excerpt":"今天在chrome自动更新到523版本后，突然被chrome上显示的字体吓了一下，还以为什么坏了。后来才发现是mactype无效了，因为Chrome52后禁用DirectWrite渲染的选项已经没有了。","text":"今天在chrome自动更新到523版本后，突然被chrome上显示的字体吓了一下，还以为什么坏了。后来才发现是mactype无效了，因为Chrome52后禁用DirectWrite渲染的选项已经没有了。 没有办法只能去找各种各样的解决办法，先是试了stylish的方式，效果不明显。后来又去找mactype有没有新的版本。一直折腾了好久后，终于下定决心把chrome回退到上一个版本。 可是怎么回退呢？卸载掉再重新装吗？答案是不用这么麻烦。下面是解决办法，来自知乎 Dorawei：C:\\Program Files (x86)\\Google\\Chrome\\Temp\\ 下的一个文件夹中有old_chrome.exe，把它复制到C:\\Program Files (x86)\\Google\\Chrome\\Application 中改为 chrome.exe 就可以返回上一版了。","categories":[{"name":"Mactype","slug":"Mactype","permalink":"http://blog.iamxcc.com/categories/Mactype/"}],"tags":[{"name":"Mactype","slug":"Mactype","permalink":"http://blog.iamxcc.com/tags/Mactype/"},{"name":"Chrome","slug":"Chrome","permalink":"http://blog.iamxcc.com/tags/Chrome/"},{"name":"Win10","slug":"Win10","permalink":"http://blog.iamxcc.com/tags/Win10/"}]},{"title":"LeetCode 258: Add Digits","slug":"LeetCode-258-Add-Digits","date":"2016-08-09T02:42:38.000Z","updated":"2016-08-09T02:43:23.378Z","comments":true,"path":"2016/08/09/LeetCode-258-Add-Digits/","link":"","permalink":"http://blog.iamxcc.com/2016/08/09/LeetCode-258-Add-Digits/","excerpt":"Given a non-negative integer num, repeatedly add all its digits until the result has only one digit.","text":"Given a non-negative integer num, repeatedly add all its digits until the result has only one digit. For example:Given num = 38, the process is like: 3 + 8 = 11, 1 + 1 = 2. Since 2 has only one digit, return it. 代码1234int addDigits(int num) &#123; int res = num % 9; return (res != 0 || num == 0) ? res : 9;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.iamxcc.com/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.iamxcc.com/tags/LeetCode/"},{"name":"Math","slug":"Math","permalink":"http://blog.iamxcc.com/tags/Math/"}]},{"title":"LeetCode 69: Sqrt(x)","slug":"LeetCode-69-Sqrt-x","date":"2016-08-09T02:08:51.000Z","updated":"2016-08-09T02:29:46.675Z","comments":true,"path":"2016/08/09/LeetCode-69-Sqrt-x/","link":"","permalink":"http://blog.iamxcc.com/2016/08/09/LeetCode-69-Sqrt-x/","excerpt":"Implement int sqrt(int x). Compute and return the square root of x.","text":"Implement int sqrt(int x). Compute and return the square root of x. 思路这里使用的方法是：牛顿迭代法快速寻找平方根。如果想详细了解，可以看看这篇文章一个Sqrt函数引发的血案 一个Sqrt函数引发的血案 代码123456int mySqrt(int x) &#123; long r = x; while (r*r &gt; x) r = (r + x/r) / 2; return r;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.iamxcc.com/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.iamxcc.com/tags/LeetCode/"},{"name":"Math","slug":"Math","permalink":"http://blog.iamxcc.com/tags/Math/"}]},{"title":"LeetCode 50: Pow(x, n)","slug":"LeetCode-50-Pow-x-n","date":"2016-08-09T01:57:20.000Z","updated":"2016-08-09T01:58:36.776Z","comments":true,"path":"2016/08/09/LeetCode-50-Pow-x-n/","link":"","permalink":"http://blog.iamxcc.com/2016/08/09/LeetCode-50-Pow-x-n/","excerpt":"Implement pow(x, n).","text":"Implement pow(x, n). 代码1234567891011121314151617181920212223242526double myPow(double x, int n) &#123; double res = 1; double flag = x; int m = n; if (n &lt; 0) &#123; x = 1 / x; if (n == INT_MIN) &#123; n = INT_MAX; &#125; else &#123; n = -n; &#125; &#125; while (n&gt;0) &#123; if (n &amp; 1 == 1) &#123; res = res*x; &#125; x *= x; n = n &gt;&gt; 1; &#125; if (m == INT_MIN) &#123; if (flag &lt; 0) &#123; return -res; &#125; &#125; return res;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.iamxcc.com/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.iamxcc.com/tags/LeetCode/"},{"name":"Math","slug":"Math","permalink":"http://blog.iamxcc.com/tags/Math/"}]},{"title":"LeetCode 7: Reverse integer","slug":"LeetCode-7-Reverse-integer","date":"2016-08-09T00:37:40.000Z","updated":"2016-08-09T01:57:58.832Z","comments":true,"path":"2016/08/09/LeetCode-7-Reverse-integer/","link":"","permalink":"http://blog.iamxcc.com/2016/08/09/LeetCode-7-Reverse-integer/","excerpt":"Reverse digits of an integer. Example1: x = 123, return 321 Example2: x = -123, return -321.","text":"Reverse digits of an integer. Example1: x = 123, return 321 Example2: x = -123, return -321. 代码1234567891011int reverse(int x) &#123; int res = 0; while (x != 0) &#123; if (res &gt; INT_MAX/10 ||res &lt; INT_MIN/10) &#123; return 0; &#125; res = x % 10 + res * 10; x /= 10; &#125; return res;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.iamxcc.com/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.iamxcc.com/tags/LeetCode/"},{"name":"Math","slug":"Math","permalink":"http://blog.iamxcc.com/tags/Math/"}]},{"title":"LeetCode 12: Integer to Roman","slug":"LeetCode-12-Integer-to-Roman","date":"2016-08-09T00:18:43.000Z","updated":"2016-08-09T06:23:15.703Z","comments":true,"path":"2016/08/09/LeetCode-12-Integer-to-Roman/","link":"","permalink":"http://blog.iamxcc.com/2016/08/09/LeetCode-12-Integer-to-Roman/","excerpt":"Given an integer, convert it to a roman numeral. Input is guaranteed to be within the range from 1 to 3999.","text":"Given an integer, convert it to a roman numeral. Input is guaranteed to be within the range from 1 to 3999. 代码1234567891011121314char* intToRoman(int num) &#123; char *str = (char *)malloc(100); memset(str,0,100); char *strM[] = &#123; \"\", \"M\", \"MM\", \"MMM\" &#125;; char *strC[] = &#123; \"\", \"C\", \"CC\", \"CCC\", \"CD\", \"D\", \"DC\", \"DCC\", \"DCCC\", \"CM\" &#125;; char *strX[] = &#123; \"\", \"X\", \"XX\", \"XXX\", \"XL\", \"L\", \"LX\", \"LXX\", \"LXXX\", \"XC\" &#125;; char *strI[] = &#123; \"\", \"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\" &#125;; strcpy(str, strM[num / 1000]); strcat(str, strC[(num % 1000) / 100]); strcat(str, strX[(num % 100) / 10]); strcat(str, strI[num % 10]); return str;&#125;// 这里不太明白char str[100] = &#123;0&#125; 为什么不行","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.iamxcc.com/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.iamxcc.com/tags/LeetCode/"},{"name":"Math","slug":"Math","permalink":"http://blog.iamxcc.com/tags/Math/"}]},{"title":"LeetCode 319: Bulb Switcher","slug":"LeetCode-319-Bulb-Switcher","date":"2016-08-08T08:15:41.000Z","updated":"2016-08-08T08:52:14.614Z","comments":true,"path":"2016/08/08/LeetCode-319-Bulb-Switcher/","link":"","permalink":"http://blog.iamxcc.com/2016/08/08/LeetCode-319-Bulb-Switcher/","excerpt":"There are n bulbs that are initially off. You first turn on all the bulbs. Then, you turn off every second bulb.","text":"There are n bulbs that are initially off. You first turn on all the bulbs. Then, you turn off every second bulb. On the third round, you toggle every third bulb (turning on if it’s off or turning off if it’s on). For the ith round, you toggle every i bulb. For the nth round, you only toggle the last bulb. Find how many bulbs are on after n rounds. Example: Given n = 3.At first, the three bulbs are [off, off, off].After first round, the three bulbs are [on, on, on].After second round, the three bulbs are [on, off, on].After third round, the three bulbs are [on, off, off].So you should return 1, because there is only one bulb is on. 思路用数学的方法来思考这道题，会发现很简单。首先，决定一盏灯最后的亮灭取决于她所处在的序号。比如，6号灯最后一定是灭的，为什么呢？因为在n次操作中，只有她的因数次才能切换她的亮灭，比如第1次、第2次、第3次、第6次操作，又第1次是开，那么低6次后，她就灭了。所以要想亮，那么这个数要为有奇数个因数的数才行，而我们知道只有能开平方的数，有奇数个因数，因为她有一个不是成对出现的因数。所以要知道最后有几个灯是亮的，只要找到有几个小于n的能开平方数的数即可。而要计算一个数之下有多少小于或等于它的平方数，使用一个开平方用的函数就可以了。 代码123int bulbSwitch(int n) &#123; return sqrt(n);&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.iamxcc.com/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.iamxcc.com/tags/LeetCode/"},{"name":"Math","slug":"Math","permalink":"http://blog.iamxcc.com/tags/Math/"}]},{"title":"LeetCode 9: Palindrome Number","slug":"LeetCode-9-Palindrome-Number","date":"2016-08-08T07:52:04.000Z","updated":"2016-08-08T07:54:48.313Z","comments":true,"path":"2016/08/08/LeetCode-9-Palindrome-Number/","link":"","permalink":"http://blog.iamxcc.com/2016/08/08/LeetCode-9-Palindrome-Number/","excerpt":"Determine whether an integer is a palindrome. Do this without extra space.","text":"Determine whether an integer is a palindrome. Do this without extra space. 代码123456789101112bool isPalindrome(int x) &#123; if (x &lt; 0 || (x!=0 &amp;&amp; x%10==0)) &#123; return false; &#125; int sum = 0; while (x &gt; sum) &#123; sum = sum*10 + x%10; x /= 10; &#125; return (x==sum)||(x==sum/10); &#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.iamxcc.com/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.iamxcc.com/tags/LeetCode/"},{"name":"Math","slug":"Math","permalink":"http://blog.iamxcc.com/tags/Math/"}]},{"title":"LeetCode 231: Power of Two","slug":"LeetCode-231-Power-of-Two","date":"2016-08-08T07:33:15.000Z","updated":"2016-08-08T07:56:22.033Z","comments":true,"path":"2016/08/08/LeetCode-231-Power-of-Two/","link":"","permalink":"http://blog.iamxcc.com/2016/08/08/LeetCode-231-Power-of-Two/","excerpt":"这个题跟Power of Three的思路基本一模一样，解法也差不多。但是因为是2啊，毕竟是计算机的进制数，所以&amp;,|这些位操作总能出奇迹。","text":"这个题跟Power of Three的思路基本一模一样，解法也差不多。但是因为是2啊，毕竟是计算机的进制数，所以&amp;,|这些位操作总能出奇迹。 思路我们可以列几个2的次幂数就可以发现，他们的二进制数的最高位为1，其他位都是0。所以让她与比她小的一个数的数做一下位与&amp;即有结果为0。 代码123bool isPowerOfTwo(int n) &#123; return n &gt; 0 &amp;&amp; !(n &amp; (n - 1));&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.iamxcc.com/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.iamxcc.com/tags/LeetCode/"},{"name":"Math","slug":"Math","permalink":"http://blog.iamxcc.com/tags/Math/"}]},{"title":"LeetCode 326: Power of Three","slug":"LeetCode-326-Power-of-Three","date":"2016-08-08T07:02:06.000Z","updated":"2016-08-08T07:55:28.625Z","comments":true,"path":"2016/08/08/LeetCode-326-Power-of-Three/","link":"","permalink":"http://blog.iamxcc.com/2016/08/08/LeetCode-326-Power-of-Three/","excerpt":"今天突然发现做LeetCode上Math的题目真心很有趣，不仅解法多样，还能时不时被绝妙的想法高潮一波。","text":"今天突然发现做LeetCode上Math的题目真心很有趣，不仅解法多样，还能时不时被绝妙的想法高潮一波。Given an integer, write a function to determine if it is a power of three.Follow up:Could you do it without using any loop / recursion? 思路这道题目因为有int的限制，所以知道3的次幂的数肯定大不过1162261467。 代码123bool isPowerOfThree(int n) &#123; return (n &gt; 0 &amp;&amp; 1162261467 % n == 0);&#125; 利用log实现123bool isPowerOfThree(int n) &#123; return fmod(log10(n)/log10(3), 1)==0;&#125; 题目说明了不可以使用循环或递归：1234// 递归bool isPowerOfThree(int n) &#123; return n&gt;0 &amp;&amp; (n==1 || (n%3==0 &amp;&amp; isPowerOfThree(n/3)));&#125; 123456// 循环bool isPowerOfThree(int n) &#123; if(n&gt;1) while(n%3==0) n /= 3; return n==1;&#125; 21038 / 21038 test cases passed.Status: AcceptedRuntime: 120 ms","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.iamxcc.com/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.iamxcc.com/tags/LeetCode/"},{"name":"Math","slug":"Math","permalink":"http://blog.iamxcc.com/tags/Math/"}]},{"title":"LeetCode 232: Implement Queue using Stacks","slug":"LeetCode-232-Implement-Queue-using-Stacks","date":"2016-08-08T05:31:50.000Z","updated":"2016-08-08T07:54:08.585Z","comments":true,"path":"2016/08/08/LeetCode-232-Implement-Queue-using-Stacks/","link":"","permalink":"http://blog.iamxcc.com/2016/08/08/LeetCode-232-Implement-Queue-using-Stacks/","excerpt":"Implement the following operations of a queue using stacks.","text":"Implement the following operations of a queue using stacks. push(x) – Push element x to the back of queue. pop() – Removes the element from in front of queue. peek() – Get the front element. empty() – Return whether the queue is empty. Notes: You must use only standard operations of a stack – which means only push to top, peek/pop from top, size, and is empty operations are valid. Depending on your language, stack may not be supported natively. You may simulate a stack by using a list or deque (double-ended queue), as long as you use only standard operations of a stack. You may assume that all operations are valid (for example, no pop or peek operations will be called on an empty queue). 代码C语言版本： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748typedef struct //using deque to imitate the two stacks operation avoid extra O(N) space wasting;&#123; int *stack; int begin; //begin -&gt; point to the exact first front element; int end; //end -&gt; point to the next element of the last element to be easily indicate the empty case; int maxSize;&#125; Queue;void queueCreate(Queue *queue, int maxSize)&#123; queue-&gt;stack = (int*)malloc(sizeof(int)*maxSize); queue-&gt;begin = 0; queue-&gt;end = 0; queue-&gt;maxSize = maxSize; //record the maxSize for checking;&#125;void queuePush(Queue *queue, int element)&#123; if(queue-&gt;end == queue-&gt;maxSize) //reach its valid end, we have to rearrange the stack; &#123; for(int i = queue-&gt;begin; i &lt; queue-&gt;end; i++) queue-&gt;stack[i-queue-&gt;begin] = queue-&gt;stack[i]; queue-&gt;begin = 0; queue-&gt;end -= queue-&gt;begin; &#125; queue-&gt;stack[queue-&gt;end++] = element;&#125;void queuePop(Queue *queue)&#123; queue-&gt;begin++;&#125;int queuePeek(Queue *queue)&#123; return queue-&gt;stack[queue-&gt;begin];&#125;bool queueEmpty(Queue *queue)&#123; return queue-&gt;begin == queue-&gt;end;&#125;void queueDestroy(Queue *queue)&#123; free(queue-&gt;stack); /*free(queue); this part cannot be executed*/&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.iamxcc.com/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.iamxcc.com/tags/LeetCode/"},{"name":"Stack","slug":"Stack","permalink":"http://blog.iamxcc.com/tags/Stack/"}]},{"title":"LeetCode 20: Valid Parentheses","slug":"LeetCode-20-Valid-Parentheses","date":"2016-08-07T02:58:47.000Z","updated":"2016-08-07T12:42:50.239Z","comments":true,"path":"2016/08/07/LeetCode-20-Valid-Parentheses/","link":"","permalink":"http://blog.iamxcc.com/2016/08/07/LeetCode-20-Valid-Parentheses/","excerpt":"Given a string containing just the characters &#39;(&#39;, &#39;)&#39;, &#39;{&#39;, &#39;}&#39;, &#39;[&#39; and &#39;]&#39;, determine if the input string is valid.","text":"Given a string containing just the characters &#39;(&#39;, &#39;)&#39;, &#39;{&#39;, &#39;}&#39;, &#39;[&#39; and &#39;]&#39;, determine if the input string is valid.The brackets must close in the correct order, &quot;()&quot; and &quot;()[]{}&quot; are all valid but &quot;(]&quot; and &quot;([)]&quot; are not. 思路看到这种括弧匹配问题，我首先想到的就是用stack来实现。 代码123456789101112131415161718class Solution &#123;public: bool isValid(string s) &#123; stack&lt;char&gt; paren; for (char&amp; c : s) &#123; switch (c) &#123; case '(': case '&#123;': case '[': paren.push(c); break; case ')': if (paren.empty() || paren.top()!='(') return false; else paren.pop(); break; case '&#125;': if (paren.empty() || paren.top()!='&#123;') return false; else paren.pop(); break; case ']': if (paren.empty() || paren.top()!='[') return false; else paren.pop(); break; default: ; // pass &#125; &#125; return paren.empty() ; &#125;&#125;; C语言版本：12345678910111213141516171819202122232425262728293031bool isValid(char* s) &#123; int len = strlen(s); if( len%2 != 0 ) &#123; return false; &#125; int limit = len/2; char *stack = malloc(limit+1); int topOfStack = -1; for (int i = 0; i &lt; len; i++) &#123; if(s[i] == '(' || s[i] == '[' || s[i] =='&#123;') &#123; if(topOfStack == limit) &#123; return false; &#125; else &#123; stack[++topOfStack] = s[i]; &#125; &#125;else &#123; if(topOfStack == -1) &#123; return false; &#125; if( (stack[topOfStack] == '(' &amp;&amp; s[i] == ')') || (stack[topOfStack] == '[' &amp;&amp; s[i] == ']') || (stack[topOfStack] == '&#123;' &amp;&amp; s[i] == '&#125;') ) &#123; topOfStack--; &#125; &#125; &#125; return topOfStack == -1;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.iamxcc.com/categories/LeetCode/"},{"name":"算法","slug":"LeetCode/算法","permalink":"http://blog.iamxcc.com/categories/LeetCode/算法/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.iamxcc.com/tags/LeetCode/"},{"name":"String","slug":"String","permalink":"http://blog.iamxcc.com/tags/String/"}]},{"title":"LeetCode 125: Valid Palindrome","slug":"LeetCode-125-Valid-Palindrome","date":"2016-08-07T02:07:53.000Z","updated":"2016-08-07T07:05:12.097Z","comments":true,"path":"2016/08/07/LeetCode-125-Valid-Palindrome/","link":"","permalink":"http://blog.iamxcc.com/2016/08/07/LeetCode-125-Valid-Palindrome/","excerpt":"Given a string, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases.","text":"Given a string, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases. For example,“A man, a plan, a canal: Panama” is a palindrome.“race a car” is not a palindrome. Note:Have you consider that the string might be empty? This is a good question to ask during an interview.For the purpose of this problem, we define empty string as valid palindrome. 思路我的想法是定义一个start指针和end指针，start从头部往尾部移动，end从尾部往头部移动，其中遇到非数字和字母时，要跳过。每次都做一下对比，不同就return 0。否则一直循环下去，如果一路顺利都是匹配的话，那么return 1。 不过有个地方需要注意，匹配是不区分大小写的，所以比较前要先把大写转化为小写。 代码1234567891011121314151617181920212223242526272829303132333435363738394041int isAlphanumeric(char p) &#123; return ('a' &lt;= p &amp;&amp; p &lt;= 'z') || ('A' &lt;= p &amp;&amp; p &lt;= 'Z') || ('0' &lt;= p &amp;&amp; p &lt;= '9');&#125;char lower2Upper(char p) &#123; if ('A' &lt;= p &amp;&amp; p &lt;= 'Z') &#123; return p + 32; &#125; else &#123; return p; &#125;&#125;bool isPalindrome(char* s) &#123; int len = strlen(s); if (len &lt; 2) &#123; return s; &#125; int start = 0; int end = len - 1; while (start &lt; end) &#123; while (!isAlphanumeric(s[start])) &#123; if (start &lt; end) &#123; start++; &#125;else&#123; return 1; &#125; &#125; while (!isAlphanumeric(s[end])) &#123; if (start &lt; end) &#123; end--; &#125;else &#123; return 1; &#125; &#125; if (lower2Upper(s[start]) != lower2Upper(s[end])) &#123; return 0; &#125; start++; end--; &#125; return 1;&#125; 476 / 476 test cases passed.Status: AcceptedRuntime: 4 ms","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.iamxcc.com/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.iamxcc.com/tags/LeetCode/"},{"name":"String","slug":"String","permalink":"http://blog.iamxcc.com/tags/String/"}]},{"title":"趣说KMP算法","slug":"趣说KMP算法","date":"2016-08-06T11:59:24.000Z","updated":"2016-08-06T12:04:51.241Z","comments":true,"path":"2016/08/06/趣说KMP算法/","link":"","permalink":"http://blog.iamxcc.com/2016/08/06/趣说KMP算法/","excerpt":"今天逛知乎时，发现了一个比较浅显易懂的KMP算法解释。故在此做个笔记","text":"今天逛知乎时，发现了一个比较浅显易懂的KMP算法解释。故在此做个笔记 。作者信息如下：作者：逍遥行链接：https://www.zhihu.com/question/21923021/answer/37475572来源：知乎著作权归作者所有，转载请联系作者获得授权。 甲：abbaabbaaba在里面寻找乙：abbaaba发现第 7 个字符不匹配。这时候甲把乙叫走了，说你先一边玩去，我自己研究下。然后甲想，自己已经知道乙的前 6 个字符就是自己的前 6 个字符，不妨先「自己与自己匹配一番」。然后甲先用 abbaab 这 6 个已知的字符去匹配自身，错 1 个位，发现第一个就不一样（不匹配），然后错 2 个位，还是不匹配。当错 3 个位的时候，甲发现匹配了一个 a，但是第二个 b 不匹配。当错 4 个位的时候，匹配了两个。错 5 个位不匹配。后面的东西甲就不知道了，因为他只知道前 6 个字符。（注：实际的匹配个数是字符串 [0…i] 的后缀与前缀的最长公共长度） 随后，甲把乙叫了过来：「我已经知道你下一次匹配开始的位置了，来，让你的头部对齐我的第 5 个字符，然后从你的第 3 个字符开始继续匹配我吧！」 关键的地方，在于不要让乙「前功尽弃」——已经匹配了 6 个了，还差一个就结束了，这时不匹配导致从 0 开始，多可惜啊！现在我告诉你，在不匹配的情况下，你仍然已经匹配了 2 个（乙内心：还好不是 0），并且你可以继续从不匹配的地方开始比较，即用你的 3 个字符与我继续匹配。那，这个 2 你是怎么算的？我在你来之前就算好啦！我先与自己进行匹配（预处理），对每个位置，找「当前位置往前看的最长字符串，它与我的前缀匹配」（当然这个字符串不能是前缀），这个最长字符串的长度，在学术上称作「失配函数」。UCCU，从你的第 6 个位置往前看，恰好 [ab] 与你的前缀 [ab] 匹配，但是我的第 7 个字符并不知道你的第 3 个字符是否与我一样，所以你直接从这里开始继续匹配我。 以上为 KMP 的基本思想，关键在于失配函数的计算，网上的代码很多，这里有个很好的例子你仔细体会下：ababzababa，注意最后一个失配函数的值为 3。","categories":[{"name":"算法","slug":"算法","permalink":"http://blog.iamxcc.com/categories/算法/"}],"tags":[{"name":"KMP算法","slug":"KMP算法","permalink":"http://blog.iamxcc.com/tags/KMP算法/"}]},{"title":"LeetCode 28: Implement strStr()","slug":"LeetCode-28-Implement-strStr","date":"2016-08-06T10:12:33.000Z","updated":"2016-08-06T10:52:18.665Z","comments":true,"path":"2016/08/06/LeetCode-28-Implement-strStr/","link":"","permalink":"http://blog.iamxcc.com/2016/08/06/LeetCode-28-Implement-strStr/","excerpt":"Implement strStr(). Returns the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.","text":"Implement strStr(). Returns the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack. 思路一开始想的是暴力法，就是匹配串与被匹配串从开头开始比较，一发现不对劲，匹配串就向右移动一个单位重新开始比较，一直循环下去直到找到正确匹配位置。后来上网查了一下发现，这是个经典的字符串匹配问题，实现的算法有很多。比如：著名而难以理解的KMP算法、Brute-Force算法、Boyer-Moore算法、Sunday算法……。下面提供的就是Brute-Force算法。 代码C语言版本：12345678910111213141516171819int strStr(char* haystack, char* needle) &#123; int m = strlen(haystack); int n = strlen(needle); if (!n) &#123; return 0; &#125; for (int i = 0; i &lt; m - n + 1; i++) &#123; int j = 0; for (; j &lt; n; j++)&#123; if (haystack[i+j] != needle[j])&#123; break; &#125; &#125; if (j == n) &#123; return i; &#125; &#125; return -1;&#125; 72 / 72 test cases passed.Status: AcceptedRuntime: 4 ms","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.iamxcc.com/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.iamxcc.com/tags/LeetCode/"},{"name":"String","slug":"String","permalink":"http://blog.iamxcc.com/tags/String/"}]},{"title":"OSI模型与TCP/IP模型","slug":"OSI模型与TCP-IP模型","date":"2016-08-06T09:20:25.000Z","updated":"2016-08-06T09:28:19.600Z","comments":true,"path":"2016/08/06/OSI模型与TCP-IP模型/","link":"","permalink":"http://blog.iamxcc.com/2016/08/06/OSI模型与TCP-IP模型/","excerpt":"今天重新温习了一篇OSI模型与TCP/IP模型的知识，发现很多知识点又忘记了。所以，在此记录一下，方便下次查阅。","text":"今天重新温习了一篇OSI模型与TCP/IP模型的知识，发现很多知识点又忘记了。所以，在此记录一下，方便下次查阅。 OSI模型从低到高：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层。 物理层并不是指物理设备或者物理媒体。而是有关物理设备通过物理媒体进行互联的描述和规定。该层定义了接口的机械特性、电气特性、功能特性、规程特性等4个基本特性。物理层以比特流的方式传送来自数据链路层的数据，而不去理会数据的含义和格式。同样，接收数据后直接传给数据链路层。 数据链路层负责通过物理层从一台计算机到另外一台计算机无差错的传输数据帧，允许网络层通过网络连接进行虚拟无差错的传输。通常，数据链路层发送数据帧之后，等待接收方进行确认。接收方数据链路层检测帧传输过程中产生的任何问题。没有经过确认和损坏的帧都需要重传。 网络层负责信息寻址和将逻辑地址转换为物理地址。在网络层，数据传递单位是包。网络层的任务是选择合适的路径转发数据包。使发送方的数据包能够正确无误的按地址寻找到接收方的路径。并将数据包交给接收方。网络中两点之间可以到达的路径可能有很多，在选择最快捷、花费最低的路径时必须考虑网络拥塞程度、服务质量、线路的花费和线路的有效性。总的来说，网络层负责选择最佳路径。 网络层还能够协调发送、传输及接收设备的能力不平衡问题。如网络层对数据进行分段和重组，使得数据的长度能够满足该网络下层数据链路锁支持的最大数据帧MTU的长度。还需要考虑网络层不同网络协议之间的相互连接问题。 传输层传输层的功能是保证在不同子网的两台设备间数据包可靠、顺序、无错的传输。在传输层，数据传输单位是段。传输层负责处理端对端通信，即一个终端到另一个终端的通信，中间可以有多个交换节点。传输层向高层用户提供端到端的可靠的透明传输服务，为不同进程间的数据交换提供可靠的传输手段。在传输层的一个很重要的工作是数据的分段和重组，即把一个上层数据切割成更小的逻辑片和物理片。发送方在传输层把上层交给它的较大的数据进行分段后分别交给网络层进行独立输出，从而在传输层实现流量控制，提高网络资源的利用率。接收方收到数据后重组。传输层可以将收到的乱序数据包重新排序，并验证是否收到所有分组。 会话层会话层是利用传输层提供的端到端的服务，向表示层或会话用户提供会话服务。会话层主要功能是在两个节点之间建立、维护、释放面向用户的连接，并对会话进行管理和控制，保证会话数据可靠传送。会话层的连接与传输层的连接有1对1、1对多、多对1的关系。会话工程中，会话层需要决定到底使用全双工通信还是半双工通信。如果采用全双工，会话层的对话管理工作就很少。如果采用半双工，会话层则通过一个数据令牌来协调会话。保证每次只有一个用户能够传输数据。会话层提供同步服务，通过在数据流中定义检查点来把会话分割成明显的会话单元。当网络出故障时，从最后一个检查点开始重传数据。SQL、RPC(远程进程呼叫)都属于该层协议。 表示层表示层专门负责有关网络中计算机信息表示方式的问题。表示层在不同的数据格式之间进行数据转换，实现不同计算机之间的信息交换。除了编码，还包括数组、浮点数、记录、图像、声音等。表示层还负责数据的加密。文件的压缩，降低传输费用。 应用层直接与用户和应用程序打交道。负责对软件提供接口以使程序可以使用网络。Telnet(虚拟终端协议)、SMTP(简单邮件传输协议)、SNMP(简单网络管理协议)、DNS(域名系统)和超文本传输协议(HTTP)。 TCP/IP模型从低到高：网络接口层、网络层、传输层、应用层。 各层主要功能大致与OSI相对应。 应用层协议：HTTP、FTP、SMTP、DNS。 传输层协议：TCP、UDP。 网络层协议：IP、ARP、ICMP(因特网控制消息协议)、RARP(反向地址解释协议)。 网络接口层：Ethrenet、令牌环、帧中继、ISDN和分组交换网X.25。","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://blog.iamxcc.com/categories/计算机网络/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://blog.iamxcc.com/tags/计算机网络/"}]},{"title":"LeetCode 8: String to Integer(atoi)","slug":"LeetCode-8-String-to-Integer-atoi","date":"2016-08-06T05:38:56.000Z","updated":"2016-08-06T06:14:57.166Z","comments":true,"path":"2016/08/06/LeetCode-8-String-to-Integer-atoi/","link":"","permalink":"http://blog.iamxcc.com/2016/08/06/LeetCode-8-String-to-Integer-atoi/","excerpt":"Implement atoi to convert a string to an integer. Hint: Carefully consider all possible input cases.","text":"Implement atoi to convert a string to an integer. Hint: Carefully consider all possible input cases. If you want a challenge, please do not see below and ask yourself what are the possible input cases. Notes: It is intended for this problem to be specified vaguely (ie, no given input specs). You are responsible to gather all the input requirements up front. 代码C语言版本：1234567891011121314151617181920int myAtoi(char* str) &#123; int sign = 1; int res = 0; if (!str) &#123; return str; &#125; while(' ' == *str) &#123; str++; &#125; if ('-' == *str || '+' == *str) &#123; sign = *str++ == '+' ? 1 : -1; &#125; while(*str &gt;= '0' &amp;&amp; *str &lt;= '9') &#123; if (res &gt; INT_MAX / 10 || (res == INT_MAX / 10 &amp;&amp; *str - '0' &gt; 7)) &#123; return sign &gt; 0 ? INT_MAX : INT_MIN; &#125; res = res * 10 + (((int)*str++) - '0'); &#125; return res * sign;&#125; 1047 / 1047 test cases passed.Status: AcceptedRuntime: 4 ms","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.iamxcc.com/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.iamxcc.com/tags/LeetCode/"},{"name":"String","slug":"String","permalink":"http://blog.iamxcc.com/tags/String/"}]},{"title":"LeetCode 67: Add Binary","slug":"LeetCode-67-Add-Binary","date":"2016-08-06T03:29:22.000Z","updated":"2016-08-06T03:31:24.797Z","comments":true,"path":"2016/08/06/LeetCode-67-Add-Binary/","link":"","permalink":"http://blog.iamxcc.com/2016/08/06/LeetCode-67-Add-Binary/","excerpt":"Given two binary strings, return their sum (also a binary string). For example, a = &quot;11&quot;, b = &quot;1&quot;, Return &quot;100&quot;.","text":"Given two binary strings, return their sum (also a binary string). For example, a = &quot;11&quot;, b = &quot;1&quot;, Return &quot;100&quot;. 代码C语言版本：123456789101112131415161718char* addBinary(char* a, char* b) &#123; int lenA = strlen(a); int lenB = strlen(b); int len = lenA &gt; lenB ? lenA : lenB; char *sum = (char*)calloc(len + 2, sizeof(char)); sum[len + 1] = '\\0'; lenA--; lenB--; int c = 0; while (lenA &gt;= 0 || lenB &gt;= 0) &#123; c += lenA &gt;= 0 ? a[lenA--] - '0' : 0; c += lenB &gt;= 0 ? b[lenB--] - '0' : 0; sum[len--] = c % 2 + '0'; c /= 2; &#125; if (!c) return sum + 1; sum[0] = '1'; return sum;&#125; 294 / 294 test cases passed.Status: AcceptedRuntime: 0 ms","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.iamxcc.com/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.iamxcc.com/tags/LeetCode/"},{"name":"String","slug":"String","permalink":"http://blog.iamxcc.com/tags/String/"}]},{"title":"LeetCode 14: Longest Common Prefix","slug":"LeetCode-14-Longest-Common-Prefix","date":"2016-08-06T02:19:56.000Z","updated":"2016-08-06T02:21:59.596Z","comments":true,"path":"2016/08/06/LeetCode-14-Longest-Common-Prefix/","link":"","permalink":"http://blog.iamxcc.com/2016/08/06/LeetCode-14-Longest-Common-Prefix/","excerpt":"Write a function to find the longest common prefix string amongst an array of strings.","text":"Write a function to find the longest common prefix string amongst an array of strings. 代码C语言版本：1234567891011121314151617181920212223char* longestCommonPrefix(char** strs, int strsSize) &#123; if (strs == NULL || *strs == NULL) &#123; return \"\"; &#125; int len = strlen(strs[0]); int max = 0; char *res; while (max &lt; len) &#123; for (int i = 1; i &lt; strsSize; i++) &#123; if (strs[i][max] != strs[0][max]) &#123; len = max; break; &#125; &#125; if (max &lt; len) max++; &#125; res = (char*)malloc(sizeof(char)*(max+1)); for (int i = 0; i &lt; max; i++) &#123; res[i] = strs[0][i]; &#125; res[max] = '\\0'; return res;&#125; 117 / 117 test cases passed.Status: AcceptedRuntime: 0 ms","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.iamxcc.com/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.iamxcc.com/tags/LeetCode/"},{"name":"String","slug":"String","permalink":"http://blog.iamxcc.com/tags/String/"}]},{"title":"LeetCode 345: Reverse Vowels of a String","slug":"LeetCode-345-Reverse-Vowels-of-a-String","date":"2016-08-06T01:11:36.000Z","updated":"2016-08-06T01:14:24.580Z","comments":true,"path":"2016/08/06/LeetCode-345-Reverse-Vowels-of-a-String/","link":"","permalink":"http://blog.iamxcc.com/2016/08/06/LeetCode-345-Reverse-Vowels-of-a-String/","excerpt":"Write a function that takes a string as input and reverse only the vowels of a string.","text":"Write a function that takes a string as input and reverse only the vowels of a string. Example 1:Given s = “hello”, return “holle”.Example 2:Given s = “leetcode”, return “leotcede”. Note:The vowels does not include the letter “y”. 代码C语言版本：123456789101112131415161718192021222324int isVowelsChar(char p) &#123; return (p == 'a' || p == 'e' || p == 'i' || p == 'o' || p == 'u' || p=='A' || p=='E' || p == 'I' || p == 'O' || p =='U');&#125;char* reverseVowels(char* s) &#123; int left = 0; int right = strlen(s) - 1; if (strlen(s) &lt; 1) &#123; return s; &#125; while (left &lt; right) &#123; while (!isVowelsChar(s[left]) &amp;&amp; left &lt; right) &#123; left++; &#125; while (!isVowelsChar(s[right]) &amp;&amp; left &lt; right) &#123; right--; &#125; char temp = s[left]; s[left] = s[right]; s[right] = temp; left++; right--; &#125; return s;&#125; 481 / 481 test cases passed.Status: AcceptedRuntime: 4 ms","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.iamxcc.com/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.iamxcc.com/tags/LeetCode/"},{"name":"String","slug":"String","permalink":"http://blog.iamxcc.com/tags/String/"}]},{"title":"C语言实现strlen函数的方法","slug":"C语言实现strlen函数的方法","date":"2016-08-05T13:42:17.000Z","updated":"2016-08-05T13:51:29.610Z","comments":true,"path":"2016/08/05/C语言实现strlen函数的方法/","link":"","permalink":"http://blog.iamxcc.com/2016/08/05/C语言实现strlen函数的方法/","excerpt":"不使用中间变量求const字符串长度，即实现求字符串长度库函数strlen函数。函数接口声明如下：int strlen(const char *p)；","text":"不使用中间变量求const字符串长度，即实现求字符串长度库函数strlen函数。函数接口声明如下：int strlen(const char *p)； 思路在字符串中通常可以利用最后一个结束符’\\0’，但此处参数为const，只读，那么我们不能打他的主意。函数运行过程中不占用内存基本不可能，除非都使用了寄存器。“不使用中间变量”只是说程序员不能显示的申请内存而已，即不能有局部变量或者动态内存申请。如果函数自动申请栈内存或者使用寄存器存储变量，或者使用立即数寻址即常量，那么就相当于“不使用中间变量”。从函数原型看，返回值为int，那么在函数内部必定需要一个地方存储这个值，要么是常数要么是寄存器。长度不为1时不能一次就求出来，说明必须有递归调用，这样递归时函数会自动申请栈内存，这样就相当于程序员“不使用中间变量”了。中间返回的值通过寄存器自动保存，最后一次返回时拷贝到int中去。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;assert.h&gt;int mStrlen(const char *str);int mStrlen1(const char *str);int mStrlen2(const char *str);int main()&#123; char *str=NULL; str = \"Hello Jay!\"; printf(\"original strlen():%d\\n\",strlen(str)); printf(\"myStrlen():%d\\n\",myStrlen(str)); printf(\"myStrlen1():%d\\n\",myStrlen1(str)); printf(\"myStrlen2():%d\\n\",myStrlen2(str));&#125;int mStrlen(const char *str) // 不用中间变量，用递归实现，很容易看懂&#123; if ( (str == NULL) || (*str == '\\0') ) &#123; return 0; &#125; else &#123; return myStrlen(str+1)+1; &#125;&#125;int mStrlen1(const char *str) // 不用中间变量，也是用递归实现，写得更简洁而已&#123; assert(str != NULL); return *str ? (myStrlen1(++str) + 1) : 0;&#125;int mStrlen2(const char *str) // 使用了一个int型变量&#123; if(str==NULL) return 0; int len = 0; for(; *str++ != '\\0'; ) &#123; len++; &#125; return len;&#125;","categories":[{"name":"C语言","slug":"C语言","permalink":"http://blog.iamxcc.com/categories/C语言/"}],"tags":[{"name":"C语言","slug":"C语言","permalink":"http://blog.iamxcc.com/tags/C语言/"}]},{"title":"NULL,'\\0',0,'/0'和\"0\"的区别","slug":"NULL,0,'0'","date":"2016-08-05T13:03:42.000Z","updated":"2016-08-05T13:29:20.946Z","comments":true,"path":"2016/08/05/NULL,0,'0'/","link":"","permalink":"http://blog.iamxcc.com/2016/08/05/NULL,0,'0'/","excerpt":"最近发现对于NULL,’\\0’,0,’/0’和”0”的区别有点混淆了。所以在查阅资料之后，将笔记记录在此处，免得下次忘记了可以看看。","text":"最近发现对于NULL,’\\0’,0,’/0’和”0”的区别有点混淆了。所以在查阅资料之后，将笔记记录在此处，免得下次忘记了可以看看。 NULLNULL 即空指针，在C和C++中的形式不一样，msdn上有如下的内容那个：1234567#if !defined(NULL)&amp;&amp;defined(__NEEDS_NULL) #ifdef __cplusplus #define NULL 0 #else #define NULL ((void *)0) #endif#endif NULL 在c中用（void*）0表示，在c++中用0表示。 ‘\\0’和’0’ ‘\\0’表示字符串结束，它在ASCII中的值为0（数值0，非字符‘0’。所以在数值上NULL, ‘\\0’,0是一样的，都是0，但’0’就不同了，在ASCII码中编码为48，所以字符0和上述三个值不同。 在内存中NULL 和&#39;\\0&#39; 和&#39;0&#39;都是一个8位的char类型，NULL 和’\\0’ 值一样，都是0，以数字方式读取就是0，以字符串读取时就是’\\0’或者null（和编译器有关）。 而&#39;0&#39;在内存存储着48，以字符读取就是&#39;0&#39;,以数字读取就是48，至于0，可能是char ,int ,float,double等类型，但是值和NULL和&#39;\\0&#39;一样，都是0。 ‘/0’和’\\0’我在写C代码时，经常把’\\0’写成’/0’。其实这两者之间差别很大的。因为’/0’表示的是两个字符了，一个是’/‘, 另一个’0’。而’\\0’表示的字符串结束，值为0。 “0”“0”表示的是字符串，即在存储中存储了两个内容，一个是’0’(即字符0)，另一个是字符串结束符’\\0’(也即数字0)。 举例为了说明情况，下面列举了几个例子。1234567891011printf(\"%d\",'0'); ==&gt;48printf(\"%c\",'0'); ==&gt;0printf(\"%c\",0); ==&gt;空（即NULL）printf(\"%d\",0); ==&gt;0那么0+'0',0+'\\0'分别是什么呢？printf(\"%c\",0+'\\0'); ==&gt;空（NULL）//先转换成int,然后ASCII编码相加为0，%c输出，转换成char,所以输出NULLprintf(\"%d\",0+'\\0'); ==&gt;0 //先转换成int，然后ASCII编码相加为0, %d输出，不用转换，输出数字0printf(\"%c\",0+'0'); ==&gt;0printf(\"%d\",0+'0'); ==&gt;48","categories":[{"name":"C语言","slug":"C语言","permalink":"http://blog.iamxcc.com/categories/C语言/"}],"tags":[{"name":"C语言","slug":"C语言","permalink":"http://blog.iamxcc.com/tags/C语言/"}]},{"title":"LeetCode 263: Ugly Number","slug":"LeetCode-263-Ugly-Number","date":"2016-08-05T11:28:12.000Z","updated":"2016-08-05T11:29:54.368Z","comments":true,"path":"2016/08/05/LeetCode-263-Ugly-Number/","link":"","permalink":"http://blog.iamxcc.com/2016/08/05/LeetCode-263-Ugly-Number/","excerpt":"Write a program to check whether a given number is an ugly number. Ugly numbers are positive numbers whose prime factors only include 2, 3, 5.","text":"Write a program to check whether a given number is an ugly number. Ugly numbers are positive numbers whose prime factors only include 2, 3, 5. For example, 6, 8 are ugly while 14 is not ugly since it includes another prime factor 7. Note that 1 is typically treated as an ugly number. 代码C语言版本：12345678bool isUgly(int num) &#123; for (int i=2; i&lt;6 &amp;&amp; num; i++) &#123; while (num % i == 0) &#123; num /= i; &#125; &#125; return num == 1;&#125; 1012 / 1012 test cases passed.Status: AcceptedRuntime: 4 ms","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.iamxcc.com/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.iamxcc.com/tags/LeetCode/"},{"name":"Math","slug":"Math","permalink":"http://blog.iamxcc.com/tags/Math/"}]},{"title":"LeetCode 58: Length of Last Word","slug":"LeetCode-58-Length-of-Last-Word","date":"2016-08-05T10:23:40.000Z","updated":"2016-08-05T10:25:00.248Z","comments":true,"path":"2016/08/05/LeetCode-58-Length-of-Last-Word/","link":"","permalink":"http://blog.iamxcc.com/2016/08/05/LeetCode-58-Length-of-Last-Word/","excerpt":"Given a string s consists of upper/lower-case alphabets and empty space characters ‘ ‘, return the length of last word in the string.","text":"Given a string s consists of upper/lower-case alphabets and empty space characters ‘ ‘, return the length of last word in the string. If the last word does not exist, return 0.Note: A word is defined as a character sequence consists of non-space characters only. For example,Given s = &quot;Hello World&quot;,return 5. 代码C语言版本：12345678910111213141516171819int isChar(char p) &#123; return ('a'&lt;=p &amp;&amp; p&lt;='z')||('A'&lt;=p &amp;&amp; p&lt;='Z'); &#125; int lengthOfLastWord(char* s) &#123; int size = strlen(s); int begin; int end = size - 1; if (size &lt; 1) &#123; return 0; &#125; while(end &gt;= 0 &amp;&amp; s[end] == ' ') &#123; end--; &#125; begin = end; while ( begin &gt;= 0 &amp;&amp; isChar(s[begin])) &#123; begin--; &#125; return end - begin;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.iamxcc.com/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.iamxcc.com/tags/LeetCode/"},{"name":"String","slug":"String","permalink":"http://blog.iamxcc.com/tags/String/"}]},{"title":"LeetCode 13: Roman to Integer","slug":"LeetCode-13-Roman-to-Integer","date":"2016-08-05T09:34:44.000Z","updated":"2016-08-09T06:33:33.310Z","comments":true,"path":"2016/08/05/LeetCode-13-Roman-to-Integer/","link":"","permalink":"http://blog.iamxcc.com/2016/08/05/LeetCode-13-Roman-to-Integer/","excerpt":"Given a roman numeral, convert it to an integer.3999 / 3999 test cases passed.","text":"Given a roman numeral, convert it to an integer.3999 / 3999 test cases passed. 代码C语言版本：123456789101112131415161718192021222324int romanCharToInt(char c)&#123; switch (c) &#123; case 'I': return 1; case 'V': return 5; case 'X': return 10; case 'L': return 50; case 'C': return 100; case 'D': return 500; case 'M': return 1000; default: return 0; &#125;&#125;int romanToInt(char* s) &#123; int res = 0; int size = strlen(s); for (int i = 0; i &lt; size; i++) &#123; if (romanCharToInt(s[i]) &lt; romanCharToInt(s[i + 1]))&#123; res -= romanCharToInt(s[i]); &#125; else &#123; res += romanCharToInt(s[i]); &#125; &#125; return res;&#125; 3999 / 3999 test cases passed.Status: AcceptedRuntime: 24 msC++版本：123456789101112131415161718192021222324252627class Solution &#123;public: int romanToInt(string s) &#123; int num = 0; int size = s.size(); for (int i = 0; i &lt; size; i++) &#123; if (i &lt; (size - 1) &amp;&amp; romanCharToInt(s[i]) &lt; romanCharToInt(s[i + 1])) &#123; num -= romanCharToInt(s[i]); &#125; else &#123; num += romanCharToInt(s[i]); &#125; &#125; return num; &#125; int romanCharToInt(char c) &#123; switch (c) &#123; case 'I': return 1; case 'V': return 5; case 'X': return 10; case 'L': return 50; case 'C': return 100; case 'D': return 500; case 'M': return 1000; default: return 0; &#125; &#125;&#125;; 3999 / 3999 test cases passed.Status: AcceptedRuntime: 36 msjava版本：123456789101112131415161718192021222324252627282930public class Solution &#123; public int romanToInt(String s) &#123; //：Ⅰ（1）Ⅴ（5）Ⅹ（10）L（50）C（100）D（500）M（1000） // rules:位于大数的后面时就作为加数；位于大数的前面就作为减数 //eg：Ⅲ=3,Ⅳ=4,Ⅵ=6,ⅩⅨ=19,ⅩⅩ=20,ⅩLⅤ=45,MCMⅩⅩC=1980 //\"DCXXI\" if(s == null || s.length() == 0) return 0; int len = s.length(); HashMap&lt;Character,Integer&gt; map = new HashMap&lt;Character,Integer&gt;(); map.put('I',1); map.put('V',5); map.put('X',10); map.put('L',50); map.put('C',100); map.put('D',500); map.put('M',1000); int result = map.get(s.charAt(len -1)); int pivot = result; for(int i = len -2; i&gt;= 0;i--)&#123; int cur = map.get(s.charAt(i)); if(cur &gt;= pivot)&#123; result += cur; &#125;else&#123; result -= cur; &#125; pivot = cur; &#125; return result; &#125;&#125; 3999 / 3999 test cases passed.Status: AcceptedRuntime: 24 ms","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.iamxcc.com/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.iamxcc.com/tags/LeetCode/"},{"name":"String","slug":"String","permalink":"http://blog.iamxcc.com/tags/String/"}]},{"title":"LeetCode 344: Reverse String","slug":"LeetCode-344-Reverse-String","date":"2016-08-05T09:12:25.000Z","updated":"2016-08-05T09:18:56.336Z","comments":true,"path":"2016/08/05/LeetCode-344-Reverse-String/","link":"","permalink":"http://blog.iamxcc.com/2016/08/05/LeetCode-344-Reverse-String/","excerpt":"Write a function that takes a string as input and returns the string reversed. Example: Given s = &quot;hello&quot;, return &quot;olleh&quot;.","text":"Write a function that takes a string as input and returns the string reversed. Example: Given s = &quot;hello&quot;, return &quot;olleh&quot;. 代码C语言版本：12345678910111213char* reverseString(char* s) &#123; int left = 0; int right = strlen(s) - 1; while (left&lt;right)&#123; s[left] ^= s[right]; s[right] ^= s[left]; s[left] ^= s[right]; left++; right--; &#125; return s;&#125; 476 / 476 test cases passed.Status: AcceptedRuntime: 4 msC++版本：12345678910class Solution &#123;public: string reverseString(string s) &#123; int l = 0, r = s.size() - 1; while (l &lt; r)&#123; swap(s[l++], s[r--]); &#125; return s; &#125;&#125;; 476 / 476 test cases passed.Status: AcceptedRuntime: 12 ms","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.iamxcc.com/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.iamxcc.com/tags/LeetCode/"},{"name":"String","slug":"String","permalink":"http://blog.iamxcc.com/tags/String/"}]},{"title":"LeetCode 2: Add Two Numbers","slug":"LeetCode-2-Add-Two-Numbers","date":"2016-08-05T08:52:42.000Z","updated":"2016-08-05T08:56:47.608Z","comments":true,"path":"2016/08/05/LeetCode-2-Add-Two-Numbers/","link":"","permalink":"http://blog.iamxcc.com/2016/08/05/LeetCode-2-Add-Two-Numbers/","excerpt":"You are given two linked lists representing two non-negative numbers. The digits are stored in reverse order and each of their nodes contain a single digit.","text":"You are given two linked lists representing two non-negative numbers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list. Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)Output: 7 -&gt; 0 -&gt; 8 代码C语言版本：12345678910111213141516171819202122232425262728293031323334/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * struct ListNode *next; * &#125;; */struct ListNode* addTwoNumbers(struct ListNode* l1, struct ListNode* l2) &#123; struct ListNode* c1 = l1; struct ListNode* c2 = l2; struct ListNode* sentinel = (struct ListNode*)malloc(sizeof(struct ListNode)); struct ListNode* dummy = sentinel; int sum = 0; while ( c1 || c2) &#123; sum /= 10; if ( c1 )&#123; sum += c1 -&gt; val; c1 = c1 -&gt; next; &#125; if ( c2 )&#123; sum += c2 -&gt; val; c2 = c2 -&gt; next; &#125; dummy -&gt; next = (struct ListNode*)malloc(sizeof(struct ListNode)); dummy -&gt; next -&gt; val = sum % 10; dummy = dummy -&gt; next; &#125; if ( sum / 10 == 1 ) &#123; dummy -&gt; next = (struct ListNode*)malloc(sizeof(struct ListNode)); dummy -&gt; next -&gt; val = 1; &#125; return sentinel -&gt; next;&#125; C++版本：1234567891011121314151617181920212223/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) &#123; ListNode preheader(-1), *curr=&amp;preheader; int carry=0; while(l1 || l2 || carry) &#123; curr-&gt;next = new ListNode(((l1?l1-&gt;val:0)+(l2?l2-&gt;val:0)+carry)%10); curr = curr-&gt;next; carry = ((l1?l1-&gt;val:0)+(l2?l2-&gt;val:0)+carry)/10; l1?l1=l1-&gt;next:0; l2?l2=l2-&gt;next:0; &#125; return preheader.next; &#125;&#125;; 1558 / 1558 test cases passed.Status: AcceptedRuntime: 40 ms","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.iamxcc.com/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.iamxcc.com/tags/LeetCode/"},{"name":"Linked List","slug":"Linked-List","permalink":"http://blog.iamxcc.com/tags/Linked-List/"}]},{"title":"LeetCode 147: Insertion Sort List","slug":"LeetCode-147-Insertion-Sort-List","date":"2016-08-05T06:22:38.000Z","updated":"2016-08-05T06:24:14.239Z","comments":true,"path":"2016/08/05/LeetCode-147-Insertion-Sort-List/","link":"","permalink":"http://blog.iamxcc.com/2016/08/05/LeetCode-147-Insertion-Sort-List/","excerpt":"Sort a linked list using insertion sort.","text":"Sort a linked list using insertion sort. 代码C语言版本：1234567891011121314151617181920212223242526272829/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * struct ListNode *next; * &#125;; */struct ListNode* insertionSortList(struct ListNode* head) &#123; if ( !head ) &#123; return head; &#125; struct ListNode* helper; helper -&gt; next = NULL; struct ListNode* cur = head; struct ListNode* behind = NULL; struct ListNode* pre = helper; while ( cur ) &#123; behind = cur -&gt; next; while ( pre -&gt; next &amp;&amp; pre-&gt;next-&gt;val &lt; cur-&gt;val ) &#123; pre = pre -&gt; next; &#125; cur -&gt; next = pre -&gt; next; pre -&gt; next = cur; pre = helper; cur = behind; &#125; return helper -&gt; next;&#125; 21 / 21 test cases passed.Status: AcceptedRuntime: 64 ms","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.iamxcc.com/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.iamxcc.com/tags/LeetCode/"},{"name":"Linked List","slug":"Linked-List","permalink":"http://blog.iamxcc.com/tags/Linked-List/"}]},{"title":"LeetCode 86: Partition List","slug":"LeetCode-86-Partition-List","date":"2016-08-05T03:27:08.000Z","updated":"2016-08-05T03:29:19.485Z","comments":true,"path":"2016/08/05/LeetCode-86-Partition-List/","link":"","permalink":"http://blog.iamxcc.com/2016/08/05/LeetCode-86-Partition-List/","excerpt":"Given a linked list and a value x, partition it such that all nodes less than x come before nodes greater than or equal to x.","text":"Given a linked list and a value x, partition it such that all nodes less than x come before nodes greater than or equal to x.You should preserve the original relative order of the nodes in each of the two partitions.For example,Given 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;2 and x = 3,return 1-&gt;2-&gt;2-&gt;4-&gt;3-&gt;5. 代码C语言版本：12345678910111213141516171819202122232425262728293031/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * struct ListNode *next; * &#125;; */struct ListNode* partition(struct ListNode* head, int x) &#123; if ( !head ) &#123; return NULL; &#125; struct ListNode *smaller, *smallerHeader; smallerHeader -&gt; next = head; smaller = smallerHeader; struct ListNode *bigger, *biggerHeader; biggerHeader -&gt; next = head; bigger = biggerHeader; while ( head ) &#123; if ( head -&gt; val &lt; x ) &#123; smaller -&gt; next = head; smaller = head; &#125;else &#123; bigger -&gt; next = head; bigger = head; &#125; head = head -&gt; next; &#125; bigger -&gt; next = NULL; smaller -&gt; next = biggerHeader -&gt; next; return smallerHeader -&gt; next;&#125; 166 / 166 test cases passed.Status: AcceptedRuntime: 4 ms","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.iamxcc.com/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.iamxcc.com/tags/LeetCode/"},{"name":"Linked List","slug":"Linked-List","permalink":"http://blog.iamxcc.com/tags/Linked-List/"}]},{"title":"LeetCode 350: Intersection of Two Arrays II","slug":"LeetCode-350-Intersection-of-Two-Arrays-II","date":"2016-08-04T23:25:38.000Z","updated":"2016-08-04T23:28:32.643Z","comments":true,"path":"2016/08/05/LeetCode-350-Intersection-of-Two-Arrays-II/","link":"","permalink":"http://blog.iamxcc.com/2016/08/05/LeetCode-350-Intersection-of-Two-Arrays-II/","excerpt":"Given two arrays, write a function to compute their intersection. Example: Given nums1 = [1, 2, 2, 1], nums2 = [2, 2], return [2, 2].","text":"Given two arrays, write a function to compute their intersection. Example: Given nums1 = [1, 2, 2, 1], nums2 = [2, 2], return [2, 2]. Note: Each element in the result should appear as many times as it shows in both arrays. The result can be in any order. 思路代码C语言版本：1234567891011121314151617181920212223242526int cmp(const int* a, const int* b)&#123; return *a - *b;&#125;/** * Return an array of size *returnSize. * Note: The returned array must be malloced, assume caller calls free(). */int* intersect(int* nums1, int nums1Size, int* nums2, int nums2Size, int* returnSize) &#123; qsort(nums1, nums1Size, sizeof(int), cmp); qsort(nums2, nums2Size, sizeof(int), cmp); int i = 0, j = 0, k = 0; int* intersect = (int*)malloc(sizeof(int)*(nums1Size+nums2Size)); while ( i &lt; nums1Size &amp;&amp; j &lt; nums2Size ) &#123; if ( nums1[i] &lt; nums2[j]) &#123; i++; &#125;else if ( nums1[i] &gt; nums2[j] ) &#123; j++; &#125;else &#123; intersect[k++] = nums1[i]; i++; j++; &#125; &#125; *returnSize = k; return intersect;&#125; 60 / 60 test cases passed.Status: AcceptedRuntime: 4 ms","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.iamxcc.com/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.iamxcc.com/tags/LeetCode/"},{"name":"Linked List","slug":"Linked-List","permalink":"http://blog.iamxcc.com/tags/Linked-List/"}]},{"title":"LeetCode 328: Odd Even Linked List","slug":"LeetCode-328-Odd-Even-Linked-List","date":"2016-08-04T13:47:47.000Z","updated":"2016-08-04T14:34:11.923Z","comments":true,"path":"2016/08/04/LeetCode-328-Odd-Even-Linked-List/","link":"","permalink":"http://blog.iamxcc.com/2016/08/04/LeetCode-328-Odd-Even-Linked-List/","excerpt":"Given a singly linked list, group all odd nodes together followed by the even nodes. Please note here we are talking about the node number and not the value in the nodes.","text":"Given a singly linked list, group all odd nodes together followed by the even nodes. Please note here we are talking about the node number and not the value in the nodes. You should try to do it in place. The program should run in O(1) space complexity and O(nodes) time complexity. Example:Given 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL,return 1-&gt;3-&gt;5-&gt;2-&gt;4-&gt;NULL. Note:The relative order inside both the even and odd groups should remain as it was in the input.The first node is considered odd, the second node even and so on … 代码C语言版本：1234567891011121314151617181920212223242526272829/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * struct ListNode *next; * &#125;; */struct ListNode* oddEvenList(struct ListNode* head) &#123; if ( !head || !(head -&gt; next) )&#123; return head; &#125; struct ListNode* slow = head; struct ListNode* fast = head -&gt; next; struct ListNode* oddHead = head; struct ListNode* evenHead = head -&gt; next; while ( fast &amp;&amp; fast -&gt; next )&#123; slow -&gt; next = fast -&gt; next; slow = fast -&gt; next; if ( !slow -&gt; next )&#123; fast -&gt; next = NULL; break; &#125; fast -&gt; next = slow -&gt; next; fast = slow -&gt; next; &#125; slow -&gt; next = evenHead; return oddHead; &#125; 70 / 70 test cases passed.Status: AcceptedRuntime: 4 ms","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.iamxcc.com/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.iamxcc.com/tags/LeetCode/"},{"name":"Linked List","slug":"Linked-List","permalink":"http://blog.iamxcc.com/tags/Linked-List/"}]},{"title":"LeetCode 142: Linked List Cycle II","slug":"LeetCode-142-Linked-List-Cycle-II","date":"2016-08-04T04:49:05.000Z","updated":"2016-08-04T04:54:50.934Z","comments":true,"path":"2016/08/04/LeetCode-142-Linked-List-Cycle-II/","link":"","permalink":"http://blog.iamxcc.com/2016/08/04/LeetCode-142-Linked-List-Cycle-II/","excerpt":"Given a linked list, return the node where the cycle begins. If there is no cycle, return null. Note: Do not modify the linked list. Follow up: Can you solve it without using extra space?","text":"Given a linked list, return the node where the cycle begins. If there is no cycle, return null. Note: Do not modify the linked list. Follow up: Can you solve it without using extra space? 思路还是使用快慢指针的做法，先判断是否有环，没环的话直接返回null，否则在有环的情况下，在slow指针和fast指针第一次相遇处，让fast指针停下，slow继续前进，与此同时，一个从head开始的rHead指针也一起前进。最后rHead与slow指针相遇处就是环的开始之处。 代码C语言版本：12345678910111213141516171819202122232425262728/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * struct ListNode *next; * &#125;; */struct ListNode *detectCycle(struct ListNode *head) &#123; struct ListNode* fast = head; struct ListNode* slow = head; struct ListNode* rHead = head; while (fast &amp;&amp; fast -&gt; next) &#123; fast = fast -&gt; next -&gt; next; slow = slow -&gt; next; if (slow == fast)&#123; break; &#125; &#125; if ( !fast || !fast -&gt; next)&#123; return false; &#125; while ( slow != rHead)&#123; rHead = rHead -&gt; next; slow = slow -&gt; next; &#125; return rHead;&#125; 16 / 16 test cases passed.Status: AcceptedRuntime: 8 ms","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.iamxcc.com/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.iamxcc.com/tags/LeetCode/"},{"name":"Linked List","slug":"Linked-List","permalink":"http://blog.iamxcc.com/tags/Linked-List/"}]},{"title":"LeetCode 234: Palindrome Linked List","slug":"LeetCode-234-Palindrome-Linked-List","date":"2016-08-03T14:21:55.000Z","updated":"2016-08-03T14:24:52.044Z","comments":true,"path":"2016/08/03/LeetCode-234-Palindrome-Linked-List/","link":"","permalink":"http://blog.iamxcc.com/2016/08/03/LeetCode-234-Palindrome-Linked-List/","excerpt":"Given a singly linked list, determine if it is a palindrome. Follow up: Could you do it in O(n) time and O(1) space?","text":"Given a singly linked list, determine if it is a palindrome. Follow up: Could you do it in O(n) time and O(1) space? 思路这道题让我们判断一个链表是否为回文链表，LeetCode中关于回文串的题共有六道，除了这道，其他的五道为 Palindrome Number 验证回文数字， Validate Palindrome 验证回文字符串， Palindrome Partitioning 拆分回文串，Palindrome Partitioning II 拆分回文串之二 和 Longest Palindromic Substring 最长回文串.链表比字符串难的地方就在于不能通过坐标来直接访问，而只能从头开始遍历到某个位置。那么根据回文串的特点，我们需要比较对应位置的值是否相等，那么我们首先需要找到链表的中点，这个可以用快慢指针来实现，使用方法可以参见之前的两篇Convert Sorted List to Binary Search Tree 将有序链表转为二叉搜索树 和 Reorder List 链表重排序，我们使用快慢指针找中点的原理是fast和slow两个指针，每次快指针走两步，慢指针走一步，等快指针走完时，慢指针的位置就是中点。我们还需要用栈，每次慢指针走一步，都把值存入栈中，等到达中点时，链表的前半段都存入栈中了，由于栈的后进先出的性质，就可以和后半段链表按照回文对应的顺序比较了。 代码C语言版本：12345678910111213141516171819202122232425262728293031323334353637383940/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * struct ListNode *next; * &#125;; */struct ListNode* reverseList(struct ListNode* head) &#123; if (NULL == head)&#123; return head; &#125; struct ListNode *p = head; struct ListNode *pNext; p = head-&gt;next; head-&gt;next = NULL; while (p != NULL)&#123; pNext = p-&gt;next; p-&gt;next = head; head = p; p = pNext; &#125; return head;&#125;bool isPalindrome(struct ListNode* head) &#123; struct ListNode* fast = head; struct ListNode* slow = head; while ( fast != NULL &amp;&amp; fast-&gt;next != NULL) &#123; slow = slow -&gt; next; fast = fast -&gt; next -&gt; next; &#125; ///reverse the bottom half list struct ListNode* rHead = reverseList(slow); while(head != NULL &amp;&amp; rHead != NULL)&#123; if(head-&gt;val != rHead-&gt;val) return false; head = head-&gt;next; rHead = rHead-&gt;next; &#125; return true;&#125; 22 / 22 test cases passed.Status: AcceptedRuntime: 12 ms","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.iamxcc.com/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.iamxcc.com/tags/LeetCode/"},{"name":"Linked List","slug":"Linked-List","permalink":"http://blog.iamxcc.com/tags/Linked-List/"}]},{"title":"LeetCode 83: Remove Duplicates from Sorted List","slug":"LeetCode-83-Remove-Duplicates-from-Sorted-List","date":"2016-08-03T13:46:45.000Z","updated":"2016-08-03T13:49:34.684Z","comments":true,"path":"2016/08/03/LeetCode-83-Remove-Duplicates-from-Sorted-List/","link":"","permalink":"http://blog.iamxcc.com/2016/08/03/LeetCode-83-Remove-Duplicates-from-Sorted-List/","excerpt":"Given a sorted linked list, delete all duplicates such that each element appear only once. For example, Given 1-&gt;1-&gt;2, return 1-&gt;2.Given 1-&gt;1-&gt;2-&gt;3-&gt;3, return 1-&gt;2-&gt;3.","text":"Given a sorted linked list, delete all duplicates such that each element appear only once. For example, Given 1-&gt;1-&gt;2, return 1-&gt;2.Given 1-&gt;1-&gt;2-&gt;3-&gt;3, return 1-&gt;2-&gt;3. 思路由于链表已经排好序，所以直接循环查找重复的节点，没什么好说的，比较简单。 代码C语言版本：1234567891011121314151617181920212223/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * struct ListNode *next; * &#125;; */struct ListNode* deleteDuplicates(struct ListNode* head) &#123; struct ListNode* p = head; if ( head )&#123; while ( p -&gt; next )&#123; if (p -&gt; val != p -&gt; next -&gt; val )&#123; p = p -&gt; next; &#125;else&#123; struct ListNode* tmp = p -&gt; next; p -&gt; next = p -&gt; next -&gt; next; free( tmp ); &#125; &#125; &#125; return head;&#125; 164 / 164 test cases passed.Status: AcceptedRuntime: 4 ms","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.iamxcc.com/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.iamxcc.com/tags/LeetCode/"},{"name":"Linked List","slug":"Linked-List","permalink":"http://blog.iamxcc.com/tags/Linked-List/"}]},{"title":"LeetCode 141: Linked List Cycle","slug":"LeetCode-141-Linked-List-Cycle","date":"2016-08-03T13:15:18.000Z","updated":"2016-08-03T14:04:32.004Z","comments":true,"path":"2016/08/03/LeetCode-141-Linked-List-Cycle/","link":"","permalink":"http://blog.iamxcc.com/2016/08/03/LeetCode-141-Linked-List-Cycle/","excerpt":"Given a linked list, determine if it has a cycle in it. Follow up: Can you solve it without using extra space?","text":"Given a linked list, determine if it has a cycle in it. Follow up: Can you solve it without using extra space? 思路设两个指针即快慢指针，只要是一个环，那么跑得快的总能追上跑得慢的。 代码C语言版本：12345678910111213141516171819202122/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * struct ListNode *next; * &#125;; */bool hasCycle(struct ListNode *head) &#123; struct ListNode* fast = head; struct ListNode* slow = head; while ( fast &amp;&amp; fast -&gt; next )&#123; fast = fast -&gt; next -&gt; next; slow = slow -&gt; next; if (fast == slow)&#123; return true; &#125; &#125; return false;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.iamxcc.com/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.iamxcc.com/tags/LeetCode/"},{"name":"Linked List","slug":"Linked-List","permalink":"http://blog.iamxcc.com/tags/Linked-List/"}]},{"title":"LeetCode 19: Remove Nth Node From End of List","slug":"LeetCode-19-Remove-Nth-Node-From-End-of-List","date":"2016-08-03T10:35:26.000Z","updated":"2016-08-03T10:37:59.938Z","comments":true,"path":"2016/08/03/LeetCode-19-Remove-Nth-Node-From-End-of-List/","link":"","permalink":"http://blog.iamxcc.com/2016/08/03/LeetCode-19-Remove-Nth-Node-From-End-of-List/","excerpt":"Given a linked list, remove the nth node from the end of list and return its head. For example,Given linked list: 1-&gt;2-&gt;3-&gt;4-&gt;5, and n = 2.","text":"Given a linked list, remove the nth node from the end of list and return its head. For example,Given linked list: 1-&gt;2-&gt;3-&gt;4-&gt;5, and n = 2.After removing the second node from the end, the linked list becomes 1-&gt;2-&gt;3-&gt;5.Note:Given n will always be valid.Try to do this in one pass. 思路两个指针，当一个指向末尾时，另一个恰好指向要删除节点的前一个节点处。 代码C语言版本：12345678910111213141516171819202122232425/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * struct ListNode *next; * &#125;; */struct ListNode* removeNthFromEnd(struct ListNode* head, int n) &#123; struct ListNode* front = head; struct ListNode* behind = head; while ( front )&#123; front = front -&gt; next; if ( n-- &lt; 0 )&#123; behind = behind-&gt;next; &#125; &#125; if (n == 0) &#123; head = head-&gt;next; &#125;else &#123; behind-&gt;next = behind-&gt;next-&gt;next; &#125; return head;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.iamxcc.com/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.iamxcc.com/tags/LeetCode/"},{"name":"Linked List","slug":"Linked-List","permalink":"http://blog.iamxcc.com/tags/Linked-List/"}]},{"title":"LeetCode 160: Intersection of Two Linked Lists","slug":"LeetCode-160-Intersection-of-Two-Linked-Lists","date":"2016-08-03T03:26:12.000Z","updated":"2016-08-03T06:15:12.439Z","comments":true,"path":"2016/08/03/LeetCode-160-Intersection-of-Two-Linked-Lists/","link":"","permalink":"http://blog.iamxcc.com/2016/08/03/LeetCode-160-Intersection-of-Two-Linked-Lists/","excerpt":"Write a program to find the node at which the intersection of two singly linked lists begins.For example, the following two linked lists:","text":"Write a program to find the node at which the intersection of two singly linked lists begins.For example, the following two linked lists:123456A: a1 → a2 ↘ c1 → c2 → c3 ↗ B: b1 → b2 → b3begin to intersect at node c1. Notes: If the two linked lists have no intersection at all, return null. The linked lists must retain their original structure after the function returns. You may assume there are no cycles anywhere in the entire linked structure. Your code should preferably run in O(n) time and use only O(1) memory. 代码C语言版本：123456789101112131415161718192021222324252627282930313233343536373839404142434445/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * struct ListNode *next; * &#125;; */struct ListNode *getIntersectionNode(struct ListNode *headA, struct ListNode *headB) &#123; struct ListNode *LA, *LB; struct ListNode *h1, *h2; int lenA=0, lenB=0, step=0; if(!headA || !headB) return NULL; LA = headA; LB = headB; while(LA)&#123; lenA++; LA = LA-&gt;next; &#125; while(LB)&#123; lenB++; LB = LB-&gt;next; &#125; if(lenA &gt;= lenB&#123; step = lenA - lenB; h1 = headA; h2 = headB; &#125;else&#123; step = lenB - lenA; h1 = headB; h2 = headA; &#125; while(h1 &amp;&amp; step)&#123; step--; h1 = h1-&gt;next; &#125; while(h1 &amp;&amp; h2)&#123; if(h1-&gt;val == h2-&gt;val) return h1; h1 = h1-&gt;next; h2 = h2-&gt;next; &#125; return NULL;&#125; 42 / 42 test cases passed.Status: AcceptedRuntime: 32 ms","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.iamxcc.com/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.iamxcc.com/tags/LeetCode/"},{"name":"Linked List","slug":"Linked-List","permalink":"http://blog.iamxcc.com/tags/Linked-List/"}]},{"title":"LeetCode 203: Remove Linked List Elements","slug":"LeetCode-203-Remove-Linked-List-Elements","date":"2016-08-02T14:58:14.000Z","updated":"2016-08-07T07:53:43.448Z","comments":true,"path":"2016/08/02/LeetCode-203-Remove-Linked-List-Elements/","link":"","permalink":"http://blog.iamxcc.com/2016/08/02/LeetCode-203-Remove-Linked-List-Elements/","excerpt":"Remove all elements from a linked list of integers that have value val. Example Given: 1 --&gt; 2 --&gt; 6 --&gt; 3 --&gt; 4 --&gt; 5 --&gt; 6, val = 6. Return: 1 --&gt; 2 --&gt; 3 --&gt; 4 --&gt; 5.","text":"Remove all elements from a linked list of integers that have value val. Example Given: 1 --&gt; 2 --&gt; 6 --&gt; 3 --&gt; 4 --&gt; 5 --&gt; 6, val = 6. Return: 1 --&gt; 2 --&gt; 3 --&gt; 4 --&gt; 5. 思路两个指针, 一样的就删, 不一样就next. 代码C语言版本：1234567891011121314151617181920212223/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * struct ListNode *next; * &#125;; */struct ListNode* removeElements(struct ListNode* head, int val) &#123; struct ListNode* dummy; dummy -&gt; next = head; struct ListNode* p = dummy; struct ListNode* q = head; while(q != NULL) &#123; if(q-&gt;val == val) &#123; p-&gt;next = q-&gt;next; &#125; else &#123; p = p-&gt;next; &#125; q = q-&gt;next; &#125; return dummy-&gt;next; &#125; 63 / 63 test cases passed.Status: AcceptedRuntime: 12 ms 12345678st=&gt;start: Starte=&gt;endop=&gt;operation: My Operationcond=&gt;condition: Yes or No?st-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op 123Alice-&gt;Bob: Hello Bob, how are you?Note right of Bob: Bob thinksBob--&gt;Alice: I am good thanks!","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.iamxcc.com/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.iamxcc.com/tags/LeetCode/"},{"name":"Linked List","slug":"Linked-List","permalink":"http://blog.iamxcc.com/tags/Linked-List/"}]},{"title":"LeetCode 371: Sum of Two integers","slug":"LeetCode-371-Sum-of-Two-integers","date":"2016-08-02T10:43:25.000Z","updated":"2016-08-02T11:00:20.352Z","comments":true,"path":"2016/08/02/LeetCode-371-Sum-of-Two-integers/","link":"","permalink":"http://blog.iamxcc.com/2016/08/02/LeetCode-371-Sum-of-Two-integers/","excerpt":"Calculate the sum of two integers a and b, but you are not allowed to use the operator + and -.Example: Given a = 1 and b = 2, return 3.","text":"Calculate the sum of two integers a and b, but you are not allowed to use the operator + and -.Example: Given a = 1 and b = 2, return 3. 题意计算a和b的和，但是不能使用+和-号。 思路这里要求我们不能用加法、减法等运算符来实现加法运算。这里应该使用位运算来实现加法运算，实际上，这也是计算机CPU内部实现加法运算的方案。x ^ y真值表: x y x^y 0 0 0 0 1 1 1 0 1 1 1 0 x &amp; y真值表: x y x&amp;y 0 0 0 0 1 0 1 0 0 1 1 1 我们可以基于以上的真值表用&amp;和^运算来实现加法，每一位的^运算得到每一位上的不加进位的和，用&amp;运算得到每一位的进位。 代码C语言版本：1234567891011int getSum(int a, int b) &#123; int sum = a; int carry = b; int tmp; while ( carry )&#123; tmp = sum; sum = sum ^ carry; carry = (carry &amp; tmp) &lt;&lt; 1; &#125; return sum;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.iamxcc.com/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.iamxcc.com/tags/LeetCode/"},{"name":"Bit Manupulation","slug":"Bit-Manupulation","permalink":"http://blog.iamxcc.com/tags/Bit-Manupulation/"}]},{"title":"LeetCode 24: Swap Nodes in Pairs","slug":"LeetCode-24-Swap-Nodes-in-Pairs","date":"2016-08-02T09:17:28.000Z","updated":"2016-08-02T09:22:49.264Z","comments":true,"path":"2016/08/02/LeetCode-24-Swap-Nodes-in-Pairs/","link":"","permalink":"http://blog.iamxcc.com/2016/08/02/LeetCode-24-Swap-Nodes-in-Pairs/","excerpt":"Given a linked list, swap every two adjacent nodes and return its head. For example, Given 1-&gt;2-&gt;3-&gt;4, you should return the list as 2-&gt;1-&gt;4-&gt;3.","text":"Given a linked list, swap every two adjacent nodes and return its head. For example, Given 1-&gt;2-&gt;3-&gt;4, you should return the list as 2-&gt;1-&gt;4-&gt;3.Your algorithm should use only constant space. You may not modify the values in the list, only nodes itself can be changed. 题意考虑一个单链表， 交换每两个相邻的节点并返回头节点。比如，给出1-&gt;2-&gt;3-&gt;4，你应该返回2-&gt;1-&gt;4-&gt;3。 思路题目意思是给定一个单链表，交换两个相邻的节点。我的做法是先找到新链表的头结点，然后像交换两个变量的值的方式，来交换两个相邻的节点，这里需要注意的是，交换的时候，需要保存交换节点的前后节点，这里我用left、right去保存，为了交换之后，前后节点不丢失。 代码C语言版本：12345678910111213141516171819202122232425262728293031323334353637383940/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * struct ListNode *next; * &#125;; */struct ListNode* swapPairs(struct ListNode* head) &#123; struct ListNode *p, *q, *right, *left; struct ListNode * ret; if(!head || !head-&gt;next) return head; p = head; q = p-&gt;next; if(p &amp;&amp; q) ret = q; while(p &amp;&amp; q) &#123; right = q-&gt;next; q-&gt;next = p; left = p; p-&gt;next = right; p = right; if(!right || !right-&gt;next) break; if(right-&gt;next) &#123; q = p-&gt;next; left-&gt;next = q; &#125; &#125; return ret;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.iamxcc.com/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.iamxcc.com/tags/LeetCode/"},{"name":"Linked List","slug":"Linked-List","permalink":"http://blog.iamxcc.com/tags/Linked-List/"}]},{"title":"LeetCode 21: Merge Two Sorted Lists","slug":"LeetCode-21-Merge-Two-Sorted-Lists","date":"2016-08-02T02:45:27.000Z","updated":"2016-08-02T02:49:29.549Z","comments":true,"path":"2016/08/02/LeetCode-21-Merge-Two-Sorted-Lists/","link":"","permalink":"http://blog.iamxcc.com/2016/08/02/LeetCode-21-Merge-Two-Sorted-Lists/","excerpt":"Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists.","text":"Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists. 题意融合两个已经排好序的链表，并返回一个新表。 思路先找到表头，然后做个循环不断排序下去即可。 代码C语言版本：1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * struct ListNode *next; * &#125;; */struct ListNode* mergeTwoLists(struct ListNode* l1, struct ListNode* l2) &#123; if (l1 == NULL)&#123; return l2; &#125; if (l2 == NULL)&#123; return l1; &#125; struct ListNode* head = NULL; // find the first element if (l1-&gt;val &lt; l2-&gt;val)&#123; head = l1; l1 = l1-&gt;next; &#125;else&#123; head = l2; l2 = l2-&gt;next; &#125; struct ListNode* p = head; while(l1&amp;&amp;l2)&#123; if (l1-&gt;val &lt; l2-&gt;val)&#123; p-&gt;next = l1; l1 = l1-&gt;next; &#125;else&#123; p-&gt;next = l2; l2 = l2-&gt;next; &#125; p = p-&gt;next; &#125; if(l1)&#123; p-&gt;next=l1; &#125;else&#123; p-&gt;next=l2; &#125; return head;&#125; 结果：208 / 208 test cases passed.Status: AcceptedRuntime: 4 ms","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.iamxcc.com/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.iamxcc.com/tags/LeetCode/"},{"name":"Linked List","slug":"Linked-List","permalink":"http://blog.iamxcc.com/tags/Linked-List/"}]},{"title":"LeetCode 206: Reverse Linked List","slug":"LeetCode-206-Reverse-Linked-List","date":"2016-08-02T00:30:43.000Z","updated":"2016-08-02T00:36:18.089Z","comments":true,"path":"2016/08/02/LeetCode-206-Reverse-Linked-List/","link":"","permalink":"http://blog.iamxcc.com/2016/08/02/LeetCode-206-Reverse-Linked-List/","excerpt":"Reverse a singly linked list.Hint: A linked list can be reversed either iteratively or recursively. Could you implement both?","text":"Reverse a singly linked list.Hint: A linked list can be reversed either iteratively or recursively. Could you implement both? 题意翻转该单链表 思路使用迭代法或者递归法皆可实现。 代码C语言版本：iteratively(迭代方法)12345678910111213141516171819202122/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * struct ListNode *next; * &#125;; */struct ListNode* reverseList(struct ListNode* head) &#123; if (NULL == head)&#123; return head; &#125; struct ListNode *p = head; p = head-&gt;next; head-&gt;next = NULL; while (p != NULL)&#123; struct ListNode *pNext = p-&gt;next; p-&gt;next = head; head = p; p = pNext; &#125; return head;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.iamxcc.com/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.iamxcc.com/tags/LeetCode/"},{"name":"Linked List","slug":"Linked-List","permalink":"http://blog.iamxcc.com/tags/Linked-List/"}]},{"title":"LeetCode 136: Single Number","slug":"LeetCode-136-Single-Number","date":"2016-08-01T15:43:43.000Z","updated":"2016-08-02T00:32:47.031Z","comments":true,"path":"2016/08/01/LeetCode-136-Single-Number/","link":"","permalink":"http://blog.iamxcc.com/2016/08/01/LeetCode-136-Single-Number/","excerpt":"Given an array of integers, every element appears twice except for one. Find that single one.","text":"Given an array of integers, every element appears twice except for one. Find that single one. Note:Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory? 题意考虑一个整数数组， 除了一个整数外其他整数都出现了两次，请把这个整数找出来。 思路我们知道两个相同的整数异或会为0，而0跟任何整数异或等于该整数。所以只要把数组的整数不断取出并异或，最后的结果就是那个值。 代码C语言版本：1234567int singleNumber(int* nums, int numsSize) &#123; int res = 0; for (int i = 0; i &lt; numsSize; i++)&#123; res ^= nums[i]; &#125; return res;&#125; 结果：15 / 15 test cases passed.Status: AcceptedRuntime: 8 ms","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.iamxcc.com/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.iamxcc.com/tags/LeetCode/"},{"name":"Bit Manupulation","slug":"Bit-Manupulation","permalink":"http://blog.iamxcc.com/tags/Bit-Manupulation/"}]},{"title":"51NOD 1005: 排序","slug":"51NOD-1005-排序","date":"2016-07-31T16:31:39.000Z","updated":"2016-07-31T16:36:51.004Z","comments":true,"path":"2016/08/01/51NOD-1005-排序/","link":"","permalink":"http://blog.iamxcc.com/2016/08/01/51NOD-1005-排序/","excerpt":"题目描述：给出N个整数，对着N个整数进行排序。","text":"题目描述：给出N个整数，对着N个整数进行排序。 input第1行：整数的数量N（1 &lt;= N &lt;= 50000)第2 - N + 1行：待排序的整数（-10^9 &lt;= A[i] &lt;= 10^9） output共n行，按照递增序输出排序好的数据。 input示例554321 output示例1234512345678910111213141516171819202122#include &lt;stdio.h&gt;int cmp(const int* a, const int* b)&#123; return *a - *b;&#125;int main()&#123; int numsSize, nums[50000]; scanf(\"%d\", &amp;numsSize); for(int i=0; i&lt;numsSize; i++) &#123; scanf(\"%d\", &amp;nums[i]); &#125; qsort(nums, numsSize, sizeof(int), cmp); for(int i=0; i&lt;numsSize; i++) &#123; printf(\"%d\\n\", nums[i]); &#125; return 0;&#125;","categories":[{"name":"51NOD","slug":"51NOD","permalink":"http://blog.iamxcc.com/categories/51NOD/"}],"tags":[{"name":"51NOD","slug":"51NOD","permalink":"http://blog.iamxcc.com/tags/51NOD/"}]},{"title":"贪心算法入门","slug":"贪心算法入门","date":"2016-07-31T16:10:35.000Z","updated":"2016-08-06T12:12:39.889Z","comments":true,"path":"2016/08/01/贪心算法入门/","link":"","permalink":"http://blog.iamxcc.com/2016/08/01/贪心算法入门/","excerpt":"约翰认为字符串的完美度等于它里面所有字母的完美度之和。每个字母的完美度可以由你来分配，不同字母的完美度不同，分别对应一个1-26之间的整数。","text":"约翰认为字符串的完美度等于它里面所有字母的完美度之和。每个字母的完美度可以由你来分配，不同字母的完美度不同，分别对应一个1-26之间的整数。 约翰不在乎字母大小写。（也就是说字母F和f）的完美度相同。给定一个字符串，输出它的最大可能的完美度。例如：dad，你可以将26分配给d，25分配给a，这样整个字符串完美度为77。 分析： 由排序不等式，出现次数最多的字母显然应该给26。所以这个题目变成了统计每种字母出现的次数了，然后按照出现次数从大到小，依次分配从高到低的权值。这就是最朴素的贪心思想。123456789101112131415161718192021222324252627#include&lt;stdio.h&gt;#include&lt;string.h&gt;int cmp(const char* a, const char* b)&#123; return *a - *b;&#125;int main()&#123; char str[100]; scanf(\"%s\", str); int strSize; strSize = strlen(str); qsort(str, strSize, sizeof(char), cmp); int res = 26; int maxValue = 26; for (int i = strSize - 1; i &gt;= 1; i--) &#123; if (str[i] != str[i - 1]) &#123; maxValue--; &#125; res += maxValue; &#125; printf(\"%d\", res);&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://blog.iamxcc.com/categories/算法/"}],"tags":[{"name":"贪心算法","slug":"贪心算法","permalink":"http://blog.iamxcc.com/tags/贪心算法/"}]},{"title":"LeetCode 229: Majority Element II","slug":"LeetCode-229-Majority-Element-II","date":"2016-07-31T14:29:46.000Z","updated":"2016-08-02T00:32:08.475Z","comments":true,"path":"2016/07/31/LeetCode-229-Majority-Element-II/","link":"","permalink":"http://blog.iamxcc.com/2016/07/31/LeetCode-229-Majority-Element-II/","excerpt":"Given an integer array of size n, find all elements that appear more than ⌊ n/3 ⌋ times. The algorithm should run in linear time and in O(1) space.","text":"Given an integer array of size n, find all elements that appear more than ⌊ n/3 ⌋ times. The algorithm should run in linear time and in O(1) space.Hint: How many majority elements could it possibly have? Do you have a better hint? Suggest it! 题意思路这道题让我们求出现次数大于n/3的众数，而且限定了时间和空间复杂度，那么就不能排序，也不能使用哈希表，这么苛刻的限制条件只有一种方法能解了，那就是摩尔投票法 Moore Voting，这种方法在之前那道题Majority Element 求众数中也使用了。题目中给了一条很重要的提示，让我们先考虑可能会有多少个众数。那么有了这个信息，我们使用投票法的核心是找出两个候选众数进行投票，需要两遍遍历，第一遍历找出两个候选众数，第二遍遍历重新投票验证这两个候选众数是否为众数即可，选候选众数方法和前面那篇Majority Element 求众数一样，由于之前那题题目中限定了一定会有众数存在，故而省略了验证候选众数的步骤，这道题却没有这种限定，即满足要求的众数可能不存在，所以要有验证。代码如下： 代码C语言版本：123456789101112131415161718192021222324252627282930313233343536373839404142/** * Return an array of size *returnSize. * Note: The returned array must be malloced, assume caller calls free(). */int* majorityElement(int* nums, int numsSize, int* returnSize) &#123; int* res = (int*)malloc(sizeof(int)*numsSize); int firstNum = 0, secondNum = 0, countFN = 0, countSN = 0; for(int i=0; i&lt;numsSize; i++)&#123; if (nums[i] == firstNum)&#123; countFN++; &#125;else if (nums[i] == secondNum)&#123; countSN++; &#125;else if (countFN == 0)&#123; firstNum = nums[i]; countFN = 1; &#125;else if (countSN == 0)&#123; secondNum = nums[i]; countSN = 1; &#125;else&#123; countFN--; countSN--; &#125; &#125; countFN = countSN = 0; for (int i=0; i&lt;numsSize; i++) &#123; if (nums[i] == firstNum)&#123; ++countFN; &#125; else if (nums[i] == secondNum)&#123; ++countSN; &#125; &#125; if (countFN &gt; numsSize/3)&#123; res[0] = firstNum; &#125; if (countSN &gt; numsSize/3)&#123; res[1] = secondNum; &#125; *returnSize = numsSize; return res; &#125; C++版本：12345678910111213141516171819202122class Solution &#123;public: vector&lt;int&gt; majorityElement(vector&lt;int&gt;&amp; nums) &#123; vector&lt;int&gt; res; int m = 0, n = 0, cm = 0, cn = 0; for (auto &amp;a : nums) &#123; if (a == m) ++cm; else if (a ==n) ++cn; else if (cm == 0) m = a, cm = 1; else if (cn == 0) n = a, cn = 1; else --cm, --cn; &#125; cm = cn = 0; for (auto &amp;a : nums) &#123; if (a == m) ++cm; else if (a == n) ++cn; &#125; if (cm &gt; nums.size() / 3) res.push_back(m); if (cn &gt; nums.size() / 3) res.push_back(n); return res; &#125;&#125;;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.iamxcc.com/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.iamxcc.com/tags/LeetCode/"},{"name":"Array","slug":"Array","permalink":"http://blog.iamxcc.com/tags/Array/"}]},{"title":"LeetCode 169 Majority Element","slug":"LeetCode-169-Majority-Element","date":"2016-07-31T13:40:08.000Z","updated":"2016-08-03T08:17:54.905Z","comments":true,"path":"2016/07/31/LeetCode-169-Majority-Element/","link":"","permalink":"http://blog.iamxcc.com/2016/07/31/LeetCode-169-Majority-Element/","excerpt":"Given an array of size n, find the majority element. The majority element is the element that appears more than n/2 times.","text":"Given an array of size n, find the majority element. The majority element is the element that appears more than n/2 times.You may assume that the array is non-empty and the majority element always exist in the array. 题意代码C语言版本：1234567891011121314int majorityElement(int* nums, int numsSize) &#123; int major=nums[0], count = 1; for(int i=1; i&lt;numsSize;i++)&#123; if(count==0)&#123; count++; major=nums[i]; &#125;else if(major==nums[i])&#123; count++; &#125;else&#123; count--; &#125; &#125; return major;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.iamxcc.com/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.iamxcc.com/tags/LeetCode/"},{"name":"Array","slug":"Array","permalink":"http://blog.iamxcc.com/tags/Array/"}]},{"title":"LeetCode 238: Product of Array Except Self","slug":"LeetCode-238-Product-of-Array-Except-Self","date":"2016-07-31T13:28:39.000Z","updated":"2016-08-03T08:18:02.665Z","comments":true,"path":"2016/07/31/LeetCode-238-Product-of-Array-Except-Self/","link":"","permalink":"http://blog.iamxcc.com/2016/07/31/LeetCode-238-Product-of-Array-Except-Self/","excerpt":"Given an array of n integers where n &gt; 1, nums, return an array output such that output[i] is equal to the product of all the elements of nums except nums[i].","text":"Given an array of n integers where n &gt; 1, nums, return an array output such that output[i] is equal to the product of all the elements of nums except nums[i].Solve it without division and in O(n).For example, given [1,2,3,4], return [24,12,8,6]. 题意代码1234567891011121314151617/** * Return an array of size *returnSize. * Note: The returned array must be malloced, assume caller calls free(). */int* productExceptSelf(int* nums, int numsSize, int* returnSize) &#123; int* res = (int*)malloc(sizeof(int)*numsSize); //the result array; for (int i = 0, tmp = 1; i &lt; numsSize; i++) &#123; res[i] = tmp; tmp *= nums[i]; &#125; for (int i = numsSize - 1, tmp = 1; i &gt;= 0; i--) &#123; res[i] *= tmp; tmp *= nums[i]; &#125; *returnSize = numsSize; return res;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.iamxcc.com/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.iamxcc.com/tags/LeetCode/"},{"name":"Array","slug":"Array","permalink":"http://blog.iamxcc.com/tags/Array/"}]},{"title":"异或^的妙用","slug":"异或-的妙用","date":"2016-07-31T08:33:10.000Z","updated":"2016-07-31T10:15:51.434Z","comments":true,"path":"2016/07/31/异或-的妙用/","link":"","permalink":"http://blog.iamxcc.com/2016/07/31/异或-的妙用/","excerpt":"最近在做一些算法题的时候，发现了异或很好使，经常有一些很妙的点子是通过它来实现的。所以特别在这里记录一下","text":"最近在做一些算法题的时候，发现了异或很好使，经常有一些很妙的点子是通过它来实现的。所以特别在这里记录一下，方便下次使用与学习。 两数交换如果不用这三个参数就实现两数的交换的话，可以使用异或^来实现,代码如下：123456void swap(int &amp;a,int &amp;b) //通过异或交换两者的值&#123; a =a^b; b= a^b; a = b^a;&#125; 找出0, 1, 2, …, n序列中缺了哪个数这是LeetCode 268 Missing Number的题，代码如下:1234567int missingNumber(int* nums, int numsSize) &#123; int res = numsSize; for(int i = 0; i &lt; numsSize; i++)&#123; res ^= i ^ nums[i]; &#125; return res;&#125; 暂时只有这两个妙处，下次还有的话，再添加。","categories":[{"name":"算法","slug":"算法","permalink":"http://blog.iamxcc.com/categories/算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://blog.iamxcc.com/tags/算法/"}]},{"title":"LeetCode 268: Missing Number","slug":"Leetcode-268-Missing-Number-C语言","date":"2016-07-31T07:55:31.000Z","updated":"2016-08-03T08:18:09.353Z","comments":true,"path":"2016/07/31/Leetcode-268-Missing-Number-C语言/","link":"","permalink":"http://blog.iamxcc.com/2016/07/31/Leetcode-268-Missing-Number-C语言/","excerpt":"Given an array containing n distinct numbers taken from 0, 1, 2, …, n, find the one that is missing from the array.","text":"Given an array containing n distinct numbers taken from 0, 1, 2, …, n, find the one that is missing from the array.For example,Given nums = [0, 1, 3] return 2.Note: Your algorithm should run in linear runtime complexity. Could you implement it using only constant extra space complexity? 题意考虑一个包含n个不同数字的数组，以0, 1, 2, …, n,的顺序排列，找到一个数组中缺失的数字。比如，nums = [0, 1, 3]则返回2。 程序以我这渣渣水平，一看到题目就想到了一个很渣的算法，如下：123456789101112131415161718192021222324int cmp(const int* a, const int* b)&#123; return *a - *b;&#125;int missingNumber(int* nums, int numsSize) &#123; int left = 0; int right = 1; int flag = 0; qsort(nums, numsSize, sizeof(int), cmp); if (numsSize == 1)&#123; return nums[0]?0:1; &#125; while (right&lt;numsSize)&#123; if ( (nums[right]-nums[left]) != 1 )&#123; flag++; return nums[right]-1; &#125; left++; right++; &#125; if (!flag)&#123; return nums[0]?0:(nums[numsSize-1]+1); &#125; return false;&#125; 结果可以想象得到：121 / 121 test cases passed.Status: AcceptedRuntime: 28 ms看了一下，结果果然很渣，打败了4.37%的人。后来上网学习到了一种很吊的：1234567int missingNumber(int* nums, int numsSize) &#123; int res = numsSize; for(int i = 0; i &lt; numsSize; i++)&#123; res ^= i ^ nums[i]; &#125; return res;&#125; 结果很感人：121 / 121 test cases passed.Status: AcceptedRuntime: 12 ms","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.iamxcc.com/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.iamxcc.com/tags/LeetCode/"},{"name":"Array","slug":"Array","permalink":"http://blog.iamxcc.com/tags/Array/"}]},{"title":"hexo主题中使用mathjax来支持LaTex公式","slug":"hexo主题中使用mathjax来支持latex公式","date":"2016-07-31T05:19:44.000Z","updated":"2016-07-31T06:42:08.750Z","comments":true,"path":"2016/07/31/hexo主题中使用mathjax来支持latex公式/","link":"","permalink":"http://blog.iamxcc.com/2016/07/31/hexo主题中使用mathjax来支持latex公式/","excerpt":"今天发现在要写很多公式时，页面显示会有点乱。或者要表达一些复杂的符号时，发现不知道怎么写出来。","text":"今天发现在要写很多公式时，页面显示会有点乱。或者要表达一些复杂的符号时，发现不知道怎么写出来。后来上网查了一下发现有mathjax这个东西，实在好用。 使用步骤因为mathjax这个js文件每次加载都有点慢，而且很多时候并用不到这个插件，所以我们的策略是按是否需要使用为前提而加载。而且如果哪天我们都不需要mathjax了，我们还要加上全局的控制的功能。所以为了实现上面的功能，我们需要修改几个文件。 主题的_config.yml文件在主题文件夹下的_config.yml中加入下面的代码，为了实现全局的控制，这里加上enable: true, false的话就会全站禁止了12345678# ---------------------------------------------------------------# Third Party Services Settings # ---------------------------------------------------------------# MathJax Supportmathjax: enable: true cdn: http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML 上面的cdn觉得慢的话，可以自己找一个。 按文章加载在文章需要调用 Mathjax 时, 只需在 front-matter 前加上 mathjax: true 即可, 即12345678---title: hexo主题中使用mathjax来支持LaTex公式date: 2016-07-31 13:19:44tags: [LaTex, hexo]categories: hexothumbnail: http://7xveyh.com1.z0.glb.clouddn.com/latex_latin_symbols.jpgmathjax: true--- 加载mathjax文件有了上面的修改，这时候就可以按需要加载mathjax脚本文件了。我主题加载js文件都是在script.ejs中判断后加载的(你们可以根据自己的情况来处理)，所以这里加上下面这段代码：123&lt;% if (page.mathjax)&#123; %&gt; &lt;%- partial(&apos;plugin/mathjax&apos;) %&gt;&lt;% &#125; %&gt; 上面代码说明如果mardkown文件中写了上面说的mathjax: ture，那么if条件为ture，则加载plugin/mathjax mathjax.ejs文件123456789101112131415161718192021&lt;% if (theme.mathjax.enable)&#123; %&gt; &lt;script type=\"text/x-mathjax-config\"&gt; MathJax.Hub.Config(&#123; tex2jax: &#123; inlineMath: [ ['$','$'], [\"\\\\(\",\"\\\\)\"] ], processEscapes: true, skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'] &#125; &#125;); &lt;/script&gt; &lt;script type=\"text/x-mathjax-config\"&gt; MathJax.Hub.Queue(function() &#123; var all = MathJax.Hub.getAllJax(), i; for (i=0; i &lt; all.length; i += 1) &#123; all[i].SourceElement().parentNode.className += ' has-jax'; &#125; &#125;); &lt;/script&gt; &lt;script type=\"text/javascript\" src=\"&lt;%= theme.mathjax.cdn %&gt;\"&gt;&lt;/script&gt;&lt;% &#125; %&gt; 可以看到代码中的theme.mathjax.cdn就是主题配置文件中的mathjax下的cdn啦。 说明我的主题使用的是ejs模板语言写的，如果是swig或者其他语言，还要稍微修改一下，具体怎么改可以上网搜索一下。下面放张效果图：","categories":[{"name":"hexo","slug":"hexo","permalink":"http://blog.iamxcc.com/categories/hexo/"}],"tags":[{"name":"LaTex","slug":"LaTex","permalink":"http://blog.iamxcc.com/tags/LaTex/"},{"name":"hexo","slug":"hexo","permalink":"http://blog.iamxcc.com/tags/hexo/"}]},{"title":"归并排序","slug":"归并排序","date":"2016-07-31T03:06:33.000Z","updated":"2016-07-31T06:01:29.389Z","comments":true,"path":"2016/07/31/归并排序/","link":"","permalink":"http://blog.iamxcc.com/2016/07/31/归并排序/","excerpt":"归并排序以O(NlogN)最坏情形运行时间运行，而所使用的比较次数几乎是最优的。它是递归算法一个很好的实例。","text":"归并排序以O(NlogN)最坏情形运行时间运行，而所使用的比较次数几乎是最优的。它是递归算法一个很好的实例。这个算法中基本的操作是合并两个已排序的表。因为这两个表是已排序的，所以若将输出放到第三个表中时则该算法可以通过对输入数据一趟排序来完成。 归并排序代码归并排序分为三个函数，分别是：mSort函数、merge函数、mergeSort函数。其中merge函数是将不断输入的数据排序并归并。mSort函数是利用递归的想法分而治之，分治是递归非常有力的用法。mergeSort函数是起到调用前面两个函数与分配临时空间的作用。 mSort函数123456789101112void mSort( int nums[], int tmpNums[], int left, int right )&#123; int center; if ( left &lt; right ) &#123; center = (left + right) / 2; mSort(nums, tmpNums, left, center); mSort(nums, tmpNums, center + 1 , right); merge(nums, tmpNums, left, center + 1, right); &#125;&#125; merge函数12345678910111213141516171819202122232425262728293031323334void merge(int nums[], int tmpNums[], int lPos, int rPos, int rightEnd)&#123; int i, leftEnd, numsElement, tmpPos; leftEnd = rPos - 1; tmpPos = lPos; numsElement = rightEnd - lPos + 1; while (lPos &lt;= leftEnd &amp;&amp; rPos &lt;= rightEnd) &#123; if (nums[lPos] &lt;= nums[rPos]) &#123; tmpNums[tmpPos++] = nums[lPos++]; &#125; else &#123; tmpNums[tmpPos++] = nums[rPos++]; &#125; &#125; while (lPos &lt;= leftEnd) &#123; tmpNums[tmpPos++] = nums[lPos++]; &#125; while (rPos &lt;= rightEnd) &#123; tmpNums[tmpPos++] = nums[rPos++]; &#125; for (i = 0; i &lt; numsElement; i++, rightEnd--) &#123; nums[rightEnd] = tmpNums[rightEnd]; &#125;&#125; mergeSort函数1234567891011121314void mergeSort(int nums[], int N)&#123; int *tmpNums; tmpNums = malloc(N * sizeof(int)); if (tmpNums != NULL) &#123; mSort(nums, tmpNums, 0, N - 1); free(tmpNums); &#125; else &#123; printf(\"No space for tmp array\"); &#125;&#125; main函数123456789101112#include&lt;stdio.h&gt;int main(int argc, char *argv[])&#123; int nums[10] = &#123; 5, 3, 4, 1, 6, 10, 12, 2, 23, 9 &#125;; mergeSort(nums, 10); int i; for (i = 0; i&lt;10; i++) &#123; printf(\"%d\\n\", nums[i]); &#125;&#125; 归并排序的分析假设N是2的幂，从而我们总可以将它分裂成均为偶数的两部分。对于N-1，归并排序时间是常数，我们将记为1.否则，对N个数归并并排序的用时等于完成两个大小为N/2的递归排序所用的时间再加上合并的时间， 它是线性的。下面方程给出准确的表示：$$ T(1) = 1 $$$$ T(N) = 2T(\\frac N2) + N $$将上式两边同时除以N有：$$ \\frac{T(N)}{N} = {T(\\frac N2)\\over(\\frac N2)} + 1 $$该方程对2的幂的任意的N是成立的，我们还可以写成：$$ {T(\\frac N2)\\over(\\frac N2)} = {T(\\frac N4)\\over(\\frac N4)} +1 $$$$ ...$$$$ {T(2)\\over2} = {T(1)\\over1} + 1 $$将上式相加，并约掉可以得到：$$ {T(N)\\over N} = {T(1)\\over1} + logN $$两边同时乘以N得到：$$ T(N) = N + NlogN = O(NlogN) $$","categories":[{"name":"排序","slug":"排序","permalink":"http://blog.iamxcc.com/categories/排序/"}],"tags":[{"name":"排序算法","slug":"排序算法","permalink":"http://blog.iamxcc.com/tags/排序算法/"}]},{"title":"Leetcode 283: Move Zeroes","slug":"Leetcode-283-Move-Zeroes","date":"2016-07-30T10:48:47.000Z","updated":"2016-08-03T08:18:14.081Z","comments":true,"path":"2016/07/30/Leetcode-283-Move-Zeroes/","link":"","permalink":"http://blog.iamxcc.com/2016/07/30/Leetcode-283-Move-Zeroes/","excerpt":"Given an array nums, write a function to move all 0’s to the end of it while maintaining the relative order of the non-zero elements.","text":"Given an array nums, write a function to move all 0’s to the end of it while maintaining the relative order of the non-zero elements.For example, given nums = [0, 1, 0, 3, 12], after calling your function, nums should be [1, 3, 12, 0, 0].Note: You must do this in-place without making a copy of the array. Minimize the total number of operations. 题意考虑一个数组，写一个函数使用该数组的0移动到数组尾部，而非零的数保持一定的顺序。比如，给一个数组nums =[0, 1, 0, 3, 12],经过该函数处理后，nums应该变为[1, 3, 12, 0, 0]; 程序(C语言)123456789101112131415161718192021void swap(int* nums, int left, int right)&#123; if (left == right)&#123; return; &#125;else&#123; nums[left] ^= nums[right]; nums[right] ^= nums[left]; nums[left] ^= nums[right]; &#125;&#125;void moveZeroes(int* nums, int numsSize)&#123; int left = 0; int right = 0; while (right &lt; numsSize)&#123; if (nums[right] != 0)&#123; swap(nums, left, right); left++; &#125; right++; &#125;&#125; 结果21 / 21 test cases passed.Status: AcceptedRuntime: 8 ms","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.iamxcc.com/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.iamxcc.com/tags/LeetCode/"},{"name":"Array","slug":"Array","permalink":"http://blog.iamxcc.com/tags/Array/"}]},{"title":"Leetcode 217: Contains Duplicate","slug":"Leetcode-217-Contains-Duplicate","date":"2016-07-30T10:34:47.000Z","updated":"2016-08-03T08:17:41.745Z","comments":true,"path":"2016/07/30/Leetcode-217-Contains-Duplicate/","link":"","permalink":"http://blog.iamxcc.com/2016/07/30/Leetcode-217-Contains-Duplicate/","excerpt":"Given an array of integers, find if the array contains any duplicates. Your function should return true if any value appears at least twice in the array","text":"Given an array of integers, find if the array contains any duplicates. Your function should return true if any value appears at least twice in the array,and it should return false if every element is distinct. 题意大概为, 考虑一个整型的数组，找出是否该数组有重复的数。如果有数出现超过两次，那么你的函数返回ture，否则返回false。 程序(C语言)12345678910111213141516int cmp(const int* a, const int* b)&#123; return *a - *b;&#125;bool containsDuplicate(int* nums, int numsSize) &#123; qsort(nums, numsSize, sizeof(int), cmp); if (numsSize &lt; 2)&#123; return false; &#125; int i; for (i=0; i&lt;(numsSize-1); i++)&#123; if (nums[i] == nums[i+1])&#123; return true; &#125; &#125; return false;&#125; 结果16 / 16 test cases passed.Status: AcceptedRuntime: 12 ms","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.iamxcc.com/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.iamxcc.com/tags/LeetCode/"},{"name":"Array","slug":"Array","permalink":"http://blog.iamxcc.com/tags/Array/"}]},{"title":"C函数qsort的用法","slug":"C函数qsort用法","date":"2016-07-30T07:37:31.000Z","updated":"2016-07-30T23:18:34.435Z","comments":true,"path":"2016/07/30/C函数qsort用法/","link":"","permalink":"http://blog.iamxcc.com/2016/07/30/C函数qsort用法/","excerpt":"qsort()函数是ANSI C标准中提供的，其声明在stdlib.h文件中，是根据二分发写的，其时间复杂度为n*log(n)。","text":"qsort()函数是ANSI C标准中提供的，其声明在stdlib.h文件中，是根据二分发写的，其时间复杂度为n*log(n)。为了了解 排序方式排序方式有很多种，比如：选择排序、冒泡排序、归并排序、快速排序等等。顾名思义快速排序是目前公认的一种比较好的排序算法，其比选择排序、冒泡排序都要快。因为它的速度很快，所以系统也在库里实现这个算法，便于我们使用，这个函数就是qsort了。 qsort简介qsort的函数原型是:1void qsort(void* base, size_t nelem, size_t width, cmp) 其中： *base为要排序的数组 nelem为要排序的数组的长度 width为每个数组元素的大小(以字节为单位) cmp为自己定义的比较函数，其作用在于方便使用者实现对数组、字符串、结构体等结构进行升序或降序排列。 cmp函数1int cmp(const void *a, const void *b) cmp函数中有两个元素作为参数，返回一个int值，如果比较函数返回大于0，qsort就认为a&gt;b；如果返回等于0，qsort就认为a=b；如果返回小于0，qsort就认为a小于b。因此，qsort函数知道元素大小，就可以把大的放到前面去。如果你把cmp函数的返回值1与-1的位置调换，那么就造成了升降序的差别了。 实例操作为了加深理解，下面以数组、字符串、结构体为例说明情况 对int数组进行排序12345int nums[100];int cmp ( const void *a , const void *b )&#123; return *(int *)a - *(int *)b; &#125;qsort(num,100,sizeof(num[0]),cmp); 对char类型数组排序12345char word[100];int cmp( const void *a , const void *b )&#123; return *(char *)a - *(int *)b;&#125;qsort(word,100,sizeof(word[0]),cmp); 对double类型数组排序12345double nums[100];int cmp( const void *a , const void *b )&#123; return *(double *)a - *(double *)b;&#125;qsort(nums,100,sizeof(nums[0]),cmp); 对结构体类型排序1234567891011struct Node&#123; double data; int other; &#125;s[100]//按照data的值从小到大将结构体排序,关于结构体内的排序关键数据data的类型可以很多种，//参考上面的例子写int cmp( const void *a ,const void *b)&#123; return (*(Node *)a).data - (*(Node *)b).data ? 1 : -1; &#125;qsort(s,100,sizeof(s[0]),cmp); 对结构体二级排序123456789101112131415struct Node&#123; int x; int y; &#125;s[100];//按照x从小到大排序，当x相等时按照y从大到小排序int cmp( const void *a , const void *b )&#123; struct Node *c = (Node *)a; struct Node *d = (Node *)b; if(c-&gt;x != d-&gt;x) return c-&gt;x - d-&gt;x; else return d-&gt;y - c-&gt;y;&#125;qsort(s,100,sizeof(s[0]),cmp); 对字符串进行排序12345678910struct Node &#123; int data; char str[100]; &#125;s[100];//按照结构体中字符串str的字典顺序排序int cmp ( const void *a , const void *b )&#123; return strcmp( (*(Node *)a)-&gt;str , (*(Node *)b)-&gt;str );&#125;qsort(s,100,sizeof(s[0]),cmp);","categories":[{"name":"C语言","slug":"C语言","permalink":"http://blog.iamxcc.com/categories/C语言/"}],"tags":[{"name":"C语言","slug":"C语言","permalink":"http://blog.iamxcc.com/tags/C语言/"}]},{"title":"win10取消开机密码","slug":"win10取消开机密码","date":"2016-07-30T07:16:48.000Z","updated":"2016-07-30T23:19:17.582Z","comments":true,"path":"2016/07/30/win10取消开机密码/","link":"","permalink":"http://blog.iamxcc.com/2016/07/30/win10取消开机密码/","excerpt":"每次自己或者帮家人取消win10开机密码时，都要上网查一下攻略，虽然很简单，但是为了下次不那么麻烦。","text":"每次自己或者帮家人取消win10开机密码时，都要上网查一下攻略，虽然很简单，但是为了下次不那么麻烦。这里就把这个教程记录下来。 步骤 首先，在电脑中点击桌面左下角的开始菜单图标，在出现的开始菜单界面中的搜索框中输入netplwiz，然后在搜索结果中点击最上面的netplwiz。或者cmd+R再输入netplwiz也一样。 然后在弹出的界面中定位到用户或者user选项卡菜单界面，取消勾选要使用本计算机，用户必须...，然后点击确定按钮，如图所示。 输入你的电脑的登录密码，并且重新确认一下，最后点击“确定”按钮保存退出。 这样下次开机的时候就不用输入密码，不过如果是睡眠重启的话还是需要密码的。","categories":[{"name":"Win10","slug":"Win10","permalink":"http://blog.iamxcc.com/categories/Win10/"}],"tags":[{"name":"Win10","slug":"Win10","permalink":"http://blog.iamxcc.com/tags/Win10/"}]},{"title":"Git上传时出现error","slug":"git上传时出现error","date":"2016-07-27T05:24:55.000Z","updated":"2016-07-30T07:30:39.698Z","comments":true,"path":"2016/07/27/git上传时出现error/","link":"","permalink":"http://blog.iamxcc.com/2016/07/27/git上传时出现error/","excerpt":"今天使用git上传文件到github上时出现错误，提示是error: src refspec master does not match any，后来上网查了一下，问题解决了。","text":"今天使用git上传文件到github上时出现错误，提示是error: src refspec master does not match any，后来上网查了一下，问题解决了。为了防止以后再遇到类似问题又给忘记了，所以还是把这个方法简单记录在此。 git工作大致流程 1、在github上创建项目 2、使用git clone https://github.com/xxxxxxx/xxxxx.git克隆到本地 3、编辑项目 4、git add . （将改动添加到暂存区） 5、git commit -m “提交说明” 6、git push origin master 将本地更改推送到远程master分支。 这样你就完成了向远程仓库的推送。 解决措施如果在github的remote上已经有了文件，会出现错误。此时应当先pull一下，即：1git pull origin master 然后再进行：1git push origin master 这样就不会出现错误提示了。","categories":[{"name":"Git","slug":"Git","permalink":"http://blog.iamxcc.com/categories/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://blog.iamxcc.com/tags/Git/"}]},{"title":"Git命令add和commit的区别","slug":"Git命令add和commit的区别","date":"2016-07-27T00:42:34.000Z","updated":"2016-07-27T05:25:47.684Z","comments":true,"path":"2016/07/27/Git命令add和commit的区别/","link":"","permalink":"http://blog.iamxcc.com/2016/07/27/Git命令add和commit的区别/","excerpt":"要想弄明白git add和git commit的区别，首先我们需要知道三个概念：工作区(Working Directory)、版本库(Repository)、暂存区(Stage or index)。","text":"要想弄明白git add和git commit的区别，首先我们需要知道三个概念：工作区(Working Directory)、版本库(Repository)、暂存区(Stage or index)。 工作区当你在开发一个项目时，主目录就是你的工作区。 版本库工作区中有一个隐藏目录.git，这个就是git的版本库了。 暂存区Git的版本库里存了很多文件，其中包括称为Stage或index的暂存区，还有一个git为我们自动创建的第一个分支master，以及指向master的一个指针HEAD。下面就是三个区的示意图：图片来着廖雪峰老师的 博客。 区别git add和git commit的区别就在于：git add把文件添加进去，实际上就是把文件修改添加到暂存区；git commit提交更改，实际上就是把暂存区的所有内容提交到当前分支。因为我们创建Git版本库时，Git自动为我们创建了唯一一个master分支。所以，git commit就是往master分支上提交更改。你可以简单理解为，需要提交的文件修改通通放到暂存区，然后，一次性提交暂存区的所有修改。 所以要想将修改提交到master中一定要先git add到暂存区中，再git commit到master分支。","categories":[{"name":"Git","slug":"Git","permalink":"http://blog.iamxcc.com/categories/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://blog.iamxcc.com/tags/Git/"}]},{"title":"Win下Sublime3美化","slug":"Sublime3美化","date":"2016-07-26T11:20:15.000Z","updated":"2016-07-30T23:19:58.881Z","comments":true,"path":"2016/07/26/Sublime3美化/","link":"","permalink":"http://blog.iamxcc.com/2016/07/26/Sublime3美化/","excerpt":"虽然sublime3没有atom的高颜值，但是稍微美化一下也是上得了台面的，再加上极快的启动速度，简直是我心中的神器。","text":"虽然sublime3没有atom的高颜值，但是稍微美化一下也是上得了台面的，再加上极快的启动速度，简直是我心中的神器。 主题美化使用过很多sublime3的主题，最后在laracasts视频中发现了一款十分漂亮的主题Material Theme。废话不多说，下面是教程：首先在sublime中Ctrl+Shift+p出现一个输入面板，再在面板上输入install package确认后再次出现一个面板，此时输入Material theme确认后等待安装即可。安装完成后在Preference-&gt;Setting-User中输入一下代码：12&quot;color_scheme&quot;: &quot;Packages/Material Theme/schemes/Material-Theme.tmTheme&quot;,&quot;theme&quot;: &quot;Material-Theme.sublime-theme&quot;, 最后再重启一下即可。当然这个主题还有一些其他的设置，想要更详细的设置请看官网 PackageControl 编程字体的选择曾经有段时间我不断在寻找最舒服的编程字体，包括什么Source Code Pro、DeJaVu Sans Mono、Droid Sans Mono、CamingoCode、Courier New等等，但是都不太满意。比如Source Code Pro中i的头尖尖的看着让我感到别扭。其他几种各有各的缺点。最后终于发现了Fira Code，这是Firefox设计的一款字体。废话不多说上图说明：","categories":[{"name":"Sublime","slug":"Sublime","permalink":"http://blog.iamxcc.com/categories/Sublime/"}],"tags":[{"name":"Win10","slug":"Win10","permalink":"http://blog.iamxcc.com/tags/Win10/"},{"name":"Sublime","slug":"Sublime","permalink":"http://blog.iamxcc.com/tags/Sublime/"}]},{"title":"Sublime3快捷键整理","slug":"Sublime3快捷键整理","date":"2016-07-26T10:59:51.000Z","updated":"2016-07-30T23:20:06.672Z","comments":true,"path":"2016/07/26/Sublime3快捷键整理/","link":"","permalink":"http://blog.iamxcc.com/2016/07/26/Sublime3快捷键整理/","excerpt":"Sublime Text 3是我最喜欢而且使用最多的一个编辑器，因为他启动速度快，界面可以美化的十分性感与优雅。","text":"Sublime Text 3是我最喜欢而且使用最多的一个编辑器，因为他启动速度快，界面可以美化的十分性感与优雅。虽然自由度没有atom这么高，但是atom相比于Sublime速度实在是有点慢。下面是我整理的一些常用快捷键： Ctrl + g 跳转到相应的行Ctrl + m 在括号起始位置和终止位置之间切换Ctrl + Shift + m 选中括号内内容Ctrl + Shift + k 删除光标所在行Ctrl + Shift + up 当前行向上移动Ctrl + Shift + down 当前行向下移动Ctrl + l 选择光标所在行ctrl + t 交换相邻的两个字母","categories":[{"name":"Sublime","slug":"Sublime","permalink":"http://blog.iamxcc.com/categories/Sublime/"}],"tags":[{"name":"Sublime","slug":"Sublime","permalink":"http://blog.iamxcc.com/tags/Sublime/"}]},{"title":"WinSnap:带阴影的截图才是好截图","slug":"WinSnap-带阴影的截图才是好截图","date":"2016-07-26T09:39:20.000Z","updated":"2016-07-30T23:19:03.997Z","comments":true,"path":"2016/07/26/WinSnap-带阴影的截图才是好截图/","link":"","permalink":"http://blog.iamxcc.com/2016/07/26/WinSnap-带阴影的截图才是好截图/","excerpt":"我认为 OS X 内建的截图工具的最大优点就是自动加阴影。正所谓「再小的需求也应该被满足，是的，你可能发现了上文中所有","text":"我认为 OS X 内建的截图工具的最大优点就是自动加阴影。正所谓「再小的需求也应该被满足，是的，你可能发现了上文中所有的截图都是带有阴影的，真的就是 OS X 截图的那种阴影诶！ 如果你也像我一样对这个阴影喜爱有加，你一定需要 WinSnap 这款应用。仅仅 2MB，你便能够在 Windows 上完全实现 OS X 内建截图的效果，阴影和快捷键都不在话下，有过之无不及。 下载地址是：WinSnap ,这个是免安装版本的，下载后可以直接用了。上面的图片恰好是WinSnap热键的自定义菜单，可以根据自己的习惯调节一下","categories":[{"name":"Win10","slug":"Win10","permalink":"http://blog.iamxcc.com/categories/Win10/"}],"tags":[{"name":"Win10","slug":"Win10","permalink":"http://blog.iamxcc.com/tags/Win10/"},{"name":"工具","slug":"工具","permalink":"http://blog.iamxcc.com/tags/工具/"}]},{"title":"Win10上使用Mactype","slug":"Win10上使用Mactype","date":"2016-07-26T02:21:47.000Z","updated":"2016-07-30T23:19:36.867Z","comments":true,"path":"2016/07/26/Win10上使用Mactype/","link":"","permalink":"http://blog.iamxcc.com/2016/07/26/Win10上使用Mactype/","excerpt":"由于window系统上字体渲染很不舒服，故我一直使用mactype来改善一下。但是升级到win10后发现一打开mactype就出现黑屏或者打开界面显示有问题。","text":"由于window系统上字体渲染很不舒服，故我一直使用mactype来改善一下。但是升级到win10后发现一打开mactype就出现黑屏或者打开界面显示有问题。后面查了一些教程后发现在win10上还需要做一些文件替换。下面是教程： 安装首先，安装mactype，到网上随便找一个下载即可。这里提供了百度网盘的下载路径 Mactype。安装的话没什么需要特别注意的。 文件替换安装完成后，先不要打开mactype否则可能会出现黑屏等等问题。先打开mactype的安装目录，像我是在C:\\Program Files (x86)\\MacType这里，这时候用EasyHk32.dll、EasyHk64.dll、MacType.dll、MacType64.dll文件替换掉mactype安装目录下的对应文件。替换文件在刚刚提供的百度网盘里面有。此时打开mactype再设置一番就大功告成了。下面是效果图：可以看到效果还是十分明显的，mactype加载方式我是使用兼容加载的，用注册表加载可能很方便但是会导致较慢的开机速度。","categories":[{"name":"Mactype","slug":"Mactype","permalink":"http://blog.iamxcc.com/categories/Mactype/"}],"tags":[{"name":"Mactype","slug":"Mactype","permalink":"http://blog.iamxcc.com/tags/Mactype/"},{"name":"Win10","slug":"Win10","permalink":"http://blog.iamxcc.com/tags/Win10/"}]},{"title":"99%的人都理解错了HTTP中GET与POST的区别","slug":"99-的人都理解错了HTTP中GET与POST的区别","date":"2016-07-25T05:38:30.000Z","updated":"2016-07-30T23:20:41.884Z","comments":true,"path":"2016/07/25/99-的人都理解错了HTTP中GET与POST的区别/","link":"","permalink":"http://blog.iamxcc.com/2016/07/25/99-的人都理解错了HTTP中GET与POST的区别/","excerpt":"GET和POST是HTTP请求的两种基本方法，要说它们的区别，接触过WEB开发的人都能说出一二。最直观的区别就是GET把参数包含在URL中，POST通过request body传递参数。","text":"GET和POST是HTTP请求的两种基本方法，要说它们的区别，接触过WEB开发的人都能说出一二。最直观的区别就是GET把参数包含在URL中，POST通过request body传递参数。你可能自己写过无数个GET和POST请求，或者已经看过很多权威网站总结出的他们的区别，你非常清楚知道什么时候该用什么。当你在面试中被问到这个问题，你的内心充满了自信和喜悦。你轻轻松松的给出了一个“标准答案”： GET在浏览器回退时是无害的，而POST会再次提交请求。 GET产生的URL地址可以被Bookmark，而POST不可以。 GET请求会被浏览器主动cache，而POST不会，除非手动设置。 GET请求只能进行url编码，而POST支持多种编码方式。 GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。 GET请求在URL中传送的参数是有长度限制的，而POST么有。 对参数的数据类型，GET只接受ASCII字符，而POST没有限制。 GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。 GET参数通过URL传递，POST放在Request body中。（本标准答案参考自w3schools）“很遗憾，这不是我们要的回答！”请告诉我真相。。。如果我告诉你GET和POST本质上没有区别你信吗？让我们扒下GET和POST的外衣，坦诚相见吧！ GET和POST是什么？HTTP协议中的两种发送请求的方法。HTTP是什么？HTTP是基于TCP/IP的关于数据如何在万维网中如何通信的协议。HTTP的底层是TCP/IP。所以GET和POST的底层也是TCP/IP，也就是说，GET/POST都是TCP链接。GET和POST能做的事情是一样一样的。你要给GET加上request body，给POST带上url参数，技术上是完全行的通的。 那么，“标准答案”里的那些区别是怎么回事？ 在我大万维网世界中，TCP就像汽车，我们用TCP来运输数据，它很可靠，从来不会发生丢件少件的现象。但是如果路上跑的全是看起来一模一样的汽车，那这个世界看起来是一团混乱，送急件的汽车可能被前面满载货物的汽车拦堵在路上，整个交通系统一定会瘫痪。为了避免这种情况发生，交通规则HTTP诞生了。HTTP给汽车运输设定了好几个服务类别，有GET, POST, PUT, DELETE等等，HTTP规定，当执行GET请求的时候，要给汽车贴上GET的标签（设置method为GET），而且要求把传送的数据放在车顶上（url中）以方便记录。如果是POST请求，就要在车上贴上POST的标签，并把货物放在车厢里。当然，你也可以在GET的时候往车厢内偷偷藏点货物，但是这是很不光彩；也可以在POST的时候在车顶上也放一些数据，让人觉得傻乎乎的。HTTP只是个行为准则，而TCP才是GET和POST怎么实现的基本。 但是，我们只看到HTTP对GET和POST参数的传送渠道（url还是requrest body）提出了要求。“标准答案”里关于参数大小的限制又是从哪来的呢？ 在我大万维网世界中，还有另一个重要的角色：运输公司。不同的浏览器（发起http请求）和服务器（接受http请求）就是不同的运输公司。 虽然理论上，你可以在车顶上无限的堆货物（url中无限加参数）。但是运输公司可不傻，装货和卸货也是有很大成本的，他们会限制单次运输量来控制风险，数据量太大对浏览器和服务器都是很大负担。业界不成文的规定是，（大多数）浏览器通常都会限制url长度在2K个字节，而（大多数）服务器最多处理64K大小的url。超过的部分，恕不处理。如果你用GET服务，在request body偷偷藏了数据，不同服务器的处理方式也是不同的，有些服务器会帮你卸货，读出数据，有些服务器直接忽略，所以，虽然GET可以带request body，也不能保证一定能被接收到哦。 好了，现在你知道，GET和POST本质上就是TCP链接，并无差别。但是由于HTTP的规定和浏览器/服务器的限制，导致他们在应用过程中体现出一些不同。 你以为本文就这么结束了？ 我们的大BOSS还等着出场呢。。。 这位BOSS有多神秘？当你试图在网上找“GET和POST的区别”的时候，那些你会看到的搜索结果里，从没有提到他。他究竟是什么呢。。。 GET和POST还有一个重大区别，简单的说：GET产生一个TCP数据包；POST产生两个TCP数据包。 长的说：对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。 也就是说，GET只需要汽车跑一趟就把货送到了，而POST得跑两趟，第一趟，先去和服务器打个招呼“嗨，我等下要送一批货来，你们打开门迎接我”，然后再回头把货送过去。 因为POST需要两步，时间上消耗的要多一点，看起来GET比POST更有效。因此Yahoo团队有推荐用GET替换POST来优化网站性能。但这是一个坑！跳入需谨慎。为什么？ GET与POST都有自己的语义，不能随便混用。 据研究，在网络环境好的情况下，发一次包的时间和发两次包的时间差别基本可以无视。而在网络环境差的情况下，两次包的TCP在验证数据包完整性上，有非常大的优点。 并不是所有浏览器都会在POST中发送两次包，Firefox就只发送一次。 现在，当面试官再问你“GET与POST的区别”的时候，你的内心是不是这样的？","categories":[{"name":"HTTP","slug":"HTTP","permalink":"http://blog.iamxcc.com/categories/HTTP/"}],"tags":[{"name":"HTTP","slug":"HTTP","permalink":"http://blog.iamxcc.com/tags/HTTP/"},{"name":"GET","slug":"GET","permalink":"http://blog.iamxcc.com/tags/GET/"},{"name":"POST","slug":"POST","permalink":"http://blog.iamxcc.com/tags/POST/"}]},{"title":"Research directions for IOT","slug":"Research directions for IOT","date":"2016-07-20T00:57:18.000Z","updated":"2016-07-26T03:06:06.709Z","comments":true,"path":"2016/07/20/Research directions for IOT/","link":"","permalink":"http://blog.iamxcc.com/2016/07/20/Research directions for IOT/","excerpt":"As each individual system has its own assumptions and strategy to control the physical world variables without much knowledge of the other systems,","text":"As each individual system has its own assumptions and strategy to control the physical world variables without much knowledge of the other systems, which leads to conflicts when these systems are integrated without careful consideration. 1.What`s the problem of dependency in IOT?As each individual system has its own assumptions and strategy to control the physical world variables without much knowledge of the other systems, which leads to conflicts when these systems are integrated without careful consideration. Such problems arise in the cyber part mainly because each application has assumptions on the physical world entities without knowing how other applications work. Let’s use an example to better illustrate “what the problem of dependency” are: a home health care application may detect depression and decide to turn on all the lights. On the other hand, the energy management application may decide to turn off lights when no motion is detected. Detecting and resolving such dependency problems is important for correctness of operation of interacting IoT systems. The problem of dependencies are: App interdependency: It arises when one app relies on another app. If the independent app makes an error, the error may propagate and affect all the dependent apps and may cause a lot of conflicts in the system.t Control dependency for the sensors and actuators: It arises when multiple apps want to control a sensor in different ways.For example, App1 wants to run a humidifier and App2 wants to run a dehumidifier at the same time. Missing dependency: It arises when app developers forget to specify the dependency information of their apps. For example, App1 forgets to specify its dependency on light L1 in its meta data., but at runtime it tries to control L1. 2.What`s the major technologies to address the dependency issues in IOT?Cyber Physical system(CPS)We can propose a integrated CPS, a utility sensing and actuation system that provides comprehensive strategies to specify, detect, and resolve conflicts.This system consideres a comprehensive spectrum of dependencies and treating each system as an app. Each system communicates with its sensors and actuators and performs computations for taking appropriate control decisions to actuate on the physical world entities. App developers specify dependency information as meta data within their apps and their apps are put in an app store. Users can choose and install apps from the app store. This system can use the meta-data to detect and resolve conflicts at app installation time and at run-time. Let`s take some examples to introduce this ststem: addressing requirement dependency: This system reqiures developers to specify the requirement of each app in a manifest file written in XML.just like this : 123456789101112&lt;requirement&gt; &lt;device&gt; &lt;device_type&gt; x10_motion_sensor &lt;/device_type&gt; &lt;container&gt; room &lt;/container&gt; &lt;level&gt; strict &lt;/level&gt; &lt;/device&gt; &lt;device&gt; &lt;device_type&gt; x10_contact_sensor &lt;/device_type&gt; &lt;container&gt; window, door &lt;/container&gt; &lt;level&gt; strict &lt;/level&gt; &lt;/device&gt; &lt;/requirement&gt; Requirements can be either strict or loose. The motion sensor requirement is strict, which means that the app will not work without the motion sensors.But the app will still work without the contact sensors. adderssing actuator control dependency: Resolving control dependency of the actuators in a wrong way may cause death, e.g, granting an app’s request to turn off the breathing machine to save energy while it is being used by another health app.therefore, this system will detect such conflicts when two apps try to access the same device at the same time and resolve the conflict in favor of the higher priority app.It requires app developers to specify in XMLeffect,emphasis, and condition for each actuator that app wants to control. EffectEffect specifies the effect of an app on the environment when using a particular device.Two apps may be using completely different devices, but are conflicting with each orher by causing opposite effects.The XML tags can be increase, decrease, and change.For example, App1 may specify:123456&lt;device&gt; &lt;device_name&gt; humidifier &lt;/device_name&gt; &lt;effect&gt; &lt;humidity&gt; increase &lt;/humidity&gt; &lt;/effect&gt;&lt;/device&gt; On the other hand, App2 mey specify:123456&lt;device&gt; &lt;device_name&gt; humidifier &lt;/device_name&gt; &lt;effect&gt; &lt;humidity&gt; increase &lt;/humidity&gt; &lt;/effect&gt;&lt;/device&gt; When two apps have an opposite effect, they will not conflict. When two apps have an opposite effect, there is a chance that they will conflict at runtime. When two apps have the same effect, or mixed effect, system will look into emphasis andconditionto determine whether these apps will conflict or not. EmphasisEmphasis is based on the insight that not all control operations are equally important to an app, and emphasis allows an app to specify which device operation is more important than others.The security app mentioinsed above specifies its emphasis for controlling lights:123&lt;emphasis&gt; &lt;operation&gt; On() &lt;/operation&gt;&lt;/emphasis&gt; The energy app mentioned above specified above specifies its emphasis for controlling lights:1234&lt;emphasis&gt; &lt;operation&gt; On() &lt;/operation&gt; &lt;operation&gt; Off() &lt;/operation&gt;&lt;/emphasis&gt; when two apps have the same emphasis, then they are not conflicting with each other. if the emphasis of two apps is different, then they may be conflicting(also depends on conditions). ConditionTwo apps are not conflicting if they operate on a device with a mutually exclusive condition.The conditions can be categorized into two groups: (1)conditions based on time.(2)conditions based on event. Here are some example:1234&lt;start_time&gt; 20:00:00&lt;/start_time&gt;&lt;end_time&gt; 21:00:00 &lt;/end_time&gt;&lt;night&gt; duration &lt;/night&gt;&lt;sunset&gt; begin &lt;/sunset&gt; 3.What’s the questions and gaps that need to be filled in IoT system with examples?####SecurityA fundamental problem that must be solved in IOT is dealing with security problem.It worth to think about 3 security problem as follow: dependency issues – Do you know when something goes wrong?The aforementioned paragraph suggests that resolving control dependency of the actuators in a wrong way may cause death, e.g, granting an app’s request to turn off the breathing machine to save energy while it is being used by another health app. Data Encryption – Is your data protected?At a glance, many developers may be inclined to use SSL for secure communications. However, this can be problematic in an M2M application due to the additional processing power and memory required in a device to support SSL, and the increased wireless data costs that are a product of the increase in network communications overhead. Controlling access – Who can access your data/system?While encryption is demanded for private information, in some instances, confidentiality may be far less important than access and authentication. For example, the data transmitted with a wireless command to open your car door may not be confidential, but it is critical that no unauthorized parties have access to unlock the door through that system. PrivacyDespite the immense potential of IoT in the various spheres, the whole communication infrastructure of the IoT is flawed from the security standpoint and is susceptible to loss of privacy for the end users. Some of the most prominent security issues plaguing the entire developing IoT system arise out of the security issues present in the technologies used in IoT for information relay from one device to another. As such some of the prominent security issues stemming out from the communication technology are the following:( Wireless Sensor Networks (WSN) ) DoS attack on the physical layer:The physical layer of a wireless sensor network carries out the function of selection and generation of carrier frequency, modulation and demodulation, encryption and decryption, transmission and reception of data. This layer of the wireless sensor network is attacked mainly through Jamming: In this type of DoS attack occupies the communication channel between the nodes thus preventing them from communicating with each other. Node tampering: Physical tampering of the node to extract sensitive information is known as node tampering. DoS attack on the link layer:The link layer of WSN multiplexes the various data streams, provides detection of data frame, MAC and error control. Moreover the link layer ensures point-point or pointmultipoint reliability . The DoS attacks taking place in this layer are: Collision: This type of DoS attack can be initiated whentwo nodes simultaneously transmit packets of data on the same frequency channel. Unfairness: As described in , unfairness is a repeated collision based attack. It can also be referred to as exhaustion based attacks. Battery Exhaustion: This type of DoS attack causes unusually high traffic in a channel making its accessibility very limited to the nodes. Such a disruption in the channel is caused by a large number of requests (Request To Send) and transmissions over the channel. DoS attack on the network layer:The main function of the network layer of WSN is routing. The specific DoS attacks taking place in this layer are: Spoofing, replaying and misdirection of traffic. Hello flood attack: This attack causes high traffic in channels by congesting the channel with an unusually high number of useless messages. Here a single malicious node sends a useless message which is then replayed by the attacker to create a high traffic. Homing: In case of homing attack, a search is made in the traffic for cluster heads and key managers which have the capability to shut down the entire network. DoS attack on the transport layer:This layer of the WSN architecture provides reliability of data transmission and avoids congestion resulting from high traffic in the routers. The DoS attacks in this layer are: Flooding: It refers to deliberate congestion of communication channels through relay of unnecessary messages and high traffic. De-synchronization: In de-synchronization attack, fake messages are created at one or both endpoints requesting retransmissions for correction of non-existent error. This results in loss of energy in one or both the end-points in carrying out the spoofed instructions. ####Data ChallengeThe technologies to address the big data challenge already exist, like Hadoop or NoSQL, providing horizontal scalability, high capacity and parallel processing at prices that make them affordable and economical.With the development of wearables for consumers and the emerging use of smart machines the portion of IoT as a subset of big data will grow quickly forcing enterprises to think their infrastructure to enable scalability and to make them cost effective. ####Server TechnologiesThe impact of IoT on the server market will be largely focused on increased investment in key vertical industries and organizations related to those industries where IoT can be profitable, or add significant value.Some organizations that manage and consume data collected from a huge array of devices will require additional compute capacity and may well increase server budgets if there is a business case for it. ####Data Center NetworkExisting data center WAN (Wide Area Network) links have been built for moderate-bandwidth requirements created by our current use of technology. However, as the amount of data being transferred is set to increase dramatically, the need for expanded bandwidth grows.The result of all this, the research points out, is that because of the scale of the data being created it will no longer be economically feasible to store data at a single location. Reference[1] S. Munir and J. Stankovic, “DepSys: Dependency aware integration of systems for smart homes,” in Proc. ACM/IEEE Int. Conf. Cyber Phys. Syst.,Apr. 2014.[2] J. Stankovic, “When sensor, and actuator networks cover the world,invited keynote article,” ETRI J., vol. 30, no. 5, pp. 627–633, Oct. 2008.[3] Security. http://embedded-computing.com/guest-blogs/5-security-questions-for-your-next-iot-deployment/[4] Tuhin Borgohain, Uday Kumar, Sugata Sanyal. “Survey of Security and Privacy Issues of Internet of Things“. Fri, 9 Jan 2015.[5] “7 Big Problems with the Internet of Things”. http://www.cmswire.com/cms/internet-of-things/7-big-problems-with-the-internet-of-things-024571.php","categories":[{"name":"物联网","slug":"物联网","permalink":"http://blog.iamxcc.com/categories/物联网/"}],"tags":[{"name":"物联网","slug":"物联网","permalink":"http://blog.iamxcc.com/tags/物联网/"}]},{"title":"sass安装","slug":"sass安装","date":"2016-06-19T14:59:33.000Z","updated":"2016-07-30T23:20:15.928Z","comments":true,"path":"2016/06/19/sass安装/","link":"","permalink":"http://blog.iamxcc.com/2016/06/19/sass安装/","excerpt":"Sass 是最早的 CSS 预处理语言，有比 LESS 更为强大的功能，不过其一开始的缩进式语法（Sass老版本语法)并不能被大众接受","text":"Sass 是最早的 CSS 预处理语言，有比 LESS 更为强大的功能，不过其一开始的缩进式语法（Sass老版本语法)并不能被大众接受，不过由于其强大的功能和 Ruby on Rails 的大力推动，还是有很多开发者选择了 Sass。Sass 是采用 Ruby 语言编写的一款 CSS 预处理语言，它诞生于2007年，是最大的成熟的 CSS 预处理语言。最初它是为了配合 HAML（一种缩进式 HTML 预编译器）而设计的，因此有着和 HTML 一样的缩进式风格。 Ruby安装在 Windows 平台下安装 Ruby 需要先有 Ruby 安装包，大家可以到 Ruby 的 官网下载对应需要的 Ruby 版本。Ruby 安装文件下载好后，可以按应用软件安装步骤进行安装 Ruby。在安装过程中，个人建议将其安装在 C 盘下，在安装过程中选择第二个选项（不选中，就会出现编译时找不到Ruby环境的情况），如下图所示： Ruby 安装完成后，在开始菜单中找到新安装的 Ruby，并启动 Ruby 的 Command 控制面板，如下图所示： Sass安装当你的电脑中安装好 Ruby 之后，接下来就可以安装 Sass 了。同样的在windows下安装 Sass 有多种方法。但这几种方法都是非常的简单，只需要在你的命令终端输入一行命令即可。 1、通过命令安装 Sass打开电脑的命令终端，输入下面的命令：1gem install sass 提醒一下，在使用 Mac 的同学，可能需要在上面的命令前加上”sudo”，才能正常安装：1sudo gem install sass 如果上面的方法没有安装成功，可以使用下面的两种方法。 2、通过 Compass 来安装 Sass除了使用 gem 命令来安装 Sass 之外，还可以通过安装 compass 来安装 Sass，因为 Compass 是基于 Sass 开发的一个框架。也就是说，你安装了 Compass，也就同时安装好了 Sass。 同样的在你的命令终端输入下面的命令： 1sudo gem install sass 执行完上面的命令之后，就开始安装 Compass 和 Sass。 注：Compass 是一个成熟的、基于 Sass 开发的一个框架，这里面集成了很多写好的 mixins 和 Sass 函数。不过在此暂不做过多阐述。 3、本地安装Sass由于有时候直接使用上面的命令安装会让你无法正常实现安装（网络受限原因），当碰到这种情况之时，那么安装需要特殊去处理，可以通过下面的方法来实现 Sass 的正常安装： 可以到 Rubygems 网站上将 Sass 的安装包（http://rubygems.org/gems/sass）下载下来，然后在命令终端输入： 1gem install &lt;把下载的安装包拖到这里&gt; 直接回车即可安装成功。 注：在 iOSX和win10系统平台，可以直接将下载的安装包拖到 “gem install” 后面。 4、淘宝 RubyGems 镜像安装 Sass除了下载 Sass 安装包到本地安装之外，碰到网络原因无法安装时还可以使用淘宝 RubyGems 镜像安装 Sass。只是我们需要通过 gem sources 命令来配置源，先移除默认的 https://rubygems.org 源，然后添加淘宝的源 https://ruby.taobao.org： 第一步：移动默认的源 1gem sources --remove https://rubygems.org/ 第二步：指定淘宝的源 1gem sources -a https://ruby.taobao.org/ 第三步：查看指定的源是不是淘宝源 1gem sources -l 返回结果如下： 12*** CURRENT SOURCES ***https://ruby.taobao.org 请确保只有 ruby.taobao.org。如果无误之后，执行下面的命令： 1gem install sass","categories":[{"name":"Sass","slug":"Sass","permalink":"http://blog.iamxcc.com/categories/Sass/"}],"tags":[{"name":"Sass","slug":"Sass","permalink":"http://blog.iamxcc.com/tags/Sass/"},{"name":"css","slug":"css","permalink":"http://blog.iamxcc.com/tags/css/"}]},{"title":"Git系列之安装","slug":"Git系列之安装","date":"2016-06-16T05:34:53.000Z","updated":"2016-07-27T05:25:40.577Z","comments":true,"path":"2016/06/16/Git系列之安装/","link":"","permalink":"http://blog.iamxcc.com/2016/06/16/Git系列之安装/","excerpt":"最早Git是在Linux上开发的，很长一段时间内，Git也只能在Linux和Unix系统上跑。不过，慢慢地有人把它移植到了Windows上。","text":"最早Git是在Linux上开发的，很长一段时间内，Git也只能在Linux和Unix系统上跑。不过，慢慢地有人把它移植到了Windows上。现在，Git可以在Linux、Unix、Mac和Windows这几大平台上正常运行了。这里主要讲windows下Git的安装，其他平台的可以到网上去搜索解决。win下安装十分简单，因为Git官网已经将其打包了，直接下载下来双击然后按照步骤安装即可。这里是Git官网 安装安装完成后，在开始菜单里找到“Git”-&gt;“Git Bash”，弹出一个类似命令行窗口的东西，就说明Git安装成功！如下图所示：","categories":[{"name":"Git","slug":"Git","permalink":"http://blog.iamxcc.com/categories/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://blog.iamxcc.com/tags/Git/"}]},{"title":"通信协议之Http","slug":"通信协议之Http","date":"2016-06-16T02:54:50.000Z","updated":"2016-07-30T23:20:50.892Z","comments":true,"path":"2016/06/16/通信协议之Http/","link":"","permalink":"http://blog.iamxcc.com/2016/06/16/通信协议之Http/","excerpt":"生活中我们接触的比较多的通信协议有HTTP、TCP、UDP等等。特别是HTTP协议，因为我们每天上网在浏览器中","text":"生活中我们接触的比较多的通信协议有HTTP、TCP、UDP等等。特别是HTTP协议，因为我们每天上网在浏览器中输入的网址基本都可以看到以http://开头的字符串。那么什么是通信协议呢？简而言之就是通信时所遵守的规则，只有双方按照这个规则“说话”，对方才能理解或为之服务。这里只是很口语化的解释，详细的解释可以到这里查看： 百度百科 维基百科 HTTP、TCP、UDP的区别TCP/IP是个协议组，可分为四个层次：网络接口层、网络层、传输层和应用层。 在网络层有IP协议、ICMP协议、ARP协议、RARP协议和BOOTP协议。 在传输层中有TCP协议与UDP协议。 在应用层有FTP、HTTP、TELNET、SMTP、DNS等协议。因此，HTTP本身就是一个协议，是从Web服务器传输超文本到本地浏览器的传送协议。 什么是HTTP协议HTTP全称是HyperText Transfer Protocal，即：超文本传输协议，从1990年开始就在WWW上广泛应用，是现今在WWW上应用最多的协议， Http是应用层协议，当你上网浏览网页的时候，浏览器和Web服务器之间就会通过HTTP在Internet上进行数据的发送和接收。Http是一个基于请求/响应模式的、无状态的协议。即我们通常所说的Request/Response。 URLURL(Uniform Resource Locator) 地址用于描述一个网络上的资源, 基本格式如下12345678schema://host[:port#]/path/.../[?query-string][#anchor]scheme 指定低层使用的协议(例如：http, https, ftp)host HTTP服务器的IP地址或者域名port# HTTP服务器的默认端口是80，这种情况下端口号可以省略。如果使用了别的端口，必须指明，例如 http://www.cnblogs.com:8080/path 访问资源的路径query-string 发送给http服务器的数据anchor- 锚 URL 的一个例子1234567http://www.mywebsite.com/sj/test/test.aspx?name=sviergn&amp;x=true#stuffSchema: httphost: www.mywebsite.compath: /sj/test/test.aspxQuery String: name=sviergn&amp;x=trueAnchor: stuff HTTP的Request/Response先看Request 消息的结构,Request消息分为3部分 第一部分叫Request line。 第二部分叫Request header。 第三部分是body. header和body之间有个空行。 第一行中的Method表示请求方法,比如”POST”,”GET”, Path-to-resoure表示请求的资源， Http/version-number 表示HTTP协议的版本号当使用的是”GET” 方法的时候， body是为空的比如我们打开博客园首页的request 如下GET http://www.cnblogs.com/ HTTP/1.1Host: www.cnblogs.com抽象的东西，难以理解，老感觉是虚的， 所谓眼见为实, 实际见到的东西，我们才能理解和记忆。 我们今天用Fiddler，实际的看看Request和Response.下面我们打开Fiddler 捕捉一个博客园登录的Request 然后分析下它的结构, 在Inspectors tab下以Raw的方式可以看到完整的Request的消息。如下图：","categories":[{"name":"HTTP","slug":"HTTP","permalink":"http://blog.iamxcc.com/categories/HTTP/"}],"tags":[{"name":"HTTP","slug":"HTTP","permalink":"http://blog.iamxcc.com/tags/HTTP/"},{"name":"通信协议","slug":"通信协议","permalink":"http://blog.iamxcc.com/tags/通信协议/"}]},{"title":"wampserver配置多站点","slug":"wampserver配置多站点","date":"2016-06-14T04:54:06.000Z","updated":"2016-07-30T23:19:46.917Z","comments":true,"path":"2016/06/14/wampserver配置多站点/","link":"","permalink":"http://blog.iamxcc.com/2016/06/14/wampserver配置多站点/","excerpt":"一般而言，当我们在本地调试网站时都会有多个站点。这时候为了方便区分各个网站，就需要设置多站点，即给每个站点取一个网址。","text":"一般而言，当我们在本地调试网站时都会有多个站点。这时候为了方便区分各个网站，就需要设置多站点，即给每个站点取一个网址。当然，这个网址只能在本地打开。这里，就介绍一下wampserver在win10下怎么设置多站点。 修改wampserver配置文件在wampserver安装位置\\bin\\apache\\apache\\apache2.4.17\\conf\\httpd.conf文件中查找Include conf/extra/httpd-vhosts.conf，去掉前面的注释#。打开wampserver安装位置\\bin\\apache\\apache\\apache2.4.17\\conf\\extra/httpd-vhosts.conf文件；在最后加入类似内容：（文件路径是自己安装程序的路径） 1234&lt;VirtualHost *:80&gt; DocumentRoot \"D:/wamp/www/blog\"(这是你放程序的文件路径) ServerName www.yoursite.com （这是自己定义的域名）&lt;/VirtualHost&gt; 修改windows下的hosts文件通过win+R在run下输入drivers，打开etc\\hosts文件，在最后加入127.0.0.1 www.yoursite.com （这是自己定义的域名） 结论123456# localhost name resolution is handled within DNS itself.# 127.0.0.1 localhost# ::1 localhost127.0.0.1 blog.iamxcc.com127.0.0.1 www.sf.com 以上是我的hosts文件内容，可以看出我定义了两个站点一个是blog.iamxcc.com, 另一个是www.sf.com。 123456789&lt;VirtualHost *:80&gt; DocumentRoot \"D:\\Web\\wamp64\\www\\my-site\\blog\" ServerName blog.iamxcc.com&lt;/VirtualHost&gt;&lt;VirtualHost *:80&gt; DocumentRoot \"D:\\Web\\wamp64\\www\\my-site\\sf\" ServerName www.sf.com&lt;/VirtualHost&gt; 其中blog.iamxcc.com指向位于D:\\Web\\wamp64\\www\\my-site\\blog下的站点，www.sf.com指向D:\\Web\\wamp64\\www\\my-site\\blog下的站点。到此为止，wampserver配置多任务已经成功。","categories":[{"name":"Wampserver","slug":"Wampserver","permalink":"http://blog.iamxcc.com/categories/Wampserver/"}],"tags":[{"name":"Wampserver","slug":"Wampserver","permalink":"http://blog.iamxcc.com/tags/Wampserver/"},{"name":"Wordpress","slug":"Wordpress","permalink":"http://blog.iamxcc.com/tags/Wordpress/"}]},{"title":"c语言交换a、b的方法","slug":"c语言交换a、b的方法","date":"2016-06-13T15:42:03.000Z","updated":"2016-07-30T23:20:27.691Z","comments":true,"path":"2016/06/13/c语言交换a、b的方法/","link":"","permalink":"http://blog.iamxcc.com/2016/06/13/c语言交换a、b的方法/","excerpt":"C语言中要实现两个变量值的交换一般而言可以分为两种方法：不引入中间变量和引入中间变量。具体代码如下：","text":"C语言中要实现两个变量值的交换一般而言可以分为两种方法：不引入中间变量和引入中间变量。具体代码如下： 常规方法一般而言，在C语言中交换a、b两个值时，我们常用的是使用指针来交换。具体的代码如下：1234567void swap(int *a ,int *b) //通过指针交换两者的值&#123; int c; c = *a; *a = *b; *b= c;&#125; 通过异或来实现除了上面的方法，还有一种更加简洁的办法如下：123456void swap(int &amp;a,int &amp;b) //通过异或交换两者的值&#123; a =a^b; b= a^b; a = b^a;&#125;","categories":[{"name":"C语言","slug":"C语言","permalink":"http://blog.iamxcc.com/categories/C语言/"}],"tags":[{"name":"C语言","slug":"C语言","permalink":"http://blog.iamxcc.com/tags/C语言/"},{"name":"算法","slug":"算法","permalink":"http://blog.iamxcc.com/tags/算法/"}]},{"title":"Hello World","slug":"hello-world","date":"2016-06-12T05:34:53.000Z","updated":"2016-08-03T08:53:03.529Z","comments":true,"path":"2016/06/12/hello-world/","link":"","permalink":"http://blog.iamxcc.com/2016/06/12/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info.","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[{"name":"随笔","slug":"随笔","permalink":"http://blog.iamxcc.com/categories/随笔/"}],"tags":[]},{"title":"一加通过adb刷机","slug":"一加通过adb刷机","date":"2016-05-27T15:26:19.000Z","updated":"2016-07-30T23:20:53.029Z","comments":true,"path":"2016/05/27/一加通过adb刷机/","link":"","permalink":"http://blog.iamxcc.com/2016/05/27/一加通过adb刷机/","excerpt":"经常刷Android机的朋友应该知道刷机方法有两种：一种是线刷，另一种是卡刷。两种方式都十分简单。下面就两种方法分别介绍：","text":"经常刷Android机的朋友应该知道刷机方法有两种：一种是线刷，另一种是卡刷。两种方式都十分简单。下面就两种方法分别介绍： 线刷包与卡刷包的区别1.名字的不同一般而言，名字中带有fastboot的都是线刷包 2.文件中的区别卡刷包线刷包 adb 刷机1adb sideload rom.zip","categories":[{"name":"Android","slug":"Android","permalink":"http://blog.iamxcc.com/categories/Android/"}],"tags":[{"name":"Oneplus","slug":"Oneplus","permalink":"http://blog.iamxcc.com/tags/Oneplus/"},{"name":"Android","slug":"Android","permalink":"http://blog.iamxcc.com/tags/Android/"}]}]}